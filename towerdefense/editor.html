<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense Config Editor</title>
      
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1e1e1e;
            color: #f0f0f0;
        }
        
        .container {
            display: flex;
            gap: 20px;
            height: calc(100vh - 40px);
        }
        
        .sidebar {
            width: 250px;
            background-color: #252525;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }
        
        .tower-list {
            flex: 1;
            overflow-y: auto;
        }
        
        .tower-item {
            padding: 10px;
            margin-bottom: 5px;
            background-color: #333;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .tower-item:hover {
            background-color: #444;
        }
        
        .tower-item.selected {
            background-color: #505050;
            border-left: 4px solid #a0f;
        }
        
        .editor {
            background-color: #252525;
            border-radius: 8px;
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }
        #three-js-container {
            position: absolute;
            width: 256px; 
            height: 256px;
            margin: auto;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
        }
        .preview-canvas-container {
            position: relative;
            width: 600px;
            height: 240px;
        }

        .preview {
            background-color: #252525;
            border-radius: 8px;
            padding: 20px;
            height: 300px;
            position: relative;
        }
        
        #preview-canvas {
            background-color: transparent;
            border-radius: 4px;
        }
        .camera-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px;
            border-radius: 4px;
        }

        .camera-controls button {
            padding: 4px 8px;
            font-size: 0.8em;
        }

        .camera-controls .color-picker {
            width: 24px;
            height: 24px;
            padding: 0;
            border: none;
        }

        .camera-controls .size-slider {
            width: 80px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #444;
            background-color: #333;
            color: #f0f0f0;
            font-family: monospace;
        }
        
        textarea {
            height: 100px;
            resize: vertical;
        }
        
        button {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            margin-right: 10px;
            background-color: #505050;
            color: #f0f0f0;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #606060;
        }
        
        button.primary {
            background-color: #a0f;
        }
        
        button.primary:hover {
            background-color: #b4f;
        }
        
        button.danger {
            background-color: #d00;
        }
        
        button.danger:hover {
            background-color: #f00;
        }
        
        .actions {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .input-row {
            display: flex;
            gap: 2em;
            margin-bottom: 1em;
        }
        
        .input-row .form-group {
            flex: 1;
            margin-bottom: 0;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s linear 0.25s, opacity 0.25s 0s;
        }
        
        .modal.show {
            visibility: visible;
            opacity: 1;
            transition-delay: 0s;
        }
        
        .modal-content {
            background-color: #252525;
            border-radius: 8px;
            padding: 20px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .property-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #444;
            padding: 10px;
            border-radius: 4px;
            background-color: #333;
        }
        
        .property-item {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        .property-item input {
            flex: 1;
        }
        
        .property-item button {
            padding: 4px 8px;
        }
        
        .tab-navigation {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #444;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        
        .tab.active {
            border-bottom: 3px solid #a0f;
            font-weight: bold;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .instructions {
            margin-bottom: 20px;
            padding: 10px;
            background-color: #333;
            border-radius: 4px;
            border-left: 4px solid #a0f;
        }
        
        #grid-display {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
            font-family: monospace;
        }

        .success-message {
            color: lightgreen;
            margin-left: 10px;
            animation: fadeOut 2s forwards;
            animation-delay: 1s;
        }
        .type-selector {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            flex-direction: column;
        }

        .type-selector .tower-item {
            flex: 1;
            text-align: center;
            padding: 8px 5px;
            font-size: 0.9em;
        }

        .tab-navigation {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #444;
        }
        .type-actions {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .small-btn {
            padding: 4px 8px;
            font-size: 0.8em;
            margin-right: 0;
        }

        .warning {
            background-color: rgba(255, 0, 0, 0.1);
            padding: 10px;
            border-radius: 4px;
            border-left: 4px solid #f44;
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        #graphics-container {
            display: flex;
            height: 50vh;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        #graphics-sidebar {
            width: 360px;
            background: linear-gradient(180deg, #2a2a2a, #222);
            border-right: 1px solid #555;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
        }
        #graphics-rightbar {
            width: 360px;
            background: linear-gradient(180deg, #2a2a2a, #222);
            border-right: 1px solid #555;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
        }
        #canvas-container {
            flex: 1;
            position: relative;
            background: #101010;
        }
        #canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #toolbar {
            padding: 15px;
            border-bottom: 1px solid #555;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            background: #333;
        }

        #shape-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        .shape-item {
            padding: 12px;
            margin-bottom: 8px;
            background-color: #383838;
            border: 1px solid #555;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .shape-item:hover {
            background-color: #444;
        }
        .shape-item.active {
            background-color: #4a4a4a;
            border-color: #4CAF50;
            color: #fff;
        }
        #inspector {
            padding: 15px;
            background: #2f2f2f;
            border-top: 1px solid #555;
        }
        .form-row {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .form-row label {
            width: 90px;
            font-size: 14px;
            color: #ccc;
        }
        .form-row input, .form-row select {
            flex: 1;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 4px;
            background-color: #383838;
            color: #e0e0e0;
            font-size: 14px;
        }
        .scene-info {
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            position: absolute;
            bottom: 15px;
            left: 15px;
            border-radius: 6px;
            font-size: 13px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        .button-danger {
            background-color: #e53935;
        }
        .button-danger:hover {
            background-color: #d32f2f;
        }
        #move-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        #move-modal > div {
            background: #333;
            padding: 25px;
            border-radius: 8px;
            width: 320px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        #move-modal h3 {
            margin-bottom: 20px;
            color: #e0e0e0;
            font-size: 18px;
        }
        #move-modal button {
            width: 48%;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h2>Editor</h2>
            <div class="tower-list" id="tower-list">
                <!-- Tower list will be dynamically populated -->
            </div>
            <div style="margin-top: auto; padding-top: 10px;">
                <button class="primary" id="add-tower-btn" style="width: 100%;">Add New Tower</button>
                <button id="import-export-btn" style="width: 100%; margin-top: 10px;">Import/Export Config</button>
            </div>
        </div>
        
        <div class="main-content">
            <div id="graphics-container">
                <div id="graphics-sidebar">
                    <div id="toolbar">
                        <button id="add-shape">Add Shape</button>
                        <button id="duplicate-shape">Duplicate</button>
                        <button id="delete-shape" class="button-danger">Delete</button>
                        <button id="scale-all">Scale All</button>
                        <button id="move-all">Move All</button>
                        <button id="generate-isometric">Isometric Sprites</button> 
                    </div>
                    <div id="shape-list"></div>                    
                </div>
                <div id="canvas-container">
                    <canvas id="canvas"></canvas>
                    <div class="scene-info">
                        <div>Shapes: <span id="shape-count">0</span></div>
                        <div>Selected: <span id="selected-shape">None</span></div>
                        <div><small>Controls: Left-click to select, Drag to rotate, Right-drag to pan, Scroll to zoom</small></div>
                    </div>
                </div>
                
                <div id="graphics-rightbar">
                    <div id="inspector"></div>
                    <div id="json-editor" style="display: none">
                        <textarea id="json-content" placeholder="Edit JSON here..."></textarea>
                    </div>
                </div>
            </div>
            <div class="editor" id="editor">
                <div class="instructions">
                    Select a tower from the sidebar or create a new one to start editing.
                </div>
                <!-- Editor form will be dynamically populated -->
            </div>
        </div>
    </div>
    
    <!-- Import/Export Modal -->
    <div class="modal" id="import-export-modal">
        <div class="modal-content">
            <h2>Import/Export Configuration</h2>
            
            <div class="tab-navigation">
                <div class="tab active" data-tab="import">Import</div>
                <div class="tab" data-tab="export">Export</div>
            </div>
            
            <div class="tab-content active" id="import-tab">
                <p>Paste your tower configuration below:</p>
                <textarea id="import-textarea" rows="15"></textarea>
                <div class="actions">
                    <button class="primary" id="import-btn">Import Configuration</button>
                    <button id="close-import-export-modal">Cancel</button>
                </div>
            </div>
            
            <div class="tab-content" id="export-tab">
                <p>Copy your tower configuration:</p>
                <textarea id="export-textarea" rows="15" readonly></textarea>
                <div class="actions">
                    <button class="primary" id="copy-export-btn">Copy to Clipboard</button>
                    <button id="close-export-modal">Close</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- New Tower Modal -->
    <div class="modal" id="new-object-modal">
        <div class="modal-content">
            <h2>Create New Object</h2>
            <div class="form-group">
                <label for="new-object-id">Tower ID:</label>
                <input type="text" id="new-object-id" placeholder="e.g. fireTower">
            </div>
            <div class="form-group">
                <label for="new-object-name">Display Name:</label>
                <input type="text" id="new-object-name" placeholder="e.g. Fire Tower">
            </div>
            <div class="actions">
                <button class="primary" id="create-object-btn">Create Tower</button>
                <button id="close-new-object-modal">Cancel</button>
            </div>
        </div>
    </div>
    
    <div id="move-modal">
        <div>
            <h3>Move All Shapes</h3>
            <div class="form-row">
                <label for="move-x">X Offset:</label>
                <input type="number" id="move-x" value="0" step="0.5">
            </div>
            <div class="form-row">
                <label for="move-y">Y Offset:</label>
                <input type="number" id="move-y" value="0" step="0.5">
            </div>
            <div class="form-row">
                <label for="move-z">Z Offset:</label>
                <input type="number" id="move-z" value="0" step="0.5">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button id="move-cancel">Cancel</button>
                <button id="move-apply">Apply</button>
            </div>
        </div>
    </div>

    <div id="isometric-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #333; padding: 25px; border-radius: 8px; width: 320px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);">
            <h3 style="margin-bottom: 20px; color: #e0e0e0; font-size: 18px;">Generate Isometric Sprites</h3>
            <div class="form-row">
                <label for="iso-frustum">Frustum Size:</label>
                <input type="number" id="iso-frustum" value="48" step="1" min="1">
            </div>
            <div class="form-row">
                <label for="iso-distance">Distance:</label>
                <input type="number" id="iso-distance" value="100" step="1" min="1">
            </div>
            <div class="form-row">
                <label for="iso-size">Sprite Size:</label>
                <input type="number" id="iso-size" value="64" step="1" min="1">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button id="iso-cancel">Cancel</button>
                <button id="iso-generate">Generate</button>
            </div>
        </div>
    </div>


    <script type="module">
    import * as THREE from './three.module.min.js';
    
    import { OrbitControls } from './three.orbitControls.js';


    (function() {
        /**
         * Tower Defense Config Editor
         * A tool for creating and editing configurations for tower defense games
         */
        
        // Configuration constants
        const CONFIG = {
            GRID_SIZE: 40,
            DEFAULT_TOWER_SIZE: 30,
            DEFAULT_TOWER_COLOR: '#ffffff',
            DEFAULT_RENDER: {
                canvasWidth: 64,
                canvasHeight: 64,
                shapes: [{
                    type: 'circle',
                    x: 32,
                    y: 32,
                    size: 32,
                    color: '#000000'
                }]
            }
        };
        let threeJsCamera = null;
        let currentCameraLocation = 0;
        
        const cameraDistance = 96;
        let cameraLocations = [ 
            { x: cameraDistance, y: cameraDistance, z: cameraDistance },
            { x: cameraDistance, y: cameraDistance, z: -cameraDistance },
            { x: -cameraDistance, y: cameraDistance, z: -cameraDistance },
            { x: -cameraDistance, y: cameraDistance, z: cameraDistance }
        ];

        //const threeJsContext = setupThreeJsRenderer('three-js-container');
        // Application state changes
        const state = {
            objectTypes: {
                towers: {},
                enemies: {},
                projectiles: {}
            },
            objectTypeDefinitions: [
                { id: 'towers', name: 'Towers', singular: 'Tower' },
                { id: 'enemies', name: 'Enemies', singular: 'Enemy' },
                { id: 'projectiles', name: 'Projectiles', singular: 'Projectile' }
            ],
            selectedType: 'towers',
            selectedObject: null,
            isDragging: false,
            objectPosition: { x: 300, y: 120 }
        };
        // Default sample data - expand with enemy and projectile types
        const DEFAULT_CONFIG = {
            towers: {
                bloodCore: { 
                    color: '#a0f', 
                    size: 30 
                },
                batSwarm: { 
                    info: 'Fast attack speed with moderate damage. Good for groups of weaker enemies.', 
                    color: '#a0f', 
                    size: 30, 
                    projectile: 'bat', 
                    range: 120, 
                    damage: 1, 
                    attackSpeed: 20, 
                    cost: 50, 
                    piercing: 0, 
                    critChance: 0.05, 
                    critMultiplier: 1.5, 
                    leech: 0, 
                    population: 1 
                },
                bloodGolem: { 
                    info: 'Provides 5 additional max population.', 
                    color: '#d00', 
                    size: 40, 
                    projectile: 'bloodBolt', 
                    range: 0, 
                    damage: 0, 
                    attackSpeed: 1000, 
                    cost: 100, 
                    piercing: 0, 
                    critChance: 0.1, 
                    critMultiplier: 2, 
                    leech: 0, 
                    supply: 5 
                },
                miner: { 
                    info: 'Mines additional gold every second.', 
                    color: '#d00', 
                    size: 40, 
                    cost: 50, 
                    attackSpeed: 50, 
                    mineAmt: 1, 
                    population: 1 
                }
            },
            enemies: {
                zombie: {
                    info: 'Slow moving enemy with moderate health',
                    color: '#0d0',
                    size: 25,
                    health: 50,
                    speed: 1,
                    damage: 1,
                    reward: 5
                },
                runner: {
                    info: 'Fast moving enemy with low health',
                    color: '#0f0',
                    size: 20,
                    health: 20,
                    speed: 2.5,
                    damage: 1,
                    reward: 3
                }
            },
            projectiles: {
                arrow: {
                    info: 'Standard arrow projectile',
                    color: '#fff',
                    size: 10,
                    speed: 5,
                    pierce: 0,
                    isCircle: true
                },
                fireball: {
                    info: 'Explosive projectile with area damage',
                    color: '#f50',
                    size: 15,
                    speed: 3,
                    aoe: 30,
                    isCircle: true
                }
            }
        };
        // Cache DOM elements
        const elements = {
            towerList: document.getElementById('tower-list'),
            editor: document.getElementById('editor'),
            previewCanvas: document.getElementById('preview-canvas'),
            gridDisplay: document.getElementById('grid-display'),
            importExportModal: document.getElementById('import-export-modal'),
            importTextarea: document.getElementById('import-textarea'),
            exportTextarea: document.getElementById('export-textarea'),
            newObjectModal: document.getElementById('new-object-modal'),
            newObjectIdInput: document.getElementById('new-object-id'),
            newObjectNameInput: document.getElementById('new-object-name'),
            tabs: document.querySelectorAll('.tab'),
            rotateLeftBtn: document.getElementById('rotateLeftBtn'),
            rotateRightBtn: document.getElementById('rotateRightBtn'),
            clearDrawingBtn: document.getElementById('clearDrawingBtn'),
            colorPicker: document.getElementById('colorPicker'),
            sizeSlider: document.getElementById('sizeSlider')
        };
        let drawingState = {
            currentShape: 'circle',
            currentColor: '#000000',
            currentSize: 32,
            isDrawing: false
        };
        function getSingularType(typeId) {
            const typeDef = state.objectTypeDefinitions.find(t => t.id === typeId);
            return typeDef ? typeDef.singular : typeId.slice(0, -1);
        }

        // Add this function to get the plural form of a type
        function getPluralType(typeId) {
            const typeDef = state.objectTypeDefinitions.find(t => t.id === typeId);
            return typeDef ? typeDef.name : typeId;
        }
        // HTML for object type selection in sidebar
        function renderTypeSelector() {
            let html = `<h2>Object Types</h2>
                        <div class="type-selector">`;
            
            state.objectTypeDefinitions.forEach(type => {
                html += `<div class="tower-item ${state.selectedType === type.id ? 'selected' : ''}" data-type="${type.id}">${type.name}</div>`;
            });
            
            html += `</div>
                    <div class="type-actions">
                        <button id="add-type-btn" class="small-btn">Add Type</button>
                        ${state.objectTypeDefinitions.length > 1 ? `<button id="remove-type-btn" class="small-btn danger">Remove Type</button>` : ''}
                    </div>
                    <h2>${getPluralType(state.selectedType)}</h2>`;
            
            return html;
        }        
        // Replace renderTowerList function
        function renderObjectList() {
            // Add type selector
            elements.towerList.innerHTML = renderTypeSelector();
            
            // Add objects of the selected type
            Object.keys(state.objectTypes[state.selectedType] || {}).forEach(objId => {
                const objectItem = document.createElement('div');
                objectItem.className = `tower-item ${state.selectedObject === objId ? 'selected' : ''}`;
                objectItem.textContent = objId;
                objectItem.addEventListener('click', () => selectObject(objId));
                elements.towerList.appendChild(objectItem);
            });
            
            // Add event listeners for type selection
            document.querySelectorAll('.type-selector .tower-item').forEach(item => {
                item.addEventListener('click', () => {
                    state.selectedType = item.dataset.type;
                    state.selectedObject = null;
                    renderObjectList();
                    renderEditor();
                    renderPreview();
                    updateSidebarButtons();
                });
            });
            
            // Add event listeners for type actions
            document.getElementById('add-type-btn')?.addEventListener('click', showAddTypeModal);
            document.getElementById('remove-type-btn')?.addEventListener('click', showRemoveTypeModal);
        }
        
        // Replace selectTower function
        function selectObject(objId) {
            state.selectedObject = objId;
            renderObjectList();
            renderEditor();
            renderPreview();
        }
        
        // Update the editor UI
        function renderEditor() {
            const singularType = getSingularType(state.selectedType); // Remove 's' to get singular
            
            if (!state.selectedObject) {
                elements.editor.innerHTML = `
                    <div class="instructions">
                        Select a ${singularType} from the sidebar or create a new one to start editing.
                    </div>
                `;
                return;
            }
            
            elements.editor.innerHTML = `
                <h2>Editing: ${state.selectedObject} (${singularType})</h2>
                
                <div class="tab-content active" id="advanced-tab">  
                    <h3>Properties</h3>
                    <div class="property-list" id="custom-properties">
                        <!-- Custom properties will be rendered here -->
                    </div>
                    <button id="add-property-btn" style="margin-top: 10px;">Add Custom Property</button>
                </div>
                
                <div class="actions">
                    <div>
                        <button class="primary" id="save-object-btn">Save ${singularType}</button>
                        <button id="revert-changes-btn">Revert Changes</button>
                    </div>
                    <button class="danger" id="delete-object-btn">Delete ${singularType}</button>
                </div>
            `;
            
            // Setup property editor
            const customPropertiesContainer = document.getElementById('custom-properties');
            renderCustomProperties(customPropertiesContainer, state.objectTypes[state.selectedType][state.selectedObject]);
            
            // Add event listeners for editor controls
            document.getElementById('add-property-btn').addEventListener('click', () => {
                addCustomProperty(customPropertiesContainer, '', '');
            });
            
            document.getElementById('save-object-btn').addEventListener('click', saveObject);
            document.getElementById('revert-changes-btn').addEventListener('click', () => {
                selectObject(state.selectedObject);
            });
            document.getElementById('delete-object-btn').addEventListener('click', deleteObject);
        }
        
        /**
         * Render custom properties in the editor
         */
        function renderCustomProperties(container, object) {
            container.innerHTML = '';
            if( !object.render ) {
                object.render = JSON.parse(JSON.stringify(CONFIG.DEFAULT_RENDER));
            }
            Object.entries(object).forEach(([key, value]) => {
                addCustomProperty(container, key, value);
            });
        }
        
        /**
         * Add a custom property input to the editor
         */
        function addCustomProperty(container, key, value) {
            const propertyItem = document.createElement('div');
            propertyItem.className = 'property-item';
            
            const keyInput = document.createElement('input');
            keyInput.type = 'text';
            keyInput.placeholder = 'Property Name';
            keyInput.value = key;
            keyInput.className = 'property-key';
            
            const valueInput = document.createElement('input');
            let type = 'text';
            if( key === 'color' ) {
                type = 'color';
            } else if( key === 'render' ) {
                type = 'textarea';
                value = JSON.stringify(value);
                valueInput.setAttribute('id', 'render-value');
            }
            valueInput.type = type;
            valueInput.placeholder = 'Value';
            valueInput.value = value;
            valueInput.className = 'property-value';
            
            const removeBtn = document.createElement('button');
            removeBtn.textContent = 'Remove';
            removeBtn.className = 'danger';
            removeBtn.addEventListener('click', () => {
                container.removeChild(propertyItem);
            });
            
            propertyItem.appendChild(keyInput);
            propertyItem.appendChild(valueInput);
            propertyItem.appendChild(removeBtn);
            container.appendChild(propertyItem);
        }
        
        // Replace saveTower function
        function saveObject() {
            if (!state.selectedObject) return;
            
            const object = {}; 
            
            // Collect custom properties
            document.querySelectorAll('.property-item').forEach(item => {
                const keyInput = item.querySelector('.property-key');
                const valueInput = item.querySelector('.property-value');
                
                if (keyInput.value && valueInput.value) {
                    let value = valueInput.value;
                    
                    // Try to parse value types
                    if (!isNaN(parseFloat(value)) && isFinite(value)) {
                        value = parseFloat(value);
                    } else if (value.toLowerCase() === 'true') {
                        value = true;
                    } else if (value.toLowerCase() === 'false') {
                        value = false;
                    }
                    if(keyInput.value == "render") {
                        value = JSON.parse(value);
                    }
                    object[keyInput.value] = value;
                }
            });
            
            // Update the config
            state.objectTypes[state.selectedType][state.selectedObject] = object;
            
            // Update UI
            renderObjectList();
            renderPreview();
            saveToLocalStorage();
            // Show success message
            const actions = document.querySelector('.actions');
            const successMsg = document.createElement('span');
            successMsg.textContent = 'Changes saved!';
            successMsg.className = 'success-message';
            actions.appendChild(successMsg);
            
            setTimeout(() => {
                if (actions.contains(successMsg)) {
                    actions.removeChild(successMsg);
                }
            }, 2000);
        }
                
        // Replace deleteTower function
        function deleteObject() {
            if (!state.selectedObject) return;
            
            const singularType = state.selectedType.slice(0, -1);
            
            if (confirm(`Are you sure you want to delete "${state.selectedObject}" ${singularType}?`)) {
                delete state.objectTypes[state.selectedType][state.selectedObject];
                state.selectedObject = null;
                renderObjectList();
                renderEditor();
                renderPreview();
            }
        }

        
        /**
         * Render the preview canvas
         */
         function renderPreview() {
            
            if (state.selectedObject && state.objectTypes[state.selectedType][state.selectedObject]) {
                const object = state.objectTypes[state.selectedType][state.selectedObject];
 
                drawObject(object, state.objectPosition);               

            }
        }
        
          
        /**
         * Draw a tower at the specified position
         */
        function drawObject(object, position) {
            const renderData = object.render || CONFIG.DEFAULT_RENDER;
            
                // Create a custom event with data
            const myCustomEvent = new CustomEvent('viewObject', {
                detail: renderData, // Custom data
                bubbles: true, // Allows the event to bubble up (optional)
                cancelable: true // Allows the event to be canceled (optional)
            });

            // Dispatch the event
            document.body.dispatchEvent(myCustomEvent);

            //renderShapes(renderData, threeJsContext);
        }

       
        function addShapeToRender(x, y) {
            if (!state.selectedObject) return;
            
            const object = state.objectTypes[state.selectedType][state.selectedObject];
            const render = object.render || JSON.parse(JSON.stringify(CONFIG.DEFAULT_RENDER));
            
            // Convert canvas coordinates to render coordinates (64x64 space)
            const renderX = Math.round(x - (state.objectPosition.x - 32));
            const renderY = Math.round(y - (state.objectPosition.y - 32));
            
            if (renderX >= 0 && renderX <= 64 && renderY >= 0 && renderY <= 64) {
                const shape = {
                    type: drawingState.currentShape,
                    x: renderX,
                    y: renderY,
                    size: drawingState.currentSize,
                    color: drawingState.currentColor
                };
                
                render.shapes.push(shape);
                object.render = render;
                document.getElementById("render-value").value = JSON.stringify(render);
                renderPreview();
            }
        }

        function clearRender() {
            if (!state.selectedObject) return;
            
            const object = state.objectTypes[state.selectedType][state.selectedObject];
            object.render = { canvasWidth: 64, canvasHeight: 64, shapes: [] };
            renderPreview();
        }
        /**
         * Generate JavaScript code for the current configuration
         */
        function generateConfigCode() {
            let code = `{\n`;
            
            Object.entries(state.objectTypes[state.selectedType]).forEach(([objId, config]) => {
                code += `    ${objId}: { `;
                
                const props = Object.entries(config)
                    .filter(([_, value]) => value !== undefined && value !== null)
                    .map(([key, value]) => {
                        if (typeof value === 'string') {
                            return `${key}: '${value}'`;
                        } if(typeof value === 'object' ) {
                            return `${key}: ${JSON.stringify(value)}`;
                        } else {
                            return `${key}: ${value}`;
                        }
                    })
                    .join(', ');
                
                code += `${props} },\n`;
            });
            
            code += '}';
            
            return code;
        }

        
        /**
         * Parse configuration code and convert to object
         */
        function parseConfigCode(code) {
            try {
                // Extract the config object with variable pattern matching
                const regex = /\{([^;]*(?:\{[^;]*\}[^;]*)*)\}/s;
                const match = code.match(regex);
                
                if (!match) {
                    throw new Error('Could not find configuration in the code');
                }
                                
                // Create a valid JavaScript expression
                const objText = `(${match[0]})`;
                
                // Parse the JavaScript object
                const config = eval(objText);
                
                // Determine the actual object type
                let objectType = state.selectedType;
                
                return { type: objectType, config };
            } catch (error) {
                console.error('Error parsing configuration:', error);
                alert('Failed to parse configuration. Please check format and try again.');
                return null;
            }
        }
        
        /**
         * Create a new tower
         */
        function createNewObject() {
            const id = elements.newObjectIdInput.value.trim();
            const name = elements.newObjectNameInput.value.trim();
            
            if (!id) {
                alert(`Please enter an ID`);
                return;
            }
            
            if (state.objectTypes[state.selectedType][id]) {
                alert(`Object with ID "${id}" already exists`);
                return;
            }
            
            // Create default properties based on type
            let defaultProps = {
                info: name || id,
                color: CONFIG.DEFAULT_TOWER_COLOR,
                size: CONFIG.DEFAULT_TOWER_SIZE,
                render: JSON.parse(JSON.stringify(CONFIG.DEFAULT_RENDER))
            };
            
            state.objectTypes[state.selectedType][id] = defaultProps;
            
            elements.newObjectModal.classList.remove('show');
            renderObjectList();
            selectObject(id);
        }
        
        /**
         * Set up event listeners
         */
        function setupEventListeners() {
   
            // Import/Export handling
            document.getElementById('import-export-btn').addEventListener('click', () => {
                elements.exportTextarea.value = generateConfigCode();
                elements.importExportModal.classList.add('show');
            });
            
            document.getElementById('close-import-export-modal').addEventListener('click', () => {
                elements.importExportModal.classList.remove('show');
            });
            
            document.getElementById('close-export-modal').addEventListener('click', () => {
                elements.importExportModal.classList.remove('show');
            });
            
            document.getElementById('copy-export-btn').addEventListener('click', copyExportToClipboard);
            
            document.getElementById('import-btn').addEventListener('click', importConfig);
            
            // New object handling
            document.getElementById('add-tower-btn').addEventListener('click', () => {
                elements.newObjectIdInput.value = '';
                elements.newObjectNameInput.value = '';
                updateNewObjectModal();
                elements.newObjectModal.classList.add('show');
            });
            
            document.getElementById('close-new-object-modal').addEventListener('click', () => {
                elements.newObjectModal.classList.remove('show');
            });
            
            document.getElementById('create-object-btn').addEventListener('click', createNewObject);
            
            // Tab navigation
            elements.tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    elements.tabs.forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    tab.classList.add('active');
                    document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
                });
            });
            document.body.addEventListener('saveObjectGraphics', (event) => {
                let renderData = event.detail;
                console.log("saving", renderData);
                document.getElementById('render-value').value = JSON.stringify(renderData);
            });
        }
  
        /**
         * Copy export code to clipboard
         */
        function copyExportToClipboard() {
            elements.exportTextarea.select();
            document.execCommand('copy');
            const copyBtn = document.getElementById('copy-export-btn');
            copyBtn.textContent = 'Copied!';
            saveToLocalStorage();
            setTimeout(() => {
                copyBtn.textContent = 'Copy to Clipboard';
            }, 2000);
        }

        function saveToLocalStorage() {
            
            localStorage.setItem("objectTypes", JSON.stringify(state.objectTypes));
            localStorage.setItem("objectTypeDefinitions", JSON.stringify(state.objectTypeDefinitions));
        }
        
        /**
         * Import configuration from textarea
         */
        function importConfig() {
            const code = elements.importTextarea.value;
            const result = parseConfigCode(code);
            
            if (result) {
                state.objectTypes[result.type] = result.config;
                state.selectedType = result.type;
                renderObjectList();
                elements.importExportModal.classList.remove('show');
                
                if (Object.keys(state.objectTypes[state.selectedType]).length > 0) {
                    selectObject(Object.keys(state.objectTypes[state.selectedType])[0]);
                } else {
                    state.selectedObject = null;
                    renderEditor();
                    renderPreview();
                }
                saveToLocalStorage();
            }
        }
        // Update new object modal
        function updateNewObjectModal() {
            const singularType = getSingularType(state.selectedType);
            document.querySelector('#new-object-modal h2').textContent = `Create New ${singularType.charAt(0).toUpperCase() + singularType.slice(1)}`;
            document.querySelector('#new-object-modal label[for="new-object-id"]').textContent = `${singularType.charAt(0).toUpperCase() + singularType.slice(1)} ID:`;
            document.getElementById('create-object-btn').textContent = `Create ${singularType.charAt(0).toUpperCase() + singularType.slice(1)}`;
        }

        function createNewType() {
            const typeId = document.getElementById('new-type-id').value.trim();
            const typeName = document.getElementById('new-type-name').value.trim();
            const typeSingular = document.getElementById('new-type-singular').value.trim();
            
            if (!typeId) {
                alert('Please enter a Type ID');
                return;
            }
            
            if (state.objectTypes[typeId]) {
                alert(`Type "${typeId}" already exists`);
                return;
            }
            
            // Add the new type
            state.objectTypes[typeId] = {};
            state.objectTypeDefinitions.push({
                id: typeId,
                name: typeName || typeId.charAt(0).toUpperCase() + typeId.slice(1),
                singular: typeSingular || typeId.slice(0, -1).charAt(0).toUpperCase() + typeId.slice(0, -1).slice(1)
            });
            
            // Switch to the new type
            state.selectedType = typeId;
            state.selectedObject = null;
            
            // Close the modal and update UI
            document.getElementById('add-type-modal').classList.remove('show');
            renderObjectList();
            renderEditor();
            renderPreview();
            updateSidebarButtons();
            saveToLocalStorage();
        }

        function showAddTypeModal() {
            // Create the modal if it doesn't exist
            if (!document.getElementById('add-type-modal')) {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.id = 'add-type-modal';
                modal.innerHTML = `
                    <div class="modal-content">
                        <h2>Add New Object Type</h2>
                        <div class="form-group">
                            <label for="new-type-id">Type ID (plural, e.g. "weapons"):</label>
                            <input type="text" id="new-type-id" placeholder="e.g. weapons">
                        </div>
                        <div class="form-group">
                            <label for="new-type-name">Display Name (plural):</label>
                            <input type="text" id="new-type-name" placeholder="e.g. Weapons">
                        </div>
                        <div class="form-group">
                            <label for="new-type-singular">Singular Name:</label>
                            <input type="text" id="new-type-singular" placeholder="e.g. Weapon">
                        </div>
                        <div class="actions">
                            <button class="primary" id="create-type-btn">Create Type</button>
                            <button id="close-add-type-modal">Cancel</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Add event listeners
                document.getElementById('create-type-btn').addEventListener('click', createNewType);
                document.getElementById('close-add-type-modal').addEventListener('click', () => {
                    document.getElementById('add-type-modal').classList.remove('show');
                });
            }
            
            // Show the modal
            document.getElementById('add-type-modal').classList.add('show');
        }

        function showRemoveTypeModal() {
            // Create the modal if it doesn't exist
            if (!document.getElementById('remove-type-modal')) {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.id = 'remove-type-modal';
                modal.innerHTML = `
                    <div class="modal-content">
                        <h2>Remove Object Type</h2>
                        <div class="warning" style="color: #f44; margin: 10px 0;">
                            Warning: This will permanently delete all objects of this type!
                        </div>
                        <div class="actions">
                            <button class="danger" id="confirm-remove-type-btn">Remove Type</button>
                            <button id="close-remove-type-modal">Cancel</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Add event listeners
                document.getElementById('confirm-remove-type-btn').addEventListener('click', removeSelectedType);
                document.getElementById('close-remove-type-modal').addEventListener('click', () => {
                    document.getElementById('remove-type-modal').classList.remove('show');
                });
            }
            
            // Show the modal
            document.getElementById('remove-type-modal').classList.add('show');
        }

        function removeSelectedType() {
            const typeId = state.selectedType;
            
            if (!typeId) return;
            
            // Prevent removing all types
            if (state.objectTypeDefinitions.length <= 1) {
                alert('Cannot remove the last object type');
                return;
            }
            
            // Remove the type
            delete state.objectTypes[typeId];
            state.objectTypeDefinitions = state.objectTypeDefinitions.filter(type => type.id !== typeId);
            
            // Switch to the first available type
            state.selectedType = state.objectTypeDefinitions[0].id;
            state.selectedObject = null;
            
            // Close the modal and update UI
            document.getElementById('remove-type-modal').classList.remove('show');
            renderObjectList();
            renderEditor();
            renderPreview();
            updateSidebarButtons();
            saveToLocalStorage();
        }
        // Update HTML for sidebar buttons
        function updateSidebarButtons() {
            const singularType = getSingularType(state.selectedType);
            document.getElementById('add-tower-btn').textContent = `Add New ${singularType}`;
            document.getElementById('import-export-btn').textContent = `Import/Export ${getPluralType(state.selectedType)}`;
        }

        /**
         * Application initialization
         */
        function init() {
            let savedObjectTypes = localStorage.getItem("objectTypes");
            let objectTypeDefinitions = localStorage.getItem("objectTypeDefinitions");
            if( savedObjectTypes && objectTypeDefinitions ) {
                state.objectTypes = JSON.parse(savedObjectTypes);
                state.objectTypeDefinitions = JSON.parse(objectTypeDefinitions);
            } else {
                // Initialize state with default configs
                state.objectTypes = { ...DEFAULT_CONFIG };
            }    
                 
            // Set up event listeners
            setupEventListeners();
            
            // Render initial UI
            renderObjectList();
            updateSidebarButtons();
            
            if (Object.keys(state.objectTypes[state.selectedType]).length > 0) {
                selectObject(Object.keys(state.objectTypes[state.selectedType])[0]);
            }            
        }
        
           
        // Initialize the application
        init();
    })();
    
    
    (function() {
        // Global variables
        let camera, scene, renderer, controls;
        let renderData = { shapes: [] };
        let selectedShapeIndex = -1;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let selectedOutline, originalMaterials = new Map();
        let isDragging = false;
        let clickStartTime = 0;
        
        // Initialize the application
        function init() {
            initThreeJS();
            initEventListeners();
            
            // Initial render
            renderShapes(renderData, { scene }, false);
            updateShapeList();
            animate();
        }
        
        // Initialize Three.js
        function initThreeJS() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.x = 100;
            camera.position.y = 100;
            camera.position.z = 100;
            camera.lookAt(0, 0, 0);
            // Create renderer
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            
            // Add grid helper
            const gridHelper = new THREE.GridHelper(100, 100);
            scene.add(gridHelper);
            
            // Add axes helper
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // Create raycaster for object selection
            raycaster = new THREE.Raycaster();
            
            // Add orbit controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            });
        }

        
        // Show the isometric modal
        function showIsometricModal() {
            document.getElementById('isometric-modal').style.display = 'block';
        }

        // Generate isometric sprites
        function generateIsometricSprites() {
            const frustumSize = parseFloat(document.getElementById('iso-frustum').value) || 48;
            const cameraDistance = parseFloat(document.getElementById('iso-distance').value) || 100;
            const size = parseFloat(document.getElementById('iso-size').value) || 64;
            const aspect = 1; // Square images for simplicity
            const tempRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            tempRenderer.setSize(size, size);
            // Hide the modal
            document.getElementById('isometric-modal').style.display = 'none';
            // Create a temporary canvas for rendering
            const renderTarget = new THREE.WebGLRenderTarget(size, size);
            const cameras = [
                new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000), // Front
                new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000), // Left
                new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000), // Right
                new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000)  // Back
            ];

            
            // Create scene and lights
            const scene = new THREE.Scene();
            const light = new THREE.AmbientLight(0xffffff, 5);
            scene.add(light);

            // Create objects from JSON and add to scene
            createObjectsFromJSON(renderData, scene);
           

            // Position each camera at different angles
            cameras[0].position.set(cameraDistance, cameraDistance, cameraDistance); // Front
            cameras[1].position.set(-cameraDistance, cameraDistance, cameraDistance); // Left
            cameras[2].position.set(cameraDistance, cameraDistance, -cameraDistance); // Right
            cameras[3].position.set(-cameraDistance, cameraDistance, -cameraDistance); // Back

            cameras.forEach(camera => camera.lookAt(0, 0, 0));

            // Capture images
            const sprites = [];
            for (const camera of cameras) {
                tempRenderer.setRenderTarget(renderTarget);
                tempRenderer.render(scene, camera);

                // Read pixels from render target
                const buffer = new Uint8Array(size * size * 4);
                tempRenderer.readRenderTargetPixels(renderTarget, 0, 0, size, size, buffer);

                // Flip the buffer vertically
                const flippedBuffer = new Uint8Array(size * size * 4);
                for (let y = 0; y < size; y++) {
                    const srcRowStart = y * size * 4;
                    const destRowStart = (size - 1 - y) * size * 4;
                    flippedBuffer.set(buffer.subarray(srcRowStart, srcRowStart + size * 4), destRowStart);
                }
                // Create a canvas to display the image
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(size, size);
                imageData.data.set(flippedBuffer);
                ctx.putImageData(imageData, 0, 0);

                sprites.push(canvas.toDataURL());
            }

            // Reset renderer
            tempRenderer.setRenderTarget(null);
            tempRenderer.dispose();
            renderTarget.dispose();
            // Display the sprites
            displayIsometricSprites(sprites);
        }

        // Display the generated isometric sprites
        function displayIsometricSprites(sprites) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.7);
                z-index: 1000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: #333;
                padding: 20px;
                border-radius: 8px;
                max-width: 80%;
                max-height: 80%;
                overflow: auto;
                text-align: center;
            `;

            const title = document.createElement('h3');
            title.textContent = 'Isometric Sprites';
            title.style.color = '#e0e0e0';
            content.appendChild(title);

            const grid = document.createElement('div');
            grid.style.cssText = `
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                margin-top: 20px;
            `;

            sprites.forEach((src, index) => {
                const img = document.createElement('img');
                img.src = src;
                img.style.maxWidth = '100%';
                img.alt = `Isometric View ${index + 1}`;
                grid.appendChild(img);
            });

            const closeButton = document.createElement('button');
            closeButton.textContent = 'Close';
            closeButton.style.cssText = `
                margin-top: 20px;
                padding: 8px 16px;
                background-color: #4CAF50;
                color: #fff;
                border: none;
                border-radius: 6px;
                cursor: pointer;
            `;
            closeButton.addEventListener('click', () => document.body.removeChild(modal));

            content.appendChild(grid);
            content.appendChild(closeButton);
            modal.appendChild(content);
            document.body.appendChild(modal);
        }
        // Add this function
        function scaleAllShapes() {
            if (renderData.shapes.length === 0) return;
            
            const scaleFactor = parseFloat(prompt("Enter scale factor (e.g. 2 for double size, 0.5 for half size):", "1"));
            
            if (isNaN(scaleFactor) || scaleFactor <= 0) {
                alert("Please enter a valid positive number");
                return;
            }
            
            // Calculate the center point of all shapes (this will be our scaling origin)
            let centerX = 0, centerY = 0, centerZ = 0;
            renderData.shapes.forEach(shape => {
                centerX += shape.x || 0;
                centerY += shape.y || 0;
                centerZ += shape.z || 0;
            });
            
            centerX /= renderData.shapes.length;
            centerY /= renderData.shapes.length;
            centerZ /= renderData.shapes.length;
            
            // Scale each shape's dimensions and adjust positions relative to center
            renderData.shapes.forEach(shape => {
                // Scale dimensions
                if (shape.size) shape.size *= scaleFactor;
                if (shape.width) shape.width *= scaleFactor;
                if (shape.height) shape.height *= scaleFactor;
                if (shape.depth) shape.depth *= scaleFactor;
                if (shape.tubeSize) shape.tubeSize *= scaleFactor;
                
                // Scale positions relative to center point
                shape.x = centerX + ((shape.x || 0) - centerX) * scaleFactor;
                shape.y = centerY + ((shape.y || 0) - centerY) * scaleFactor;
                shape.z = centerZ + ((shape.z || 0) - centerZ) * scaleFactor;
            });
            
            renderShapes(renderData, { scene });
            updateShapeList();
        }
        // Initialize event listeners
        function initEventListeners() {
            // Add shape button
            document.getElementById('add-shape').addEventListener('click', addNewShape);
            
            // Duplicate shape button
            document.getElementById('duplicate-shape').addEventListener('click', duplicateSelectedShape);
            
            // Delete shape button
            document.getElementById('delete-shape').addEventListener('click', deleteSelectedShape);
            
                        
            document.getElementById('scale-all').addEventListener('click', scaleAllShapes);
            
            document.getElementById('move-all').addEventListener('click', moveAllShapes);

            document.getElementById('generate-isometric').addEventListener('click', showIsometricModal);
            document.body.addEventListener('viewObject', (event) => {
                renderData = event.detail;
                document.getElementById('json-content').value =  JSON.stringify(renderData, null, 2);
                selectedShapeIndex = renderData.shapes.length > 0 ? 0 : -1;                
                renderShapes(renderData, { scene }, false);
                updateShapeList();
            });
            // Canvas click event for shape selection
            const canvas = document.getElementById('canvas');
            canvas.addEventListener('mousedown', (event) => {
                isDragging = false;
                clickStartTime = Date.now();
            });
            
            canvas.addEventListener('mousemove', () => {
                if (Date.now() - clickStartTime > 100) {
                    isDragging = true;
                }
            });
            
            canvas.addEventListener('mouseup', (event) => {
                if (isDragging) return; // Ignore if dragging
                
                // Calculate mouse position in normalized device coordinates
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / canvas.clientWidth) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / canvas.clientHeight) * 2 + 1;
                
                // Update the picking ray with the camera and mouse position
                raycaster.setFromCamera(mouse, camera);
                
                // Calculate objects intersecting the picking ray
                const shapes = scene.children.filter(obj => obj.userData.isShape);
                const intersects = raycaster.intersectObjects(shapes);
                
                if (intersects.length > 0) {
                    const index = intersects[0].object.userData.index;
                    selectShape(index);
                }
            });

            document.getElementById('move-cancel').addEventListener('click', () => {
                document.getElementById('move-modal').style.display = 'none';
            });

            document.getElementById('move-apply').addEventListener('click', () => {
                const xOffset = parseFloat(document.getElementById('move-x').value) || 0;
                const yOffset = parseFloat(document.getElementById('move-y').value) || 0;
                const zOffset = parseFloat(document.getElementById('move-z').value) || 0;
                
                // Apply the offset to all shapes
                renderData.shapes.forEach(shape => {
                    shape.x = (shape.x || 0) + xOffset;
                    shape.y = (shape.y || 0) + yOffset;
                    shape.z = (shape.z || 0) + zOffset;
                });
                
                renderShapes(renderData, { scene }, true);
                updateShapeList();
                
                // Hide the modal
                document.getElementById('move-modal').style.display = 'none';
            });
            document.getElementById('iso-cancel').addEventListener('click', () => {
                document.getElementById('isometric-modal').style.display = 'none';
            });
            document.getElementById('iso-generate').addEventListener('click', generateIsometricSprites);
        }
        // Add this function
        function moveAllShapes() {
            if (renderData.shapes.length === 0) return;
            
            // Show the modal
            document.getElementById('move-modal').style.display = 'block';
            
            // Reset values
            document.getElementById('move-x').value = '0';
            document.getElementById('move-y').value = '0';
            document.getElementById('move-z').value = '0';
        }
        // Select a shape
        function selectShape(index) {
            selectedShapeIndex = index;
            updateShapeList();
            highlightSelectedShape();
        }
        
        // Highlight the selected shape
        function highlightSelectedShape() {
            // Remove existing outlines
            scene.children.forEach(obj => {
                if (obj.userData.isOutline) {
                    scene.remove(obj);
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                }
            });
            
            // Reset any highlighted materials
            originalMaterials.forEach((material, object) => {
                object.material = material;
            });
            originalMaterials.clear();
            
            // If no shape is selected, return
            if (selectedShapeIndex < 0 || selectedShapeIndex >= renderData.shapes.length) {
                return;
            }
  
            // Find the selected mesh
            const selectedMesh = scene.children.find(obj => 
                obj.userData.isShape && obj.userData.index === selectedShapeIndex
            );
            
            if (selectedMesh) {
                // Store original material
                originalMaterials.set(selectedMesh, selectedMesh.material);
                
                // Create a new material based on the original one but with emissive glow
                const highlightMaterial = selectedMesh.material.clone();
                highlightMaterial.emissive = new THREE.Color(0x555555);
                highlightMaterial.emissiveIntensity = 0.5;
                
                // Apply the highlight material
                selectedMesh.material = highlightMaterial;
                
                // Create outline
                const outlineGeometry = selectedMesh.geometry.clone();
                const outlineMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00, 
                    side: THREE.BackSide 
                });
                
                const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
                outline.position.copy(selectedMesh.position);
                outline.rotation.copy(selectedMesh.rotation);
                outline.scale.multiplyScalar(1.05);
                outline.userData.isOutline = true;
                
                scene.add(outline);
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        function createObjectsFromJSON(shapeData, scene) {
  
            shapeData.shapes.forEach((shape, index) => {
                let geometry, material, mesh;

                // Create material with the specified color
                material = new THREE.MeshStandardMaterial({ color: shape.color });

                
                // Create geometry based on shape type
                if (shape.type === 'sphere') {
                    geometry = new THREE.SphereGeometry(shape.size / 2, 32, 32);
                }
                else if (shape.type === 'cube') {
                    geometry = new THREE.BoxGeometry(shape.size, shape.size, shape.size);
                }
                else if (shape.type === 'box') {
                    geometry = new THREE.BoxGeometry(shape.width, shape.height, shape.depth || shape.width);
                }
                else if (shape.type === 'cylinder') {
                    geometry = new THREE.CylinderGeometry(shape.size / 2, shape.size / 2, shape.height, 32);
                }
                else if (shape.type === 'cone') {
                    geometry = new THREE.ConeGeometry(shape.size / 2, shape.height, 32);
                }
                else if (shape.type === 'torus') {
                    geometry = new THREE.TorusGeometry(shape.size / 2, shape.tubeSize || shape.size / 6, 16, 100);
                }
                else if (shape.type === 'tetrahedron') {
                    geometry = new THREE.TetrahedronGeometry(shape.size / 2);
                }
                
                if (geometry) {
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.userData.isShape = true;                    
                    mesh.userData.index = index;

                    // Position and rotation
                    mesh.position.set(shape.x || 0, shape.y || 0, shape.z || 0);
                    
                    // Handle rotation (convert from degrees to radians)
                    if (shape.rotationX) mesh.rotation.x = shape.rotationX * Math.PI / 180;
                    if (shape.rotationY) mesh.rotation.y = shape.rotationY * Math.PI / 180;
                    if (shape.rotationZ) mesh.rotation.z = shape.rotationZ * Math.PI / 180;
                    
                    scene.add(mesh);
                }
            });
        }
        // Render shapes function (imported from your code)
        function renderShapes(renderData, ctx3D, fireSave=true) {
            const { scene } = ctx3D;
           
            // Clear existing shapes
            const objectsToRemove = [];
            scene.traverse(object => {
                if (object.userData.isShape || object.userData.isOutline) {
                    objectsToRemove.push(object);
                }
            });
            
            objectsToRemove.forEach(obj => {
                scene.remove(obj);
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material) {
                    if(obj.material.map) obj.material.map.dispose(); // dispose textures
                    obj.material.dispose();
                }
            });
            
            // Add lights if they don't exist
            if (!scene.getObjectByName('ambient-light')) {
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                ambientLight.name = 'ambient-light';
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 7.5);
                directionalLight.name = 'dir-light';
                scene.add(directionalLight);
            }
            createObjectsFromJSON(renderData, scene);
           
      
            
            // Update shape count
            document.getElementById('shape-count').textContent = renderData.shapes.length;
            
            // Update the JSON editor
            document.getElementById('json-content').value = JSON.stringify(renderData, null, 2);

            if(fireSave){
                console.log('update:', renderData);
                        // Create a custom event with data
                const myCustomEvent = new CustomEvent('saveObjectGraphics', {
                    detail: renderData, // Custom data
                    bubbles: true, // Allows the event to bubble up (optional)
                    cancelable: true // Allows the event to be canceled (optional)
                });

                // Dispatch the event
                document.body.dispatchEvent(myCustomEvent);
            }
            // Highlight the selected shape (if any)
            highlightSelectedShape();
        }
        
        // Add a new shape
        function addNewShape() {
            const newShape = {
                type: 'cube',
                size: 2,
                color: '#3498db',
                x: 0,
                y: 0,
                z: 0,
                rotationX: 0,
                rotationY: 0,
                rotationZ: 0
            };
            
            renderData.shapes.push(newShape);
            selectedShapeIndex = renderData.shapes.length - 1;
            
            renderShapes(renderData, { scene });
            updateShapeList();
        }
        
        // Duplicate the selected shape
        function duplicateSelectedShape() {
            if (selectedShapeIndex >= 0) {
                const originalShape = renderData.shapes[selectedShapeIndex];
                const newShape = JSON.parse(JSON.stringify(originalShape));
                                
                renderData.shapes.push(newShape);
                selectedShapeIndex = renderData.shapes.length - 1;
                
                renderShapes(renderData, { scene });
                updateShapeList();
            }
        }
        
        // Delete the selected shape
        function deleteSelectedShape() {
            if (selectedShapeIndex >= 0) {
                renderData.shapes.splice(selectedShapeIndex, 1);
                
                if (renderData.shapes.length > 0) {
                    selectedShapeIndex = Math.min(selectedShapeIndex, renderData.shapes.length - 1);
                } else {
                    selectedShapeIndex = -1;
                }
                
                renderShapes(renderData, { scene });
                updateShapeList();
            }
        }
        
        // Update the shape list in the sidebar
        function updateShapeList() {
            const shapeList = document.getElementById('shape-list');
            shapeList.innerHTML = '';
            
            if (renderData.shapes.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.textContent = 'No shapes added. Click "Add Shape" to begin.';
                emptyMessage.style.padding = '10px';
                emptyMessage.style.color = '#777';
                shapeList.appendChild(emptyMessage);
                document.getElementById('selected-shape').textContent = 'None';
                return;
            }
            
            renderData.shapes.forEach((shape, index) => {
                const shapeItem = document.createElement('div');
                shapeItem.className = 'shape-item';
                if (index === selectedShapeIndex) {
                    shapeItem.classList.add('active');
                    document.getElementById('selected-shape').textContent = `${shape.type} (${index})`;
                }
                
                const title = document.createElement('div');
                title.textContent = `${index + 1}. ${shape.type} ${shape.color}`;
                title.style.fontWeight = 'bold';
                title.style.marginBottom = '5px';
                shapeItem.appendChild(title);
                
                const position = document.createElement('div');
                position.textContent = `Position: X=${shape.x || 0}, Y=${shape.y || 0}, Z=${shape.z || 0}`;
                position.style.fontSize = '12px';
                shapeItem.appendChild(position);
                
                shapeItem.addEventListener('click', () => {
                    selectedShapeIndex = index;
                    updateShapeList();
                    highlightSelectedShape();
                    
                    // Scroll the shape into view in the inspector
                    createInspector(shape);
                });
                
                shapeList.appendChild(shapeItem);
            });
            
            // Create inspector for selected shape
            if (selectedShapeIndex >= 0) {
                createInspector(renderData.shapes[selectedShapeIndex]);
            }
        }
        
        // Create the inspector panel for editing a shape
        function createInspector(shape) {
            const shapeList = document.getElementById('shape-list');            
     
            const inspector = document.getElementById('inspector');
            inspector.innerHTML = "";
            inspector.className = 'inspector';
            
            // Type selector
            addFormRow(inspector, 'Type', 'select', 'type', shape.type, {
                options: ['cube', 'sphere', 'box', 'cylinder', 'cone', 'torus', 'tetrahedron']
            });
            
            // Color picker
            addFormRow(inspector, 'Color', 'color', 'color', shape.color);
            
            // Position inputs
            addFormRow(inspector, 'X Position', 'number', 'x', shape.x || 0, { step: 0.1 });
            addFormRow(inspector, 'Y Position', 'number', 'y', shape.y || 0, { step: 0.1 });
            addFormRow(inspector, 'Z Position', 'number', 'z', shape.z || 0, { step: 0.1 });
            
            // Rotation inputs
            addFormRow(inspector, 'X Rotation', 'number', 'rotationX', shape.rotationX || 0, { step: 5 });
            addFormRow(inspector, 'Y Rotation', 'number', 'rotationY', shape.rotationY || 0, { step: 5 });
            addFormRow(inspector, 'Z Rotation', 'number', 'rotationZ', shape.rotationZ || 0, { step: 5 });
            
            // Size inputs
            if (shape.type === 'cube' || shape.type === 'sphere' || shape.type === 'tetrahedron' || shape.type === 'torus') {
                addFormRow(inspector, 'Size', 'number', 'size', shape.size || 2, { min: 0.1, step: 0.1 });
            }
            
            if (shape.type === 'box') {
                addFormRow(inspector, 'Width', 'number', 'width', shape.width || 2, { min: 0.1, step: 0.1 });
                addFormRow(inspector, 'Height', 'number', 'height', shape.height || 2, { min: 0.1, step: 0.1 });
                addFormRow(inspector, 'Depth', 'number', 'depth', shape.depth || 2, { min: 0.1, step: 0.1 });
            }
            
            if (shape.type === 'cylinder' || shape.type === 'cone') {
                addFormRow(inspector, 'Size', 'number', 'size', shape.size || 2, { min: 0.1, step: 0.1 });
                addFormRow(inspector, 'Height', 'number', 'height', shape.height || 3, { min: 0.1, step: 0.1 });
            }
            
            if (shape.type === 'torus') {
                addFormRow(inspector, 'Tube Size', 'number', 'tubeSize', shape.tubeSize || shape.size / 6, { min: 0.1, step: 0.1 });
            }
            
        }
        
        // Add a form row to the inspector
        function addFormRow(container, label, type, property, value, options = {}) {
            const row = document.createElement('div');
            row.className = 'form-row';
            
            const labelElement = document.createElement('label');
            labelElement.textContent = label;
            row.appendChild(labelElement);
            
            let input;
            
            if (type === 'select') {
                input = document.createElement('select');
                (options.options || []).forEach(optionValue => {
                    const option = document.createElement('option');
                    option.value = optionValue;
                    option.textContent = optionValue;
                    if (value === optionValue) {
                        option.selected = true;
                    }
                    input.appendChild(option);
                });
            } else {
                input = document.createElement('input');
                input.type = type;
                input.value = value;
                
                if (type === 'number') {
                    input.min = options.min !== undefined ? options.min : -64;
                    input.max = options.max !== undefined ? options.max : 64;
                    input.step = options.step || 1;
                }
            }
            
            input.addEventListener('change', () => {
                let newValue = input.value;
                
                if (type === 'number') {
                    newValue = parseFloat(newValue);
                }
                
                renderData.shapes[selectedShapeIndex][property] = newValue;
                renderShapes(renderData, { scene });
                updateShapeList();
            });
            
            row.appendChild(input);
            container.appendChild(row);
        }
        
        // Import JSON configuration
        function importJSON() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.addEventListener('change', e => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        renderData = importedData;
                        selectedShapeIndex = renderData.shapes.length > 0 ? 0 : -1;
                        
                        renderShapes(renderData, { scene });
                        updateShapeList();
                        
                        // Reset camera position
                        camera.position.set(0, 5, 10);
                        controls.target.set(0, 0, 0);
                    } catch (error) {
                        alert('Invalid JSON file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            });
            
            input.click();
        }
        // Apply JSON from editor
        function applyJSON() {
            try {
                const newData = JSON.parse(document.getElementById('json-content').value);
                renderData = newData;
                selectedShapeIndex = renderData.shapes.length > 0 ? 0 : -1;
                
                renderShapes(renderData, { scene });
                updateShapeList();
            } catch (error) {
                alert('Invalid JSON: ' + error.message);
            }
        }

        // Initialize the application when the page loads
        window.addEventListener('load', init);
    })();
   
    </script>
</body>
</html>