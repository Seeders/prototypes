<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Config Editor</title>
      
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1e1e1e;
            color: #f0f0f0;
        }
        
        .container {
            display: flex;
            gap: 20px;
            height: calc(100vh - 40px);
        }
        
        .sidebar {
            width: 250px;
            background-color: #252525;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }
        
        .object-list {
            flex: 1;
            overflow-y: auto;
        }
        
        .object-item {
            padding: 10px;
            margin-bottom: 5px;
            background-color: #333;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .object-item:hover {
            background-color: #444;
        }
        
        .object-item.selected {
            background-color: #505050;
            border-left: 4px solid #a0f;
        }
        
        .editor {
            background-color: #252525;
            border-radius: 8px;
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }
        #three-js-container {
            position: absolute;
            width: 256px; 
            height: 256px;
            margin: auto;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
        }
        .preview-canvas-container {
            position: relative;
            width: 600px;
            height: 240px;
        }

        .preview {
            background-color: #252525;
            border-radius: 8px;
            padding: 20px;
            height: 300px;
            position: relative;
        }
        
        #preview-canvas {
            background-color: transparent;
            border-radius: 4px;
        }
        .camera-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px;
            border-radius: 4px;
        }

        .camera-controls button {
            padding: 4px 8px;
            font-size: 0.8em;
        }

        .camera-controls .color-picker {
            width: 24px;
            height: 24px;
            padding: 0;
            border: none;
        }

        .camera-controls .size-slider {
            width: 80px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #444;
            background-color: #333;
            color: #f0f0f0;
            font-family: monospace;
        }
        
        textarea {
            height: 100px;
            resize: vertical;
        }
        
        button {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            margin-right: 10px;
            background-color: #505050;
            color: #f0f0f0;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #606060;
        }
        
        button.primary {
            background-color: #a0f;
        }
        
        button.primary:hover {
            background-color: #b4f;
        }
        
        button.danger {
            background-color: #d00;
        }
        
        button.danger:hover {
            background-color: #f00;
        }

        button.active {            
            border: 1px solid #4CAF50;
        }
        
        .actions {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .input-row {
            display: flex;
            gap: 2em;
            margin-bottom: 1em;
        }
        
        .input-row .form-group {
            flex: 1;
            margin-bottom: 0;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s linear 0.25s, opacity 0.25s 0s;
        }
        
        .modal.show {
            visibility: visible;
            opacity: 1;
            transition-delay: 0s;
        }
        
        .modal-content {
            background-color: #252525;
            border-radius: 8px;
            padding: 20px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .property-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #444;
            padding: 10px;
            border-radius: 4px;
            background-color: #333;
        }
        
        .property-item {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        .property-item input {
            flex: 1;
        }
        
        .property-item button {
            padding: 4px 8px;
        }
        
        .tab-navigation {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #444;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        
        .tab.active {
            border-bottom: 3px solid #a0f;
            font-weight: bold;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .instructions {
            margin-bottom: 20px;
            padding: 10px;
            background-color: #333;
            border-radius: 4px;
            border-left: 4px solid #a0f;
        }
        
        #grid-display {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
            font-family: monospace;
        }

        .success-message {
            color: lightgreen;
            margin-left: 10px;
            animation: fadeOut 2s forwards;
            animation-delay: 1s;
        }
        .type-selector {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            flex-direction: column;
        }

        .type-selector .object-item {
            flex: 1;
            text-align: center;
            padding: 8px 5px;
            font-size: 0.9em;
        }

        .tab-navigation {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #444;
        }
        .type-actions {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .small-btn {
            padding: 4px 8px;
            font-size: 0.8em;
            margin-right: 0;
        }

        .warning {
            background-color: rgba(255, 0, 0, 0.1);
            padding: 10px;
            border-radius: 4px;
            border-left: 4px solid #f44;
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        #graphics-container {
            display: flex;
            height: 50vh;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        #graphics-sidebar {
            width: 360px;
            background: linear-gradient(180deg, #2a2a2a, #222);
            border-right: 1px solid #555;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
        }
        #graphics-rightbar {
            width: 360px;
            background: linear-gradient(180deg, #2a2a2a, #222);
            border-right: 1px solid #555;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
        }
        #canvas-container {
            flex: 1;
            position: relative;
            background: #101010;
        }
        #canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 5px; /* Reduced from 15px */
            padding: 5px; /* Reduced from 10px */
            background: linear-gradient(180deg, #2a2a2a, #222); /* Matches your sidebar */
            border-bottom: 1px solid #555;
        }

        .btn {
            padding: 4px 8px; /* Smaller than 6px 12px */
            font-size: 12px; /* Reduced from 14px */
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            color: #f0f0f0;
            min-width: 28px; /* Ensures buttons arenâ€™t too tiny */
            text-align: center;
            margin: 0;
        }

        .btn-primary {
            background-color: #a0f;
        }

        .btn-primary:hover {
            background-color: #b4f;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .btn-danger {
            background-color: #d00;
        }

        .btn-danger:hover {
            background-color: #f00;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .btn-secondary {
            background-color: #505050;
        }

        .btn-secondary:hover {
            background-color: #606060;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .btn-special {
            background-color: #4CAF50;
        }

        .btn-special:hover {
            background-color: #66BB6A;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #shape-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        .shape-item {
            padding: 12px;
            margin-bottom: 8px;
            background-color: #383838;
            border: 1px solid #555;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .shape-item:hover {
            background-color: #444;
        }
        .shape-item.active {
            background-color: #4a4a4a;
            border-color: #4CAF50;
            color: #fff;
        }
        #inspector {
            padding: 15px;
            background: #2f2f2f;
            border-top: 1px solid #555;
        }
        .form-row {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .form-row label {
            width: 90px;
            font-size: 14px;
            color: #ccc;
        }
        .form-row input, .form-row select {
            flex: 1;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 4px;
            background-color: #383838;
            color: #e0e0e0;
            font-size: 14px;
        }
        .scene-info {
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            position: absolute;
            bottom: 15px;
            left: 15px;
            border-radius: 6px;
            font-size: 13px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        .button-danger {
            background-color: #e53935;
        }
        .button-danger:hover {
            background-color: #d32f2f;
        }
        
        #move-modal h3 {
            margin-bottom: 20px;
            color: #e0e0e0;
            font-size: 18px;
        }
        #move-modal button {
            width: 48%;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h2>Editor</h2>
            <div class="object-list" id="object-list">
                <!-- Object list will be dynamically populated -->
            </div>
            <div style="margin-top: auto; padding-top: 10px;">
                <button class="primary" id="add-object-btn" style="width: 100%;">Add New Object</button>
                <button id="import-export-btn" style="width: 100%; margin-top: 10px;">Import/Export Config</button>
                <button id="save-export-btn" style="width: 100%; margin-top: 10px;">Save Config</button>
            </div>
        </div>
        
        <div class="main-content">
            <div id="graphics-container">
                <div id="graphics-sidebar">
                    <div id="toolbar" class="toolbar">
                        <button id="preview-animation" class="btn btn-primary" title="Preview Animation">Play</button>
                        <button id="add-animation" class="btn btn-primary" title="Add Animation">+A</button>
                        <button id="delete-animation" class="btn btn-danger" title="Delete Animation">-A</button>
                        <button id="duplicate-frame" class="btn btn-primary" title="Add Frame">+F</button>
                        <button id="delete-frame" class="btn btn-danger" title="Delete Frame">-F</button>
                        <button id="add-shape" class="btn btn-primary" title="Add Shape">+S</button>
                        <button id="duplicate-shape" class="btn btn-primary" title="Duplicate Shape">SS</button>
                        <button id="delete-shape" class="btn btn-danger" title="Delete Shape">-S</button>
                        <button id="scale-all" class="btn btn-secondary" title="Scale All">Sc</button>
                        <button id="move-all" class="btn btn-secondary" title="Move All">Mv</button>
                        <button id="rotate-all" class="btn btn-secondary" title="Rotate All">Rt</button>
                        <button id="generate-isometric" class="btn btn-special" title="Generate Isometric Sprites">Iso</button>
                    </div>
                    <div id="shape-list"></div>
                </div>
                <div id="canvas-container">
                    <canvas id="canvas"></canvas>
                    <div class="scene-info">
                        <div>Shapes: <span id="shape-count">0</span></div>
                        <div>Selected: <span id="selected-shape">None</span></div>
                        <div><small>Controls: Left-click to select, Drag to rotate, Right-drag to pan, Scroll to zoom</small></div>
                    </div>
                </div>
                <div id="graphics-rightbar">
                    <div id="inspector"></div>
                    <div id="json-editor" style="display: none">
                        <textarea id="json-content" placeholder="Edit JSON here..."></textarea>
                    </div>
                </div>
            </div>
            <div class="editor" id="editor">
                <div class="instructions">
                    Select a tower from the sidebar or create a new one to start editing.
                </div>
                <!-- Editor form will be dynamically populated -->
            </div>
        </div>
    </div>
    
    <!-- Import/Export Modal -->
    <div class="modal" id="import-export-modal">
        <div class="modal-content">
            <h2>Import/Export Configuration</h2>
            
            <div class="tab-navigation">
                <div class="tab active" data-tab="import">Import</div>
                <div class="tab" data-tab="export">Export</div>
            </div>
            
            <div class="tab-content active" id="import-tab">
                <p>Paste your tower configuration below:</p>
                <textarea id="import-textarea" rows="15"></textarea>
                <div class="actions">
                    <button class="primary" id="import-btn">Import Configuration</button>
                    <button id="close-import-export-modal">Cancel</button>
                </div>
            </div>
            
            <div class="tab-content" id="export-tab">
                <p>Copy your tower configuration:</p>
                <textarea id="export-textarea" rows="15" readonly></textarea>
                <div class="actions">
                    <button class="primary" id="copy-export-btn">Copy to Clipboard</button>
                    <button id="close-export-modal">Close</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- New Tower Modal -->
    <div class="modal" id="new-object-modal">
        <div class="modal-content">
            <h2>Create New Object</h2>
            <div class="form-group">
                <label for="new-object-id">Tower ID:</label>
                <input type="text" id="new-object-id" placeholder="e.g. fireTower">
            </div>
            <div class="form-group">
                <label for="new-object-name">Display Name:</label>
                <input type="text" id="new-object-name" placeholder="e.g. Fire Tower">
            </div>
            <div class="actions">
                <button class="primary" id="create-object-btn">Create Tower</button>
                <button id="close-new-object-modal">Cancel</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="move-modal">
        <div class="modal-content">
            <h3>Move All Shapes</h3>
            <div class="form-row">
                <label for="move-x">X Offset:</label>
                <input type="number" id="move-x" value="0" step="0.5">
            </div>
            <div class="form-row">
                <label for="move-y">Y Offset:</label>
                <input type="number" id="move-y" value="0" step="0.5">
            </div>
            <div class="form-row">
                <label for="move-z">Z Offset:</label>
                <input type="number" id="move-z" value="0" step="0.5">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button id="move-cancel">Cancel</button>
                <button id="move-apply">Apply</button>
            </div>
        </div>
    </div>
    <div class="modal" id="rotate-modal">
        <div class="modal-content">
            <h3>Rotate All Shapes</h3>
            <div class="form-row">
                <label for="rotate-angle">Angle (degrees):</label>
                <input type="number" id="rotate-angle" value="0" step="1">
            </div>
            <div class="form-row">
                <label for="rotate-axis">Axis:</label>
                <select id="rotate-axis">
                    <option value="x">X</option>
                    <option value="y" selected>Y</option>
                    <option value="z">Z</option>
                </select>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button id="rotate-cancel">Cancel</button>
                <button id="rotate-apply">Apply</button>
            </div>
        </div>
    </div>
    <div  class="modal" id="isometric-modal">
        <div class="modal-content" >
            <h3 style="margin-bottom: 20px; color: #e0e0e0; font-size: 18px;">Generate Isometric Sprites</h3>
            <div class="form-row">
                <label for="iso-frustum">Frustum Size:</label>
                <input type="number" id="iso-frustum" value="48" step="1" min="1">
            </div>
            <div class="form-row">
                <label for="iso-distance">Distance:</label>
                <input type="number" id="iso-distance" value="100" step="1" min="1">
            </div>
            <div class="form-row">
                <label for="iso-size">Sprite Size:</label>
                <input type="number" id="iso-size" value="64" step="1" min="1">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button id="iso-cancel">Cancel</button>
                <button id="iso-generate">Generate</button>
            </div>
        </div>
    </div>


    <script type="module">
    import * as THREE from './library/three.module.min.js';
    
    import { OrbitControls } from './library/three.orbitControls.js';


    (function() {
        /**
         * Tower Defense Config Editor
         * A tool for creating and editing configurations for tower defense games
         */
        
        // Configuration constants
        const CONFIG = {
            GRID_SIZE: 40,
            DEFAULT_TOWER_SIZE: 30,
            DEFAULT_TOWER_COLOR: '#ffffff',
            DEFAULT_RENDER: {animations:{idle:[{shapes:[]}]}}
        };
        let threeJsCamera = null;
        let currentCameraLocation = 0;
        
        const cameraDistance = 96;
        let cameraLocations = [ 
            { x: cameraDistance, y: cameraDistance, z: cameraDistance },
            { x: cameraDistance, y: cameraDistance, z: -cameraDistance },
            { x: -cameraDistance, y: cameraDistance, z: -cameraDistance },
            { x: -cameraDistance, y: cameraDistance, z: cameraDistance }
        ];

        //const threeJsContext = setupThreeJsRenderer('three-js-container');
        // Application state changes
        const state = {
            objectTypes: {
                towers: {},
                enemies: {},
                projectiles: {}
            },
            objectTypeDefinitions: [
                { id: 'towers', name: 'Towers', singular: 'Tower' },
                { id: 'enemies', name: 'Enemies', singular: 'Enemy' },
                { id: 'projectiles', name: 'Projectiles', singular: 'Projectile' },
                { id: 'environment', name: 'Environment', singular: 'Environment' }
            ],
            selectedType: 'towers',
            selectedObject: null,
            isDragging: false,
            objectPosition: { x: 300, y: 120 }
        };
        // Cache DOM elements
        const elements = {
            objectList: document.getElementById('object-list'),
            editor: document.getElementById('editor'),
            previewCanvas: document.getElementById('preview-canvas'),
            gridDisplay: document.getElementById('grid-display'),
            importExportModal: document.getElementById('import-export-modal'),
            importTextarea: document.getElementById('import-textarea'),
            exportTextarea: document.getElementById('export-textarea'),
            newObjectModal: document.getElementById('new-object-modal'),
            newObjectIdInput: document.getElementById('new-object-id'),
            newObjectNameInput: document.getElementById('new-object-name'),
            tabs: document.querySelectorAll('.tab'),
            rotateLeftBtn: document.getElementById('rotateLeftBtn'),
            rotateRightBtn: document.getElementById('rotateRightBtn'),
            clearDrawingBtn: document.getElementById('clearDrawingBtn'),
            colorPicker: document.getElementById('colorPicker'),
            sizeSlider: document.getElementById('sizeSlider')
        };
        let drawingState = {
            currentShape: 'circle',
            currentColor: '#000000',
            currentSize: 32,
            isDrawing: false
        };
        function getSingularType(typeId) {
            const typeDef = state.objectTypeDefinitions.find(t => t.id === typeId);
            return typeDef ? typeDef.singular : typeId.slice(0, -1);
        }

        // Add this function to get the plural form of a type
        function getPluralType(typeId) {
            const typeDef = state.objectTypeDefinitions.find(t => t.id === typeId);
            return typeDef ? typeDef.name : typeId;
        }
        // HTML for object type selection in sidebar
        function renderTypeSelector() {
            let html = `<h2>Object Types</h2>
                        <div class="type-selector">`;
            
            state.objectTypeDefinitions.forEach(type => {
                html += `<div class="object-item ${state.selectedType === type.id ? 'selected' : ''}" data-type="${type.id}">${type.name}</div>`;
            });
            
            html += `</div>
                    <div class="type-actions">
                        <button id="add-type-btn" class="small-btn">Add Type</button>
                        ${state.objectTypeDefinitions.length > 1 ? `<button id="remove-type-btn" class="small-btn danger">Remove Type</button>` : ''}
                    </div>
                    <h2>${getPluralType(state.selectedType)}</h2>`;
            
            return html;
        }        
        // Replace renderTowerList function
        function renderObjectList() {
            // Add type selector
            elements.objectList.innerHTML = renderTypeSelector();
            
            // Add objects of the selected type
            Object.keys(state.objectTypes[state.selectedType] || {}).forEach(objId => {
                const objectItem = document.createElement('div');
                objectItem.className = `object-item ${state.selectedObject === objId ? 'selected' : ''}`;
                objectItem.textContent = objId;
                objectItem.addEventListener('click', () => selectObject(objId));
                elements.objectList.appendChild(objectItem);
            });
            
            // Add event listeners for type selection
            document.querySelectorAll('.type-selector .object-item').forEach(item => {
                item.addEventListener('click', () => {
                    state.selectedType = item.dataset.type;
                    state.selectedObject = null;
                    renderObjectList();
                    renderEditor();
                    renderPreview();
                    updateSidebarButtons();
                    let objects = state.objectTypes[state.selectedType];
                    for(let objectType in objects) {                 
                        selectObject(objectType);
                        break;                 
                    }
                });
            });
            
            // Add event listeners for type actions
            document.getElementById('add-type-btn')?.addEventListener('click', showAddTypeModal);
            document.getElementById('remove-type-btn')?.addEventListener('click', showRemoveTypeModal);
        }
        
        // Replace selectTower function
        function selectObject(objId) {
            state.selectedObject = objId;
            renderObjectList();
            renderEditor();
            renderPreview();
        }
        
        // Update the editor UI
        function renderEditor() {
            const singularType = getSingularType(state.selectedType); // Remove 's' to get singular
            
            if (!state.selectedObject) {
                elements.editor.innerHTML = `
                    <div class="instructions">
                        Select a ${singularType} from the sidebar or create a new one to start editing.
                    </div>
                `;
                return;
            }
            
            elements.editor.innerHTML = `
                <h2>Editing: ${state.selectedObject} (${singularType})</h2>
                
                <div class="tab-content active" id="advanced-tab">  
                    <h3>Properties</h3>
                    <div class="property-list" id="custom-properties">
                        <!-- Custom properties will be rendered here -->
                    </div>
                    <button id="add-property-btn" style="margin-top: 10px;">Add Custom Property</button>
                </div>
                
                <div class="actions">
                    <div>
                        <button class="primary" id="save-object-btn">Save ${singularType}</button>
                        <button id="revert-changes-btn">Revert Changes</button>
                    </div>
                    <button class="danger" id="delete-object-btn">Delete ${singularType}</button>
                </div>
            `;
            
            // Setup property editor
            const customPropertiesContainer = document.getElementById('custom-properties');
            renderCustomProperties(customPropertiesContainer, state.objectTypes[state.selectedType][state.selectedObject]);
            
            // Add event listeners for editor controls
            document.getElementById('add-property-btn').addEventListener('click', () => {
                addCustomProperty(customPropertiesContainer, '', '');
            });
            
            document.getElementById('save-object-btn').addEventListener('click', saveObject);
            document.getElementById('revert-changes-btn').addEventListener('click', () => {
                selectObject(state.selectedObject);
            });
            document.getElementById('delete-object-btn').addEventListener('click', deleteObject);
        }
        
        /**
         * Render custom properties in the editor
         */
        function renderCustomProperties(container, object) {
            container.innerHTML = '';

            Object.entries(object).forEach(([key, value]) => {
                addCustomProperty(container, key, value);
            });
        }
        
        /**
         * Add a custom property input to the editor
         */
        function addCustomProperty(container, key, value) {
            const propertyItem = document.createElement('div');
            propertyItem.className = 'property-item';
            
            const keyInput = document.createElement('input');
            keyInput.type = 'text';
            keyInput.placeholder = 'Property Name';
            keyInput.value = key;
            keyInput.className = 'property-key';
            
            const valueInput = document.createElement('input');
            let type = 'text';
            if( key === 'color' ) {
                type = 'color';
            } else if( key === 'render' ) {
                type = 'textarea';
                value = JSON.stringify(value);
                valueInput.setAttribute('id', 'render-value');
            }
            valueInput.type = type;
            valueInput.placeholder = 'Value';
            valueInput.value = value;
            valueInput.className = 'property-value';
            
            const removeBtn = document.createElement('button');
            removeBtn.textContent = 'Remove';
            removeBtn.className = 'danger';
            removeBtn.addEventListener('click', () => {
                container.removeChild(propertyItem);
            });
            
            propertyItem.appendChild(keyInput);
            propertyItem.appendChild(valueInput);
            propertyItem.appendChild(removeBtn);
            container.appendChild(propertyItem);
        }
        
        // Replace saveTower function
        function saveObject() {
            if (!state.selectedObject) return;
            
            const object = {}; 
            
            // Collect custom properties
            document.querySelectorAll('.property-item').forEach(item => {
                const keyInput = item.querySelector('.property-key');
                const valueInput = item.querySelector('.property-value');
                
                if (keyInput.value && valueInput.value) {
                    let value = valueInput.value;
                    
                    // Try to parse value types
                    if (!isNaN(parseFloat(value)) && isFinite(value)) {
                        value = parseFloat(value);
                    } else if (value.toLowerCase() === 'true') {
                        value = true;
                    } else if (value.toLowerCase() === 'false') {
                        value = false;
                    }
                    if(keyInput.value == "render") {
                        value = JSON.parse(value);
                    }
                    object[keyInput.value] = value;
                }
            });
            
            // Update the config
            state.objectTypes[state.selectedType][state.selectedObject] = object;
            
            // Update UI
            renderObjectList();
            renderPreview();
            saveToLocalStorage();
            // Show success message
            const actions = document.querySelector('.actions');
            const successMsg = document.createElement('span');
            successMsg.textContent = 'Changes saved!';
            successMsg.className = 'success-message';
            actions.appendChild(successMsg);
            
            setTimeout(() => {
                if (actions.contains(successMsg)) {
                    actions.removeChild(successMsg);
                }
            }, 2000);
        }
                
        // Replace deleteTower function
        function deleteObject() {
            if (!state.selectedObject) return;
            
            const singularType = state.selectedType.slice(0, -1);
            
            if (confirm(`Are you sure you want to delete "${state.selectedObject}" ${singularType}?`)) {
                delete state.objectTypes[state.selectedType][state.selectedObject];
                state.selectedObject = null;
                renderObjectList();
                renderEditor();
                renderPreview();
            }
        }

        
        /**
         * Render the preview canvas
         */
         function renderPreview() {
            
            if (state.selectedObject && state.objectTypes[state.selectedType][state.selectedObject]) {
                const object = state.objectTypes[state.selectedType][state.selectedObject];
 
                drawObject(object, state.objectPosition);               

            }
        }
        
          
        /**
         * Draw a tower at the specified position
         */
        function drawObject(object, position) {
            
            if(!object.render) return;
            const renderData = object.render;
            
                // Create a custom event with data
            const myCustomEvent = new CustomEvent('viewObject', {
                detail: renderData, // Custom data
                bubbles: true, // Allows the event to bubble up (optional)
                cancelable: true // Allows the event to be canceled (optional)
            });

            // Dispatch the event
            document.body.dispatchEvent(myCustomEvent);

            //renderShapes(renderData, threeJsContext);
        }

       
        function addShapeToRender(x, y) {
            if (!state.selectedObject) return;
            
            const object = state.objectTypes[state.selectedType][state.selectedObject];
            const render = object.render || JSON.parse(JSON.stringify(CONFIG.DEFAULT_RENDER));
            
            // Convert canvas coordinates to render coordinates (64x64 space)
            const renderX = Math.round(x - (state.objectPosition.x - 32));
            const renderY = Math.round(y - (state.objectPosition.y - 32));
            
            if (renderX >= 0 && renderX <= 64 && renderY >= 0 && renderY <= 64) {
                const shape = {
                    type: drawingState.currentShape,
                    x: renderX,
                    y: renderY,
                    size: drawingState.currentSize,
                    color: drawingState.currentColor
                };
                
                render.shapes.push(shape);
                object.render = render;
                document.getElementById("render-value").value = JSON.stringify(render);
                renderPreview();
            }
        }

        function clearRender() {
            if (!state.selectedObject) return;
            
            const object = state.objectTypes[state.selectedType][state.selectedObject];
            if( object.render ) {
                object.render = { shapes: [] };
            }
            renderPreview();
        }
        /**
         * Generate JavaScript code for the current configuration
         */
        function generateConfigCode() {
            let code = `{\n`;
            
            Object.entries(state.objectTypes[state.selectedType]).forEach(([objId, config]) => {
                code += `    ${objId}: { `;
                
                const props = Object.entries(config)
                    .filter(([_, value]) => value !== undefined && value !== null)
                    .map(([key, value]) => {
                        if (typeof value === 'string') {
                            return `${key}: '${value}'`;
                        } if(typeof value === 'object' ) {
                            return `${key}: ${JSON.stringify(value)}`;
                        } else {
                            return `${key}: ${value}`;
                        }
                    })
                    .join(', ');
                
                code += `${props} },\n`;
            });
            
            code += '}';
            
            return code;
        }

        
        /**
         * Parse configuration code and convert to object
         */
        function parseConfigCode(code) {
            try {
                // Extract the config object with variable pattern matching
                const regex = /\{([^;]*(?:\{[^;]*\}[^;]*)*)\}/s;
                const match = code.match(regex);
                
                if (!match) {
                    throw new Error('Could not find configuration in the code');
                }
                                
                // Create a valid JavaScript expression
                const objText = `(${match[0]})`;
                
                // Parse the JavaScript object
                const config = eval(objText);
                
                // Determine the actual object type
                let objectType = state.selectedType;
                
                return { type: objectType, config };
            } catch (error) {
                console.error('Error parsing configuration:', error);
                alert('Failed to parse configuration. Please check format and try again.');
                return null;
            }
        }
        
        /**
         * Create a new tower
         */
        function createNewObject() {
            const id = elements.newObjectIdInput.value.trim();
            const name = elements.newObjectNameInput.value.trim();
            
            if (!id) {
                alert(`Please enter an ID`);
                return;
            }
            
            if (state.objectTypes[state.selectedType][id]) {
                alert(`Object with ID "${id}" already exists`);
                return;
            }
            
            // Create default properties based on type
            let defaultProps = {
                info: name || id,
                color: CONFIG.DEFAULT_TOWER_COLOR,
                size: CONFIG.DEFAULT_TOWER_SIZE,
                render: JSON.parse(JSON.stringify(CONFIG.DEFAULT_RENDER))
            };
            
            state.objectTypes[state.selectedType][id] = defaultProps;
            
            elements.newObjectModal.classList.remove('show');
            renderObjectList();
            selectObject(id);
        }
        
        /**
         * Set up event listeners
         */
        function setupEventListeners() {
   
            // Import/Export handling
            document.getElementById('import-export-btn').addEventListener('click', () => {
                elements.exportTextarea.value = generateConfigCode();
                elements.importExportModal.classList.add('show');
            });
            // Save as JSON File (new functionality)
            document.getElementById('save-export-btn').addEventListener('click', () => {
                saveConfigFile();
            });

            document.getElementById('close-import-export-modal').addEventListener('click', () => {
                elements.importExportModal.classList.remove('show');
            });
            
            document.getElementById('close-export-modal').addEventListener('click', () => {
                elements.importExportModal.classList.remove('show');
            });
            
            document.getElementById('copy-export-btn').addEventListener('click', copyExportToClipboard);
            
            document.getElementById('import-btn').addEventListener('click', importConfig);
            
            // New object handling
            document.getElementById('add-object-btn').addEventListener('click', () => {
                elements.newObjectIdInput.value = '';
                elements.newObjectNameInput.value = '';
                updateNewObjectModal();
                elements.newObjectModal.classList.add('show');
            });
            
            document.getElementById('close-new-object-modal').addEventListener('click', () => {
                elements.newObjectModal.classList.remove('show');
            });
            
            document.getElementById('create-object-btn').addEventListener('click', createNewObject);
            
            // Tab navigation
            elements.tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    elements.tabs.forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    tab.classList.add('active');
                    document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
                });
            });
            document.body.addEventListener('saveObjectGraphics', (event) => {
                let renderData = event.detail;
                document.getElementById('render-value').value = JSON.stringify(renderData);
            });
        }
  
        /**
         * Copy export code to clipboard
         */
        function copyExportToClipboard() {
            elements.exportTextarea.select();
            document.execCommand('copy');
            const copyBtn = document.getElementById('copy-export-btn');
            copyBtn.textContent = 'Copied!';
            saveToLocalStorage();
            setTimeout(() => {
                copyBtn.textContent = 'Copy to Clipboard';
            }, 2000);
        }

        function saveToLocalStorage() {
            
            localStorage.setItem("objectTypes", JSON.stringify(state.objectTypes));
            localStorage.setItem("objectTypeDefinitions", JSON.stringify(state.objectTypeDefinitions));
            saveConfigFile();
        }
        
        function saveConfigFile() {
            state.objectTypes.objectTypeDefinitions = state.objectTypeDefinitions;
            const configText = JSON.stringify(state.objectTypes, null, 2);
            delete state.objectTypes.objectTypeDefinitions;
            fetch('/save-config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: configText
                })
                .then(response => {
                    if (!response.ok) throw new Error('Failed to save config');
                    return response.text();
                })
                .then(message => {
                })
                .catch(error => {
                    console.error('Error:', error);
                });
        }
        /**
         * Import configuration from textarea
         */
        function importConfig() {
            const code = elements.importTextarea.value;
            const result = parseConfigCode(code);
            
            if (result) {
                state.objectTypes[result.type] = result.config;
                state.selectedType = result.type;
                renderObjectList();
                elements.importExportModal.classList.remove('show');
                
                if (Object.keys(state.objectTypes[state.selectedType]).length > 0) {
                    selectObject(Object.keys(state.objectTypes[state.selectedType])[0]);
                } else {
                    state.selectedObject = null;
                    renderEditor();
                    renderPreview();
                }
                saveToLocalStorage();
            }
        }
        // Update new object modal
        function updateNewObjectModal() {
            const singularType = getSingularType(state.selectedType);
            document.querySelector('#new-object-modal h2').textContent = `Create New ${singularType.charAt(0).toUpperCase() + singularType.slice(1)}`;
            document.querySelector('#new-object-modal label[for="new-object-id"]').textContent = `${singularType.charAt(0).toUpperCase() + singularType.slice(1)} ID:`;
            document.getElementById('create-object-btn').textContent = `Create ${singularType.charAt(0).toUpperCase() + singularType.slice(1)}`;
        }

        function createNewType() {
            const typeId = document.getElementById('new-type-id').value.trim();
            const typeName = document.getElementById('new-type-name').value.trim();
            const typeSingular = document.getElementById('new-type-singular').value.trim();
            
            if (!typeId) {
                alert('Please enter a Type ID');
                return;
            }
            
            if (state.objectTypes[typeId]) {
                alert(`Type "${typeId}" already exists`);
                return;
            }
            
            // Add the new type
            state.objectTypes[typeId] = {};
            state.objectTypeDefinitions.push({
                id: typeId,
                name: typeName || typeId.charAt(0).toUpperCase() + typeId.slice(1),
                singular: typeSingular || typeId.slice(0, -1).charAt(0).toUpperCase() + typeId.slice(0, -1).slice(1)
            });
            
            // Switch to the new type
            state.selectedType = typeId;
            state.selectedObject = null;
            
            // Close the modal and update UI
            document.getElementById('add-type-modal').classList.remove('show');
            renderObjectList();
            renderEditor();
            renderPreview();
            updateSidebarButtons();
            saveToLocalStorage();
        }

        function showAddTypeModal() {
            // Create the modal if it doesn't exist
            if (!document.getElementById('add-type-modal')) {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.id = 'add-type-modal';
                modal.innerHTML = `
                    <div class="modal-content">
                        <h2>Add New Object Type</h2>
                        <div class="form-group">
                            <label for="new-type-id">Type ID (plural, e.g. "weapons"):</label>
                            <input type="text" id="new-type-id" placeholder="e.g. weapons">
                        </div>
                        <div class="form-group">
                            <label for="new-type-name">Display Name (plural):</label>
                            <input type="text" id="new-type-name" placeholder="e.g. Weapons">
                        </div>
                        <div class="form-group">
                            <label for="new-type-singular">Singular Name:</label>
                            <input type="text" id="new-type-singular" placeholder="e.g. Weapon">
                        </div>
                        <div class="actions">
                            <button class="primary" id="create-type-btn">Create Type</button>
                            <button id="close-add-type-modal">Cancel</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Add event listeners
                document.getElementById('create-type-btn').addEventListener('click', createNewType);
                document.getElementById('close-add-type-modal').addEventListener('click', () => {
                    document.getElementById('add-type-modal').classList.remove('show');
                });
            }
            
            // Show the modal
            document.getElementById('add-type-modal').classList.add('show');
        }

        function showRemoveTypeModal() {
            // Create the modal if it doesn't exist
            if (!document.getElementById('remove-type-modal')) {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.id = 'remove-type-modal';
                modal.innerHTML = `
                    <div class="modal-content">
                        <h2>Remove Object Type</h2>
                        <div class="warning" style="color: #f44; margin: 10px 0;">
                            Warning: This will permanently delete all objects of this type!
                        </div>
                        <div class="actions">
                            <button class="danger" id="confirm-remove-type-btn">Remove Type</button>
                            <button id="close-remove-type-modal">Cancel</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Add event listeners
                document.getElementById('confirm-remove-type-btn').addEventListener('click', removeSelectedType);
                document.getElementById('close-remove-type-modal').addEventListener('click', () => {
                    document.getElementById('remove-type-modal').classList.remove('show');
                });
            }
            
            // Show the modal
            document.getElementById('remove-type-modal').classList.add('show');
        }

        function removeSelectedType() {
            const typeId = state.selectedType;
            
            if (!typeId) return;
            
            // Prevent removing all types
            if (state.objectTypeDefinitions.length <= 1) {
                alert('Cannot remove the last object type');
                return;
            }
            
            // Remove the type
            delete state.objectTypes[typeId];
            state.objectTypeDefinitions = state.objectTypeDefinitions.filter(type => type.id !== typeId);
            
            // Switch to the first available type
            state.selectedType = state.objectTypeDefinitions[0].id;
            state.selectedObject = null;
            
            // Close the modal and update UI
            document.getElementById('remove-type-modal').classList.remove('show');
            renderObjectList();
            renderEditor();
            renderPreview();
            updateSidebarButtons();
            saveToLocalStorage();
        }
        // Update HTML for sidebar buttons
        function updateSidebarButtons() {
            const singularType = getSingularType(state.selectedType);
            document.getElementById('add-object-btn').textContent = `Add New ${singularType}`;
            document.getElementById('import-export-btn').textContent = `Import/Export ${getPluralType(state.selectedType)}`;
        }

        /**
         * Application initialization
         */
        function init() {
            fetch('/config/game_config.json')
                .then(response => {
                    if (!response.ok) throw new Error('File not found');
                    return response.json();
                })
                .then(config => {
                    state.objectTypes = config;                    
                    if(state.objectTypes.objectTypeDefinitions) {
                        state.objectTypeDefinitions = state.objectTypes.objectTypeDefinitions;
                        delete state.objectTypes.objectTypeDefinitions;                           
                    }
                    // Set up event listeners
                    setupEventListeners();
                    
                    // Render initial UI
                    renderObjectList();
                    updateSidebarButtons();                    
                    
                    if (Object.keys(state.objectTypes[state.selectedType]).length > 0) {
                        selectObject(Object.keys(state.objectTypes[state.selectedType])[0]);
                    }    
                })
                .catch(error => {
                    console.error('Error loading config:', error);
                });             
        }
        
           
        // Initialize the application
        init();
    })();
    
    
    (function() {
        // Global variables
        let camera, scene, renderer, controls;
        let renderData = { animations: { "idle": [{ shapes: [] }] } }; // Default to an empty idle animation
        let selectedShapeIndex = -1;

        let currentAnimation = "idle"; // Current animation type
        let currentFrame = 0; // Current frame index within the animation

        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let selectedOutline, originalMaterials = new Map();
        let isDragging = false;
        let clickStartTime = 0;
        let isPreviewingAnimation = false;
        // Initialize the application
        function init() {
            initThreeJS();
            initEventListeners();
            
            // Initial render
            renderShapes(renderData, { scene }, false);
            updateShapeList();
            animate();
        }
        
        // Initialize Three.js
        function initThreeJS() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.x = 100;
            camera.position.y = 100;
            camera.position.z = 100;
            camera.lookAt(0, 0, 0);
            // Create renderer
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            
            // Add grid helper
            const gridHelper = new THREE.GridHelper(100, 100);
            scene.add(gridHelper);
            
            // Add axes helper
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // Create raycaster for object selection
            raycaster = new THREE.Raycaster();
            
            // Add orbit controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            });
        }

        
        // Show the isometric modal
        function showIsometricModal() {
            document.getElementById('isometric-modal').classList.add('show');
        }

        function generateIsometricSprites() {
            const frustumSize = parseFloat(document.getElementById('iso-frustum').value) || 48;
            const cameraDistance = parseFloat(document.getElementById('iso-distance').value) || 100;
            const size = parseFloat(document.getElementById('iso-size').value) || 64;
            const aspect = 1;
            const tempRenderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            tempRenderer.setSize(size, size);
            document.getElementById('isometric-modal').classList.remove('show');

            const renderTarget = new THREE.WebGLRenderTarget(size, size);
            const cameras = [
                new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000),
                new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000),
                new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000),
                new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000)
            ];
            cameras[0].position.set(cameraDistance, cameraDistance, cameraDistance);
            cameras[1].position.set(-cameraDistance, cameraDistance, cameraDistance);
            cameras[2].position.set(cameraDistance, cameraDistance, -cameraDistance);
            cameras[3].position.set(-cameraDistance, cameraDistance, -cameraDistance);
            cameras.forEach(camera => camera.lookAt(0, 0, 0));

            const sprites = {};
            for (const animType in renderData.animations) {
                sprites[animType] = [];
                renderData.animations[animType].forEach(frame => {
                    const scene = new THREE.Scene();
                    const light = new THREE.AmbientLight(0xffffff, 5);
                    scene.add(light);
                    createObjectsFromJSON(frame, scene);

                    const frameSprites = [];
                    for (const camera of cameras) {
                        tempRenderer.setRenderTarget(renderTarget);
                        tempRenderer.render(scene, camera);
                        const buffer = new Uint8Array(size * size * 4);
                        tempRenderer.readRenderTargetPixels(renderTarget, 0, 0, size, size, buffer);
                        const flippedBuffer = new Uint8Array(size * size * 4);
                        for (let y = 0; y < size; y++) {
                            const srcRowStart = y * size * 4;
                            const destRowStart = (size - 1 - y) * size * 4;
                            flippedBuffer.set(buffer.subarray(srcRowStart, srcRowStart + size * 4), destRowStart);
                        }
                        const canvas = document.createElement('canvas');
                        canvas.width = size;
                        canvas.height = size;
                        const ctx = canvas.getContext('2d');
                        const imageData = ctx.createImageData(size, size);
                        imageData.data.set(flippedBuffer);
                        ctx.putImageData(imageData, 0, 0);
                        frameSprites.push(canvas.toDataURL());
                    }
                    sprites[animType].push(frameSprites);
                });
            }

            tempRenderer.setRenderTarget(null);
            tempRenderer.dispose();
            renderTarget.dispose();
            displayIsometricSprites(sprites);
        }

        function displayIsometricSprites(sprites) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background-color: rgba(0, 0, 0, 0.7); z-index: 1000; 
                display: flex; align-items: center; justify-content: center;
            `;
            const content = document.createElement('div');
            content.style.cssText = `
                background: #333; padding: 20px; border-radius: 8px; 
                max-width: 80%; max-height: 80%; overflow: auto;
            `;

            for (const animType in sprites) {
                const animSection = document.createElement('div');
                const title = document.createElement('h3');
                title.textContent = `${animType} Animation`;
                title.style.color = '#e0e0e0';
                animSection.appendChild(title);

                const grid = document.createElement('div');
                grid.style.cssText = `display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin: 10px 0;`;
                sprites[animType].forEach(frame => {
                    frame.forEach(src => {
                        const img = document.createElement('img');
                        img.src = src;
                        img.style.maxWidth = '100%';
                        grid.appendChild(img);
                    });
                });
                animSection.appendChild(grid);
                content.appendChild(animSection);
            }

            const closeButton = document.createElement('button');
            closeButton.textContent = 'Close';
            closeButton.style.cssText = `
                margin-top: 20px; padding: 8px 16px; background-color: #4CAF50; 
                color: #fff; border: none; border-radius: 6px; cursor: pointer;
            `;
            closeButton.addEventListener('click', () => document.body.removeChild(modal));
            content.appendChild(closeButton);
            modal.appendChild(content);
            document.body.appendChild(modal);
        }
        // Initialize event listeners
        function initEventListeners() {
            document.getElementById('add-shape').addEventListener('click', addNewShape);     
            document.getElementById('preview-animation').addEventListener('click', togglePreview);       
            document.getElementById('duplicate-shape').addEventListener('click', duplicateSelectedShape);         
            document.getElementById('delete-shape').addEventListener('click', deleteSelectedShape);                           
            document.getElementById('scale-all').addEventListener('click', scaleAllShapes);                       
            document.getElementById('rotate-all').addEventListener('click', rotateAllShapes);            
            document.getElementById('move-all').addEventListener('click', moveAllShapes);
            document.getElementById('generate-isometric').addEventListener('click', showIsometricModal);
            document.getElementById('add-animation').addEventListener('click', addNewAnimation);
            document.getElementById('delete-animation').addEventListener('click', deleteAnimation);
            document.getElementById('duplicate-frame').addEventListener('click', duplicateFrame);
            document.getElementById('delete-frame').addEventListener('click', deleteFrame);
            document.body.addEventListener('viewObject', (event) => {
                setPreviewAnimationState(false);
                renderData = event.detail;
                document.getElementById('json-content').value =  JSON.stringify(renderData, null, 2);
                currentAnimation = "idle";
                selectedShapeIndex = renderData.animations.idle[0].shapes.length > 0 ? 0 : -1;                
                renderShapes(renderData, { scene }, false);
                updateShapeList();
            });
            // Canvas click event for shape selection
            const canvas = document.getElementById('canvas');
            canvas.addEventListener('mousedown', (event) => {
                isDragging = false;
                clickStartTime = Date.now();
            });
            
            canvas.addEventListener('mousemove', () => {
                if (Date.now() - clickStartTime > 100) {
                    isDragging = true;
                }
            });
            
            canvas.addEventListener('mouseup', (event) => {
                if (isDragging) return; // Ignore if dragging
                
                // Calculate mouse position in normalized device coordinates
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / canvas.clientWidth) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / canvas.clientHeight) * 2 + 1;
                
                // Update the picking ray with the camera and mouse position
                raycaster.setFromCamera(mouse, camera);
                
                // Calculate objects intersecting the picking ray
                const shapes = scene.children.filter(obj => obj.userData.isShape);
                const intersects = raycaster.intersectObjects(shapes);
                
                if (intersects.length > 0) {
                    const index = intersects[0].object.userData.index;
                    selectShape(index);
                }
            });

            document.getElementById('move-cancel').addEventListener('click', () => {
                document.getElementById('move-modal').classList.remove('show');
            });

            document.getElementById('move-apply').addEventListener('click', () => {
                const xOffset = parseFloat(document.getElementById('move-x').value) || 0;
                const yOffset = parseFloat(document.getElementById('move-y').value) || 0;
                const zOffset = parseFloat(document.getElementById('move-z').value) || 0;
                
                // Apply the offset to all shapes
                renderData.animations[currentAnimation][currentFrame].shapes.forEach(shape => {
                    shape.x = (shape.x || 0) + xOffset;
                    shape.y = (shape.y || 0) + yOffset;
                    shape.z = (shape.z || 0) + zOffset;
                });
                renderShapes(renderData, { scene }, true);
                updateShapeList();
                
                // Hide the modal
                document.getElementById('move-modal').classList.remove('show');
            });
            document.getElementById('iso-cancel').addEventListener('click', () => {
                document.getElementById('isometric-modal').classList.remove('show');
            });
            document.getElementById('iso-generate').addEventListener('click', generateIsometricSprites);
        }
        function togglePreview(e) {
            isPreviewingAnimation = !isPreviewingAnimation;
            animatePreview();
            setPreviewAnimationState(isPreviewingAnimation);            
        }
        function setPreviewAnimationState(isPreviewing) {
            isPreviewingAnimation = isPreviewing
            let btn = document.getElementById('preview-animation');
            if (isPreviewingAnimation) {
                btn.classList.add("active");
            } else {
                currentFrame = 0;
                btn.classList.remove("active");
            }
        }
        function animatePreview() {
            if (!isPreviewingAnimation) return;
            currentFrame = (currentFrame + 1) % renderData.animations[currentAnimation].length;
            renderShapes(renderData, { scene }, false);
            //updateShapeList();
            setTimeout(animatePreview, 166); // ~6 FPS, adjust as needed
        }
        // Select a shape
        function selectShape(index) {
            if(isPreviewingAnimation){
                setPreviewAnimationState(false);
            }
            selectedShapeIndex = (selectedShapeIndex === index) ? -1 : index;
            updateShapeList();
            highlightSelectedShape();
        }
        
        // Highlight the selected shape
        function highlightSelectedShape() {
            // Remove existing outlines
            scene.children.forEach(obj => {
                if (obj.userData.isOutline) {
                    scene.remove(obj);
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                }
            });
            
            // Reset any highlighted materials
            originalMaterials.forEach((material, object) => {
                object.material = material;
            });
            originalMaterials.clear();
            
            // If no shape is selected, return
            if (selectedShapeIndex < 0 || selectedShapeIndex >= renderData.animations.idle[0].shapes.length) {
                return;
            }
  
            // Find the selected mesh
            const selectedMesh = scene.children.find(obj => 
                obj.userData.isShape && obj.userData.index === selectedShapeIndex
            );
            
            if (selectedMesh) {
                // Store original material
                originalMaterials.set(selectedMesh, selectedMesh.material);
                
                // Create a new material based on the original one but with emissive glow
                const highlightMaterial = selectedMesh.material.clone();
                highlightMaterial.emissive = new THREE.Color(0x555555);
                highlightMaterial.emissiveIntensity = 0.5;
                
                // Apply the highlight material
                selectedMesh.material = highlightMaterial;
                
                // Create outline
                const outlineGeometry = selectedMesh.geometry.clone();
                const outlineMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00, 
                    side: THREE.BackSide 
                });
                
                const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
                outline.position.copy(selectedMesh.position);
                outline.rotation.copy(selectedMesh.rotation);
                outline.scale.multiplyScalar(1.05);
                outline.userData.isOutline = true;
                
                scene.add(outline);
            }
        }
        function addNewShape() {
            const newShape = {
                type: 'cube',
                size: 2,
                color: '#3498db',
                x: 0,
                y: 0,
                z: 0,
                rotationX: 0,
                rotationY: 0,
                rotationZ: 0
            };
            renderData.animations[currentAnimation][currentFrame].shapes.push(newShape);
            selectedShapeIndex = renderData.animations[currentAnimation][currentFrame].shapes.length - 1;
            renderShapes(renderData, { scene });
            updateShapeList();
        }

        function duplicateSelectedShape() {
            if (selectedShapeIndex >= 0) {
                const originalShape = renderData.animations[currentAnimation][currentFrame].shapes[selectedShapeIndex];
                const newShape = JSON.parse(JSON.stringify(originalShape));
                renderData.animations[currentAnimation][currentFrame].shapes.push(newShape);
                selectedShapeIndex = renderData.animations[currentAnimation][currentFrame].shapes.length - 1;
                renderShapes(renderData, { scene });
                updateShapeList();
            }
        }

        function deleteSelectedShape() {
            if (selectedShapeIndex >= 0) {
                renderData.animations[currentAnimation][currentFrame].shapes.splice(selectedShapeIndex, 1);
                if (renderData.animations[currentAnimation][currentFrame].shapes.length > 0) {
                    selectedShapeIndex = Math.min(selectedShapeIndex, renderData.animations[currentAnimation][currentFrame].shapes.length - 1);
                } else {
                    selectedShapeIndex = -1;
                }
                renderShapes(renderData, { scene });
                updateShapeList();
            }
        }

        function scaleAllShapes() {
            if (renderData.animations[currentAnimation][currentFrame].shapes.length === 0) return;
            const scaleFactor = parseFloat(prompt("Enter scale factor (e.g. 2 for double size, 0.5 for half size):", "1"));
            if (isNaN(scaleFactor) || scaleFactor <= 0) {
                alert("Please enter a valid positive number");
                return;
            }
            let centerX = 0, centerY = 0, centerZ = 0;
            renderData.animations[currentAnimation][currentFrame].shapes.forEach(shape => {
                centerX += shape.x || 0;
                centerY += shape.y || 0;
                centerZ += shape.z || 0;
            });
            centerX /= renderData.animations[currentAnimation][currentFrame].shapes.length;
            centerY /= renderData.animations[currentAnimation][currentFrame].shapes.length;
            centerZ /= renderData.animations[currentAnimation][currentFrame].shapes.length;
            renderData.animations[currentAnimation][currentFrame].shapes.forEach(shape => {
                if (shape.size) shape.size *= scaleFactor;
                if (shape.width) shape.width *= scaleFactor;
                if (shape.height) shape.height *= scaleFactor;
                if (shape.depth) shape.depth *= scaleFactor;
                if (shape.tubeSize) shape.tubeSize *= scaleFactor;
                shape.x = centerX + ((shape.x || 0) - centerX) * scaleFactor;
                shape.y = centerY + ((shape.y || 0) - centerY) * scaleFactor;
                shape.z = centerZ + ((shape.z || 0) - centerZ) * scaleFactor;
            });
            renderShapes(renderData, { scene });
            updateShapeList();
        }
        function rotateAllShapes() {
            const currentShapes = renderData.animations[currentAnimation][currentFrame].shapes;
            if (currentShapes.length === 0) return;

            // Get modal elements
            const rotateModal = document.getElementById('rotate-modal');
            const rotateAngleInput = document.getElementById('rotate-angle');
            const rotateAxisSelect = document.getElementById('rotate-axis');
            const rotateCancelBtn = document.getElementById('rotate-cancel');
            const rotateApplyBtn = document.getElementById('rotate-apply');

            // Reset inputs to default values
            rotateAngleInput.value = "0";
            rotateAxisSelect.value = "y"; // Default to Y-axis

            // Show the modal
            rotateModal.classList.add('show');

            // Cancel button handler
            rotateCancelBtn.onclick = () => {
                rotateModal.classList.remove('show');
            };

            // Apply button handler
            rotateApplyBtn.onclick = () => {
                const angleDeg = parseFloat(rotateAngleInput.value);
                if (isNaN(angleDeg)) {
                    alert("Please enter a valid angle");
                    return;
                }

                const axis = rotateAxisSelect.value;
                const angleRad = angleDeg * Math.PI / 180;

                // Calculate the center of all shapes in the current frame
                let centerX = 0, centerY = 0, centerZ = 0;
                currentShapes.forEach(shape => {
                    centerX += shape.x || 0;
                    centerY += shape.y || 0;
                    centerZ += shape.z || 0;
                });
                centerX /= currentShapes.length;
                centerY /= currentShapes.length;
                centerZ /= currentShapes.length;

                // Rotate shapes around the group center by adjusting positions
                currentShapes.forEach(shape => {
                    const x = shape.x || 0;
                    const y = shape.y || 0;
                    const z = shape.z || 0;

                    // Translate to origin relative to center
                    const relX = x - centerX;
                    const relY = y - centerY;
                    const relZ = z - centerZ;

                    // Apply rotation around the chosen axis
                    if (axis === 'x') {
                        // X-axis rotation (y-z plane)
                        const newRelY = relY * Math.cos(angleRad) - relZ * Math.sin(angleRad);
                        const newRelZ = relY * Math.sin(angleRad) + relZ * Math.cos(angleRad);
                        shape.y = centerY + newRelY;
                        shape.z = centerZ + newRelZ;
                        // x remains unchanged
                    } else if (axis === 'y') {
                        // Y-axis rotation (x-z plane)
                        const newRelX = relX * Math.cos(angleRad) + relZ * Math.sin(angleRad);
                        const newRelZ = -relX * Math.sin(angleRad) + relZ * Math.cos(angleRad);
                        shape.x = centerX + newRelX;
                        shape.z = centerZ + newRelZ;
                        // y remains unchanged
                    } else if (axis === 'z') {
                        // Z-axis rotation (x-y plane)
                        const newRelX = relX * Math.cos(angleRad) - relY * Math.sin(angleRad);
                        const newRelY = relX * Math.sin(angleRad) + relY * Math.cos(angleRad);
                        shape.x = centerX + newRelX;
                        shape.y = centerY + newRelY;
                        // z remains unchanged
                    }
                    // Individual rotations (rotationX, rotationY, rotationZ) are preserved
                });

                // Update the scene and hide the modal
                renderShapes(renderData, { scene });
                updateShapeList();
                rotateModal.classList.remove('show');
            };
        }
        function moveAllShapes() {
            if (renderData.animations[currentAnimation][currentFrame].shapes.length === 0) return;
            document.getElementById('move-modal').classList.add('show');
            document.getElementById('move-x').value = '0';
            document.getElementById('move-y').value = '0';
            document.getElementById('move-z').value = '0';
        }
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        function createObjectsFromJSON(shapeData, scene) {
  
            shapeData.shapes.forEach((shape, index) => {
                let geometry, material, mesh;

                // Create material with the specified color
                material = new THREE.MeshStandardMaterial({ color: shape.color });

                
                // Create geometry based on shape type
                if (shape.type === 'sphere') {
                    geometry = new THREE.SphereGeometry(shape.size / 2, 32, 32);
                }
                else if (shape.type === 'cube') {
                    geometry = new THREE.BoxGeometry(shape.size, shape.size, shape.size);
                }
                else if (shape.type === 'box') {
                    geometry = new THREE.BoxGeometry(shape.width, shape.height, shape.depth || shape.width);
                }
                else if (shape.type === 'cylinder') {
                    geometry = new THREE.CylinderGeometry(shape.size / 2, shape.size / 2, shape.height, 32);
                }
                else if (shape.type === 'cone') {
                    geometry = new THREE.ConeGeometry(shape.size / 2, shape.height, 32);
                }
                else if (shape.type === 'torus') {
                    geometry = new THREE.TorusGeometry(shape.size / 2, shape.tubeSize || shape.size / 6, 16, 100);
                }
                else if (shape.type === 'tetrahedron') {
                    geometry = new THREE.TetrahedronGeometry(shape.size / 2);
                }
                
                if (geometry) {
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.userData.isShape = true;                    
                    mesh.userData.index = index;

                    // Position and rotation
                    mesh.position.set(shape.x || 0, shape.y || 0, shape.z || 0);
                    
                    // Handle rotation (convert from degrees to radians)
                    if (shape.rotationX) mesh.rotation.x = shape.rotationX * Math.PI / 180;
                    if (shape.rotationY) mesh.rotation.y = shape.rotationY * Math.PI / 180;
                    if (shape.rotationZ) mesh.rotation.z = shape.rotationZ * Math.PI / 180;
                    
                    scene.add(mesh);
                }
            });
        }
        // Render shapes function (imported from your code)
        function renderShapes(renderData, ctx3D, fireSave=true) {
            const { scene } = ctx3D;
           
            // Clear existing shapes
            const objectsToRemove = [];
            scene.traverse(object => {
                if (object.userData.isShape || object.userData.isOutline) {
                    objectsToRemove.push(object);
                }
            });
            
            objectsToRemove.forEach(obj => {
                scene.remove(obj);
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material) {
                    if(obj.material.map) obj.material.map.dispose(); // dispose textures
                    obj.material.dispose();
                }
            });
            
            // Add lights if they don't exist
            if (!scene.getObjectByName('ambient-light')) {
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                ambientLight.name = 'ambient-light';
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 7.5);
                directionalLight.name = 'dir-light';
                scene.add(directionalLight);
            }
            const currentShapes = renderData.animations[currentAnimation][currentFrame];
            createObjectsFromJSON(currentShapes, scene);
            
            // Update shape count
            document.getElementById('shape-count').textContent = currentShapes.shapes.length;
            
            // Update the JSON editor
            document.getElementById('json-content').value = JSON.stringify(renderData, null, 2);

            if(fireSave){
                        // Create a custom event with data
                const myCustomEvent = new CustomEvent('saveObjectGraphics', {
                    detail: renderData, // Custom data
                    bubbles: true, // Allows the event to bubble up (optional)
                    cancelable: true // Allows the event to be canceled (optional)
                });

                // Dispatch the event
                document.body.dispatchEvent(myCustomEvent);
            }
            // Highlight the selected shape (if any)
            highlightSelectedShape();
        }
        
        function addNewAnimation() {
            const animName = prompt("Enter animation name:", `anim${Object.keys(renderData.animations).length + 1}`);
            if (animName && !renderData.animations[animName]) {
                renderData.animations[animName] = [ ...renderData.animations["idle"] ];
                currentAnimation = animName;
                currentFrame = 0;
                renderShapes(renderData, { scene });
                updateShapeList();
            }
        }
        
        function deleteAnimation() {
            if( currentAnimation != "idle") {
                delete renderData.animations[currentAnimation];
                currentAnimation = "idle";
                currentFrame = 0;
                selectedShapeIndex = -1;
                renderShapes(renderData, { scene });
                updateShapeList();
            }
        }

        function duplicateFrame() {
            if (renderData.animations[currentAnimation].length > 0) {
                const currentShapes = renderData.animations[currentAnimation][currentFrame];
                const newFrame = { shapes: JSON.parse(JSON.stringify(currentShapes.shapes)) };
                renderData.animations[currentAnimation].splice(currentFrame + 1, 0, newFrame);
                currentFrame++;
                renderShapes(renderData, { scene });
                updateShapeList();
            }
        }

        function deleteFrame() {
            if (renderData.animations[currentAnimation].length > 1) {
                renderData.animations[currentAnimation].splice(currentFrame, 1);
                currentFrame = Math.min(currentFrame, renderData.animations[currentAnimation].length - 1);
                renderShapes(renderData, { scene });
                updateShapeList();
            }
        }
        // Update the shape list in the sidebar
        function updateShapeList() {
            const shapeList = document.getElementById('shape-list');
            shapeList.innerHTML = '';

            // Animation selector
            const animSelector = document.createElement('select');
            animSelector.style.marginBottom = '10px';
            Object.keys(renderData.animations).forEach(anim => {
                const option = document.createElement('option');
                option.value = anim;
                option.textContent = anim;
                if (anim === currentAnimation) option.selected = true;
                animSelector.appendChild(option);
            });
            animSelector.addEventListener('change', () => {
                setPreviewAnimationState(false);
                currentAnimation = animSelector.value;
                currentFrame = 0;
                selectedShapeIndex = -1;
                renderShapes(renderData, { scene });
                updateShapeList();
            });
            shapeList.appendChild(animSelector);

            // Frame list
            const frameList = document.createElement('div');
            frameList.style.marginBottom = '10px';
            renderData.animations[currentAnimation].forEach((frame, index) => {
                const frameItem = document.createElement('div');
                frameItem.textContent = `Frame ${index + 1}`;
                frameItem.style.padding = '5px';
                frameItem.style.cursor = 'pointer';
                if (index === currentFrame) frameItem.style.backgroundColor = '#555';
                frameItem.addEventListener('click', () => {
                    setPreviewAnimationState(false);
                    currentFrame = index;
                    renderShapes(renderData, { scene });
                    updateShapeList();
                });
                frameList.appendChild(frameItem);
            });
            shapeList.appendChild(frameList);

            // Shape list for current frame
            const currentShapes = renderData.animations[currentAnimation][currentFrame].shapes;
            if (currentShapes.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.textContent = 'No shapes in this frame.';
                emptyMessage.style.padding = '10px';
                emptyMessage.style.color = '#777';
                shapeList.appendChild(emptyMessage);
                document.getElementById('selected-shape').textContent = 'None';
                return;
            }

            currentShapes.forEach((shape, index) => {
                const shapeItem = document.createElement('div');
                shapeItem.className = 'shape-item';
                if (index === selectedShapeIndex) {
                    shapeItem.classList.add('active');
                    document.getElementById('selected-shape').textContent = `${shape.type} (${index})`;
                }
                const title = document.createElement('div');
                title.textContent = `${index + 1}. ${shape.name || shape.type} ${shape.color}`;
                title.style.fontWeight = 'bold';
                title.style.marginBottom = '5px';
                shapeItem.appendChild(title);
                const position = document.createElement('div');
                position.textContent = `Position: X=${shape.x || 0}, Y=${shape.y || 0}, Z=${shape.z || 0}`;
                position.style.fontSize = '12px';
                shapeItem.appendChild(position);
                shapeItem.addEventListener('click', () => {
                    selectShape(index);
                    createInspector(shape);
                });
                shapeList.appendChild(shapeItem);
            });

            if (selectedShapeIndex >= 0) {
                let shape = currentShapes[selectedShapeIndex];
                if( shape ) {
                    createInspector(shape);
                } else {
                    const inspector = document.getElementById('inspector');
                    inspector.innerHTML = "";
                    selectedShapeIndex = -1;
                    renderShapes(renderData, { scene });
                    updateShapeList();
                }

            }
        }
        
        // Create the inspector panel for editing a shape
        function createInspector(shape) {
            const shapeList = document.getElementById('shape-list');            
     
            const inspector = document.getElementById('inspector');
            inspector.innerHTML = "";
            inspector.className = 'inspector';
            
            addFormRow(inspector, 'Name', 'text', 'name', shape.name || "");
            // Type selector
            addFormRow(inspector, 'Type', 'select', 'type', shape.type, {
                options: ['cube', 'sphere', 'box', 'cylinder', 'cone', 'torus', 'tetrahedron']
            });
            
            // Color picker
            addFormRow(inspector, 'Color', 'color', 'color', shape.color);
            
            // Position inputs
            addFormRow(inspector, 'X Position', 'number', 'x', shape.x || 0, { step: 0.1 });
            addFormRow(inspector, 'Y Position', 'number', 'y', shape.y || 0, { step: 0.1 });
            addFormRow(inspector, 'Z Position', 'number', 'z', shape.z || 0, { step: 0.1 });
            
            // Rotation inputs
            addFormRow(inspector, 'X Rotation', 'number', 'rotationX', shape.rotationX || 0, { step: 5 });
            addFormRow(inspector, 'Y Rotation', 'number', 'rotationY', shape.rotationY || 0, { step: 5 });
            addFormRow(inspector, 'Z Rotation', 'number', 'rotationZ', shape.rotationZ || 0, { step: 5 });
            
            // Size inputs
            if (shape.type === 'cube' || shape.type === 'sphere' || shape.type === 'tetrahedron' || shape.type === 'torus') {
                addFormRow(inspector, 'Size', 'number', 'size', shape.size || 2, { min: 0.1, step: 0.1 });
            }
            
            if (shape.type === 'box') {
                addFormRow(inspector, 'Width', 'number', 'width', shape.width || 2, { min: 0.1, step: 0.1 });
                addFormRow(inspector, 'Height', 'number', 'height', shape.height || 2, { min: 0.1, step: 0.1 });
                addFormRow(inspector, 'Depth', 'number', 'depth', shape.depth || 2, { min: 0.1, step: 0.1 });
            }
            
            if (shape.type === 'cylinder' || shape.type === 'cone') {
                addFormRow(inspector, 'Size', 'number', 'size', shape.size || 2, { min: 0.1, step: 0.1 });
                addFormRow(inspector, 'Height', 'number', 'height', shape.height || 3, { min: 0.1, step: 0.1 });
            }
            
            if (shape.type === 'torus') {
                addFormRow(inspector, 'Tube Size', 'number', 'tubeSize', shape.tubeSize || shape.size / 6, { min: 0.1, step: 0.1 });
            }
            
        }
        
        // Add a form row to the inspector
        function addFormRow(container, label, type, property, value, options = {}) {
            const row = document.createElement('div');
            row.className = 'form-row';
            
            const labelElement = document.createElement('label');
            labelElement.textContent = label;
            row.appendChild(labelElement);
            
            let input;
            
            if (type === 'select') {
                input = document.createElement('select');
                (options.options || []).forEach(optionValue => {
                    const option = document.createElement('option');
                    option.value = optionValue;
                    option.textContent = optionValue;
                    if (value === optionValue) {
                        option.selected = true;
                    }
                    input.appendChild(option);
                });
            } else {
                input = document.createElement('input');
                input.type = type;
                input.value = value;
                
                if (type === 'number') {
                    input.min = options.min !== undefined ? options.min : -64;
                    input.max = options.max !== undefined ? options.max : 64;
                    input.step = options.step || 1;
                }
            }
            
            input.addEventListener('change', () => {
                let newValue = input.value;
                
                if (type === 'number') {
                    newValue = parseFloat(newValue);
                }
                
                renderData.animations[currentAnimation][currentFrame].shapes[selectedShapeIndex][property] = newValue;
                renderShapes(renderData, { scene });
                updateShapeList();
            });
            
            row.appendChild(input);
            container.appendChild(row);
        }
        
        // Import JSON configuration
        function importJSON() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.addEventListener('change', e => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        renderData = importedData;
                        selectedShapeIndex = renderData.shapes.length > 0 ? 0 : -1;
                        
                        renderShapes(renderData, { scene });
                        updateShapeList();
                        
                        // Reset camera position
                        camera.position.set(0, 5, 10);
                        controls.target.set(0, 0, 0);
                    } catch (error) {
                        alert('Invalid JSON file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            });
            
            input.click();
        }
        // Apply JSON from editor
        function applyJSON() {
            try {
                const newData = JSON.parse(document.getElementById('json-content').value);
                renderData = newData;
                selectedShapeIndex = renderData.shapes.length > 0 ? 0 : -1;
                
                renderShapes(renderData, { scene });
                updateShapeList();
            } catch (error) {
                alert('Invalid JSON: ' + error.message);
            }
        }

        // Initialize the application when the page loads
        window.addEventListener('load', init);
    })();
   
    </script>
</body>
</html>