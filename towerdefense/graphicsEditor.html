<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Shape Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        body {
            display: flex;
            height: 100vh;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        #sidebar {
            width: 360px;
            background: linear-gradient(180deg, #2a2a2a, #222);
            border-right: 1px solid #555;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
        }
        #canvas-container {
            flex: 1;
            position: relative;
            background: #101010;
        }
        #canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #toolbar {
            padding: 15px;
            border-bottom: 1px solid #555;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            background: #333;
        }
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s, transform 0.1s;
        }
        button:hover {
            background-color: #45a049;
            transform: translateY(-1px);
        }
        button:active {
            transform: translateY(1px);
        }
        #shape-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        .shape-item {
            padding: 12px;
            margin-bottom: 8px;
            background-color: #383838;
            border: 1px solid #555;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .shape-item:hover {
            background-color: #444;
        }
        .shape-item.active {
            background-color: #4a4a4a;
            border-color: #4CAF50;
            color: #fff;
        }
        #inspector {
            padding: 15px;
            background: #2f2f2f;
            border-top: 1px solid #555;
        }
        #json-editor {
            padding: 15px;
            background: #2f2f2f;
            border-top: 1px solid #555;
        }
        #json-editor textarea {
            width: 100%;
            height: 150px;
            resize: none;
            padding: 12px;
            font-family: 'Fira Code', monospace;
            font-size: 13px;
            border: 1px solid #555;
            border-radius: 6px;
            background-color: #383838;
            color: #e0e0e0;
            line-height: 1.5;
        }
        #json-editor-buttons {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }
        .form-row {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .form-row label {
            width: 90px;
            font-size: 14px;
            color: #ccc;
        }
        .form-row input, .form-row select {
            flex: 1;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 4px;
            background-color: #383838;
            color: #e0e0e0;
            font-size: 14px;
        }
        .scene-info {
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            position: absolute;
            bottom: 15px;
            left: 15px;
            border-radius: 6px;
            font-size: 13px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        .button-danger {
            background-color: #e53935;
        }
        .button-danger:hover {
            background-color: #d32f2f;
        }
        #move-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        #move-modal > div {
            background: #333;
            padding: 25px;
            border-radius: 8px;
            width: 320px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        #move-modal h3 {
            margin-bottom: 20px;
            color: #e0e0e0;
            font-size: 18px;
        }
        #move-modal button {
            width: 48%;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <div id="toolbar">
            <button id="add-shape">Add Shape</button>
            <button id="duplicate-shape">Duplicate</button>
            <button id="delete-shape" class="button-danger">Delete</button>
            <button id="scale-all">Scale All</button>
            <button id="move-all">Move All</button>
            <button id="generate-isometric">Isometric Sprites</button> 
        </div>
        <div id="shape-list"></div>
        <div id="inspector"></div>
        <div id="json-editor">
            <textarea id="json-content" placeholder="Edit JSON here..."></textarea>
            <div id="json-editor-buttons">
                <button id="apply-json">Apply</button>
            </div>
        </div>
    </div>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
        <div class="scene-info">
            <div>Shapes: <span id="shape-count">0</span></div>
            <div>Selected: <span id="selected-shape">None</span></div>
            <div><small>Controls: Left-click to select, Drag to rotate, Right-drag to pan, Scroll to zoom</small></div>
        </div>
    </div>
    <div id="move-modal">
        <div>
            <h3>Move All Shapes</h3>
            <div class="form-row">
                <label for="move-x">X Offset:</label>
                <input type="number" id="move-x" value="0" step="0.5">
            </div>
            <div class="form-row">
                <label for="move-y">Y Offset:</label>
                <input type="number" id="move-y" value="0" step="0.5">
            </div>
            <div class="form-row">
                <label for="move-z">Z Offset:</label>
                <input type="number" id="move-z" value="0" step="0.5">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button id="move-cancel">Cancel</button>
                <button id="move-apply">Apply</button>
            </div>
        </div>
    </div>
    <div id="isometric-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #333; padding: 25px; border-radius: 8px; width: 320px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);">
            <h3 style="margin-bottom: 20px; color: #e0e0e0; font-size: 18px;">Generate Isometric Sprites</h3>
            <div class="form-row">
                <label for="iso-frustum">Frustum Size:</label>
                <input type="number" id="iso-frustum" value="48" step="1" min="1">
            </div>
            <div class="form-row">
                <label for="iso-distance">Distance:</label>
                <input type="number" id="iso-distance" value="100" step="1" min="1">
            </div>
            <div class="form-row">
                <label for="iso-size">Sprite Size:</label>
                <input type="number" id="iso-size" value="64" step="1" min="1">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button id="iso-cancel">Cancel</button>
                <button id="iso-generate">Generate</button>
            </div>
        </div>
    </div>
    <script type="module">
        import * as THREE from './three.module.min.js';
        
        import { OrbitControls } from './three.orbitControls.js';
    
        (function() {
        // Global variables
        let camera, scene, renderer, controls;
        let renderData = { shapes: [] };
        let selectedShapeIndex = -1;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let selectedOutline, originalMaterials = new Map();
        let isDragging = false;
        let clickStartTime = 0;
        
        // Initialize the application
        function init() {
            initThreeJS();
            initEventListeners();
            
            // Initial render
            renderShapes(renderData, { scene });
            updateShapeList();
            animate();
        }
        
        // Initialize Three.js
        function initThreeJS() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.x = 100;
            camera.position.y = 100;
            camera.position.z = 100;
            camera.lookAt(0, 0, 0);
            // Create renderer
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            
            // Add grid helper
            const gridHelper = new THREE.GridHelper(100, 100);
            scene.add(gridHelper);
            
            // Add axes helper
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // Create raycaster for object selection
            raycaster = new THREE.Raycaster();
            
            // Add orbit controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            });
        }

        
        // Show the isometric modal
        function showIsometricModal() {
            document.getElementById('isometric-modal').style.display = 'block';
        }

        // Generate isometric sprites
        function generateIsometricSprites() {
            const frustumSize = parseFloat(document.getElementById('iso-frustum').value) || 48;
            const cameraDistance = parseFloat(document.getElementById('iso-distance').value) || 100;
            const size = parseFloat(document.getElementById('iso-size').value) || 64;
            const aspect = 1; // Square images for simplicity
            const tempRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            tempRenderer.setSize(size, size);
            // Hide the modal
            document.getElementById('isometric-modal').style.display = 'none';
            // Create a temporary canvas for rendering
            const renderTarget = new THREE.WebGLRenderTarget(size, size);
            const cameras = [
                new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000), // Front
                new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000), // Left
                new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000), // Right
                new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000)  // Back
            ];

            
            // Create scene and lights
            const scene = new THREE.Scene();
            const light = new THREE.AmbientLight(0xffffff, 5);
            scene.add(light);

            // Create objects from JSON and add to scene
            createObjectsFromJSON(renderData, scene);
           

            // Position each camera at different angles
            cameras[0].position.set(cameraDistance, cameraDistance, cameraDistance); // Front
            cameras[1].position.set(-cameraDistance, cameraDistance, cameraDistance); // Left
            cameras[2].position.set(cameraDistance, cameraDistance, -cameraDistance); // Right
            cameras[3].position.set(-cameraDistance, cameraDistance, -cameraDistance); // Back

            cameras.forEach(camera => camera.lookAt(0, 0, 0));

            // Capture images
            const sprites = [];
            for (const camera of cameras) {
                tempRenderer.setRenderTarget(renderTarget);
                tempRenderer.render(scene, camera);

                // Read pixels from render target
                const buffer = new Uint8Array(size * size * 4);
                tempRenderer.readRenderTargetPixels(renderTarget, 0, 0, size, size, buffer);

                // Flip the buffer vertically
                const flippedBuffer = new Uint8Array(size * size * 4);
                for (let y = 0; y < size; y++) {
                    const srcRowStart = y * size * 4;
                    const destRowStart = (size - 1 - y) * size * 4;
                    flippedBuffer.set(buffer.subarray(srcRowStart, srcRowStart + size * 4), destRowStart);
                }
                // Create a canvas to display the image
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(size, size);
                imageData.data.set(flippedBuffer);
                ctx.putImageData(imageData, 0, 0);

                sprites.push(canvas.toDataURL());
            }

            // Reset renderer
            tempRenderer.setRenderTarget(null);
            tempRenderer.dispose();
            renderTarget.dispose();
            // Display the sprites
            displayIsometricSprites(sprites);
        }

        // Display the generated isometric sprites
        function displayIsometricSprites(sprites) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.7);
                z-index: 1000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: #333;
                padding: 20px;
                border-radius: 8px;
                max-width: 80%;
                max-height: 80%;
                overflow: auto;
                text-align: center;
            `;

            const title = document.createElement('h3');
            title.textContent = 'Isometric Sprites';
            title.style.color = '#e0e0e0';
            content.appendChild(title);

            const grid = document.createElement('div');
            grid.style.cssText = `
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                margin-top: 20px;
            `;

            sprites.forEach((src, index) => {
                const img = document.createElement('img');
                img.src = src;
                img.style.maxWidth = '100%';
                img.alt = `Isometric View ${index + 1}`;
                grid.appendChild(img);
            });

            const closeButton = document.createElement('button');
            closeButton.textContent = 'Close';
            closeButton.style.cssText = `
                margin-top: 20px;
                padding: 8px 16px;
                background-color: #4CAF50;
                color: #fff;
                border: none;
                border-radius: 6px;
                cursor: pointer;
            `;
            closeButton.addEventListener('click', () => document.body.removeChild(modal));

            content.appendChild(grid);
            content.appendChild(closeButton);
            modal.appendChild(content);
            document.body.appendChild(modal);
        }
        // Add this function
        function scaleAllShapes() {
            if (renderData.shapes.length === 0) return;
            
            const scaleFactor = parseFloat(prompt("Enter scale factor (e.g. 2 for double size, 0.5 for half size):", "1"));
            
            if (isNaN(scaleFactor) || scaleFactor <= 0) {
                alert("Please enter a valid positive number");
                return;
            }
            
            // Calculate the center point of all shapes (this will be our scaling origin)
            let centerX = 0, centerY = 0, centerZ = 0;
            renderData.shapes.forEach(shape => {
                centerX += shape.x || 0;
                centerY += shape.y || 0;
                centerZ += shape.z || 0;
            });
            
            centerX /= renderData.shapes.length;
            centerY /= renderData.shapes.length;
            centerZ /= renderData.shapes.length;
            
            // Scale each shape's dimensions and adjust positions relative to center
            renderData.shapes.forEach(shape => {
                // Scale dimensions
                if (shape.size) shape.size *= scaleFactor;
                if (shape.width) shape.width *= scaleFactor;
                if (shape.height) shape.height *= scaleFactor;
                if (shape.depth) shape.depth *= scaleFactor;
                if (shape.tubeSize) shape.tubeSize *= scaleFactor;
                
                // Scale positions relative to center point
                shape.x = centerX + ((shape.x || 0) - centerX) * scaleFactor;
                shape.y = centerY + ((shape.y || 0) - centerY) * scaleFactor;
                shape.z = centerZ + ((shape.z || 0) - centerZ) * scaleFactor;
            });
            
            renderShapes(renderData, { scene });
            updateShapeList();
        }
        // Initialize event listeners
        function initEventListeners() {
            // Add shape button
            document.getElementById('add-shape').addEventListener('click', addNewShape);
            
            // Duplicate shape button
            document.getElementById('duplicate-shape').addEventListener('click', duplicateSelectedShape);
            
            // Delete shape button
            document.getElementById('delete-shape').addEventListener('click', deleteSelectedShape);
            
            // Apply JSON button
            document.getElementById('apply-json').addEventListener('click', applyJSON);
                        
            document.getElementById('scale-all').addEventListener('click', scaleAllShapes);
            
            document.getElementById('move-all').addEventListener('click', moveAllShapes);

            document.getElementById('generate-isometric').addEventListener('click', showIsometricModal);

            // Canvas click event for shape selection
            const canvas = document.getElementById('canvas');
            canvas.addEventListener('mousedown', (event) => {
                isDragging = false;
                clickStartTime = Date.now();
            });
            
            canvas.addEventListener('mousemove', () => {
                if (Date.now() - clickStartTime > 100) {
                    isDragging = true;
                }
            });
            
            canvas.addEventListener('mouseup', (event) => {
                if (isDragging) return; // Ignore if dragging
                
                // Calculate mouse position in normalized device coordinates
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / canvas.clientWidth) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / canvas.clientHeight) * 2 + 1;
                
                // Update the picking ray with the camera and mouse position
                raycaster.setFromCamera(mouse, camera);
                
                // Calculate objects intersecting the picking ray
                const shapes = scene.children.filter(obj => obj.userData.isShape);
                const intersects = raycaster.intersectObjects(shapes);
                
                if (intersects.length > 0) {
                    const index = intersects[0].object.userData.index;
                    selectShape(index);
                }
            });

            document.getElementById('move-cancel').addEventListener('click', () => {
                document.getElementById('move-modal').style.display = 'none';
            });

            document.getElementById('move-apply').addEventListener('click', () => {
                const xOffset = parseFloat(document.getElementById('move-x').value) || 0;
                const yOffset = parseFloat(document.getElementById('move-y').value) || 0;
                const zOffset = parseFloat(document.getElementById('move-z').value) || 0;
                
                // Apply the offset to all shapes
                renderData.shapes.forEach(shape => {
                    shape.x = (shape.x || 0) + xOffset;
                    shape.y = (shape.y || 0) + yOffset;
                    shape.z = (shape.z || 0) + zOffset;
                });
                
                renderShapes(renderData, { scene });
                updateShapeList();
                
                // Hide the modal
                document.getElementById('move-modal').style.display = 'none';
            });
            document.getElementById('iso-cancel').addEventListener('click', () => {
                document.getElementById('isometric-modal').style.display = 'none';
            });
            document.getElementById('iso-generate').addEventListener('click', generateIsometricSprites);
        }
        // Add this function
        function moveAllShapes() {
            if (renderData.shapes.length === 0) return;
            
            // Show the modal
            document.getElementById('move-modal').style.display = 'block';
            
            // Reset values
            document.getElementById('move-x').value = '0';
            document.getElementById('move-y').value = '0';
            document.getElementById('move-z').value = '0';
        }
        // Select a shape
        function selectShape(index) {
            selectedShapeIndex = index;
            updateShapeList();
            highlightSelectedShape();
        }
        
        // Highlight the selected shape
        function highlightSelectedShape() {
            // Remove existing outlines
            scene.children.forEach(obj => {
                if (obj.userData.isOutline) {
                    scene.remove(obj);
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                }
            });
            
            // Reset any highlighted materials
            originalMaterials.forEach((material, object) => {
                object.material = material;
            });
            originalMaterials.clear();
            
            // If no shape is selected, return
            if (selectedShapeIndex < 0 || selectedShapeIndex >= renderData.shapes.length) {
                return;
            }
  
            // Find the selected mesh
            const selectedMesh = scene.children.find(obj => 
                obj.userData.isShape && obj.userData.index === selectedShapeIndex
            );
            
            if (selectedMesh) {
                // Store original material
                originalMaterials.set(selectedMesh, selectedMesh.material);
                
                // Create a new material based on the original one but with emissive glow
                const highlightMaterial = selectedMesh.material.clone();
                highlightMaterial.emissive = new THREE.Color(0x555555);
                highlightMaterial.emissiveIntensity = 0.5;
                
                // Apply the highlight material
                selectedMesh.material = highlightMaterial;
                
                // Create outline
                const outlineGeometry = selectedMesh.geometry.clone();
                const outlineMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00, 
                    side: THREE.BackSide 
                });
                
                const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
                outline.position.copy(selectedMesh.position);
                outline.rotation.copy(selectedMesh.rotation);
                outline.scale.multiplyScalar(1.05);
                outline.userData.isOutline = true;
                
                scene.add(outline);
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        function createObjectsFromJSON(shapeData, scene) {
  
            shapeData.shapes.forEach((shape, index) => {
                let geometry, material, mesh;

                // Create material with the specified color
                material = new THREE.MeshStandardMaterial({ color: shape.color });

                
                // Create geometry based on shape type
                if (shape.type === 'sphere') {
                    geometry = new THREE.SphereGeometry(shape.size / 2, 32, 32);
                }
                else if (shape.type === 'cube') {
                    geometry = new THREE.BoxGeometry(shape.size, shape.size, shape.size);
                }
                else if (shape.type === 'box') {
                    geometry = new THREE.BoxGeometry(shape.width, shape.height, shape.depth || shape.width);
                }
                else if (shape.type === 'cylinder') {
                    geometry = new THREE.CylinderGeometry(shape.size / 2, shape.size / 2, shape.height, 32);
                }
                else if (shape.type === 'cone') {
                    geometry = new THREE.ConeGeometry(shape.size / 2, shape.height, 32);
                }
                else if (shape.type === 'torus') {
                    geometry = new THREE.TorusGeometry(shape.size / 2, shape.tubeSize || shape.size / 6, 16, 100);
                }
                else if (shape.type === 'tetrahedron') {
                    geometry = new THREE.TetrahedronGeometry(shape.size / 2);
                }
                
                if (geometry) {
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.userData.isShape = true;                    
                    mesh.userData.index = index;

                    // Position and rotation
                    mesh.position.set(shape.x || 0, shape.y || 0, shape.z || 0);
                    
                    // Handle rotation (convert from degrees to radians)
                    if (shape.rotationX) mesh.rotation.x = shape.rotationX * Math.PI / 180;
                    if (shape.rotationY) mesh.rotation.y = shape.rotationY * Math.PI / 180;
                    if (shape.rotationZ) mesh.rotation.z = shape.rotationZ * Math.PI / 180;
                    
                    scene.add(mesh);
                }
            });
        }
        // Render shapes function (imported from your code)
        function renderShapes(renderData, ctx3D) {
            const { scene } = ctx3D;
           
            // Clear existing shapes
            const objectsToRemove = [];
            scene.traverse(object => {
                if (object.userData.isShape || object.userData.isOutline) {
                    objectsToRemove.push(object);
                }
            });
            
            objectsToRemove.forEach(obj => {
                scene.remove(obj);
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material) {
                    if(obj.material.map) obj.material.map.dispose(); // dispose textures
                    obj.material.dispose();
                }
            });
            
            // Add lights if they don't exist
            if (!scene.getObjectByName('ambient-light')) {
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                ambientLight.name = 'ambient-light';
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 7.5);
                directionalLight.name = 'dir-light';
                scene.add(directionalLight);
            }
            createObjectsFromJSON(renderData, scene);
           
      
            
            // Update shape count
            document.getElementById('shape-count').textContent = renderData.shapes.length;
            
            // Update the JSON editor
            document.getElementById('json-content').value = JSON.stringify(renderData, null, 2);
            
            // Highlight the selected shape (if any)
            highlightSelectedShape();
        }
        
        // Add a new shape
        function addNewShape() {
            const newShape = {
                type: 'cube',
                size: 2,
                color: '#3498db',
                x: 0,
                y: 0,
                z: 0,
                rotationX: 0,
                rotationY: 0,
                rotationZ: 0
            };
            
            renderData.shapes.push(newShape);
            selectedShapeIndex = renderData.shapes.length - 1;
            
            renderShapes(renderData, { scene });
            updateShapeList();
        }
        
        // Duplicate the selected shape
        function duplicateSelectedShape() {
            if (selectedShapeIndex >= 0) {
                const originalShape = renderData.shapes[selectedShapeIndex];
                const newShape = JSON.parse(JSON.stringify(originalShape));
                                
                renderData.shapes.push(newShape);
                selectedShapeIndex = renderData.shapes.length - 1;
                
                renderShapes(renderData, { scene });
                updateShapeList();
            }
        }
        
        // Delete the selected shape
        function deleteSelectedShape() {
            if (selectedShapeIndex >= 0) {
                renderData.shapes.splice(selectedShapeIndex, 1);
                
                if (renderData.shapes.length > 0) {
                    selectedShapeIndex = Math.min(selectedShapeIndex, renderData.shapes.length - 1);
                } else {
                    selectedShapeIndex = -1;
                }
                
                renderShapes(renderData, { scene });
                updateShapeList();
            }
        }
        
        // Update the shape list in the sidebar
        function updateShapeList() {
            const shapeList = document.getElementById('shape-list');
            shapeList.innerHTML = '';
            
            if (renderData.shapes.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.textContent = 'No shapes added. Click "Add Shape" to begin.';
                emptyMessage.style.padding = '10px';
                emptyMessage.style.color = '#777';
                shapeList.appendChild(emptyMessage);
                document.getElementById('selected-shape').textContent = 'None';
                return;
            }
            
            renderData.shapes.forEach((shape, index) => {
                const shapeItem = document.createElement('div');
                shapeItem.className = 'shape-item';
                if (index === selectedShapeIndex) {
                    shapeItem.classList.add('active');
                    document.getElementById('selected-shape').textContent = `${shape.type} (${index})`;
                }
                
                const title = document.createElement('div');
                title.textContent = `${index + 1}. ${shape.type} ${shape.color}`;
                title.style.fontWeight = 'bold';
                title.style.marginBottom = '5px';
                shapeItem.appendChild(title);
                
                const position = document.createElement('div');
                position.textContent = `Position: X=${shape.x || 0}, Y=${shape.y || 0}, Z=${shape.z || 0}`;
                position.style.fontSize = '12px';
                shapeItem.appendChild(position);
                
                shapeItem.addEventListener('click', () => {
                    selectedShapeIndex = index;
                    updateShapeList();
                    highlightSelectedShape();
                    
                    // Scroll the shape into view in the inspector
                    createInspector(shape);
                });
                
                shapeList.appendChild(shapeItem);
            });
            
            // Create inspector for selected shape
            if (selectedShapeIndex >= 0) {
                createInspector(renderData.shapes[selectedShapeIndex]);
            }
        }
        
        // Create the inspector panel for editing a shape
        function createInspector(shape) {
            const shapeList = document.getElementById('shape-list');            
     
            const inspector = document.getElementById('inspector');
            inspector.innerHTML = "";
            inspector.className = 'inspector';
            
            // Type selector
            addFormRow(inspector, 'Type', 'select', 'type', shape.type, {
                options: ['cube', 'sphere', 'box', 'cylinder', 'cone', 'torus', 'tetrahedron']
            });
            
            // Color picker
            addFormRow(inspector, 'Color', 'color', 'color', shape.color);
            
            // Position inputs
            addFormRow(inspector, 'X Position', 'number', 'x', shape.x || 0, { step: 0.1 });
            addFormRow(inspector, 'Y Position', 'number', 'y', shape.y || 0, { step: 0.1 });
            addFormRow(inspector, 'Z Position', 'number', 'z', shape.z || 0, { step: 0.1 });
            
            // Rotation inputs
            addFormRow(inspector, 'X Rotation', 'number', 'rotationX', shape.rotationX || 0, { step: 5 });
            addFormRow(inspector, 'Y Rotation', 'number', 'rotationY', shape.rotationY || 0, { step: 5 });
            addFormRow(inspector, 'Z Rotation', 'number', 'rotationZ', shape.rotationZ || 0, { step: 5 });
            
            // Size inputs
            if (shape.type === 'cube' || shape.type === 'sphere' || shape.type === 'tetrahedron' || shape.type === 'torus') {
                addFormRow(inspector, 'Size', 'number', 'size', shape.size || 2, { min: 0.1, step: 0.1 });
            }
            
            if (shape.type === 'box') {
                addFormRow(inspector, 'Width', 'number', 'width', shape.width || 2, { min: 0.1, step: 0.1 });
                addFormRow(inspector, 'Height', 'number', 'height', shape.height || 2, { min: 0.1, step: 0.1 });
                addFormRow(inspector, 'Depth', 'number', 'depth', shape.depth || 2, { min: 0.1, step: 0.1 });
            }
            
            if (shape.type === 'cylinder' || shape.type === 'cone') {
                addFormRow(inspector, 'Size', 'number', 'size', shape.size || 2, { min: 0.1, step: 0.1 });
                addFormRow(inspector, 'Height', 'number', 'height', shape.height || 3, { min: 0.1, step: 0.1 });
            }
            
            if (shape.type === 'torus') {
                addFormRow(inspector, 'Tube Size', 'number', 'tubeSize', shape.tubeSize || shape.size / 6, { min: 0.1, step: 0.1 });
            }
            
        }
        
        // Add a form row to the inspector
        function addFormRow(container, label, type, property, value, options = {}) {
            const row = document.createElement('div');
            row.className = 'form-row';
            
            const labelElement = document.createElement('label');
            labelElement.textContent = label;
            row.appendChild(labelElement);
            
            let input;
            
            if (type === 'select') {
                input = document.createElement('select');
                (options.options || []).forEach(optionValue => {
                    const option = document.createElement('option');
                    option.value = optionValue;
                    option.textContent = optionValue;
                    if (value === optionValue) {
                        option.selected = true;
                    }
                    input.appendChild(option);
                });
            } else {
                input = document.createElement('input');
                input.type = type;
                input.value = value;
                
                if (type === 'number') {
                    input.min = options.min !== undefined ? options.min : -64;
                    input.max = options.max !== undefined ? options.max : 64;
                    input.step = options.step || 1;
                }
            }
            
            input.addEventListener('change', () => {
                let newValue = input.value;
                
                if (type === 'number') {
                    newValue = parseFloat(newValue);
                }
                
                renderData.shapes[selectedShapeIndex][property] = newValue;
                renderShapes(renderData, { scene });
                updateShapeList();
            });
            
            row.appendChild(input);
            container.appendChild(row);
        }
        
        // Import JSON configuration
        function importJSON() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.addEventListener('change', e => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        renderData = importedData;
                        selectedShapeIndex = renderData.shapes.length > 0 ? 0 : -1;
                        
                        renderShapes(renderData, { scene });
                        updateShapeList();
                        
                        // Reset camera position
                        camera.position.set(0, 5, 10);
                        controls.target.set(0, 0, 0);
                    } catch (error) {
                        alert('Invalid JSON file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            });
            
            input.click();
        }
        // Apply JSON from editor
        function applyJSON() {
            try {
                const newData = JSON.parse(document.getElementById('json-content').value);
                renderData = newData;
                selectedShapeIndex = renderData.shapes.length > 0 ? 0 : -1;
                
                renderShapes(renderData, { scene });
                updateShapeList();
            } catch (error) {
                alert('Invalid JSON: ' + error.message);
            }
        }

        // Initialize the application when the page loads
        window.addEventListener('load', init);
    })();
    </script>
</body>
</html>