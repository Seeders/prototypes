<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600;700&family=Cinzel:wght@500;700&display=swap" rel="stylesheet">
    <style>

:root {
    /* Solid hex colors */
    --primary-dark: #0f2418;      /* Deep forest green */
    --primary-bg: #1a3526;        /* Dark moss green */
    --secondary-bg: #224031;      /* Muted pine green */
    --accent-color: #4a7c59;      /* Fresh green (main accent) - matches grass */
    --bright-accent: #5a9e6f;     /* Lighter, vibrant green */
    --highlight-color: #6abe54;   /* Soft green highlight - matches necroOrb */
    --shadow-color: #3a443c;      /* Darker green for shadows */
    --text-color: #f7f7f0;        /* Off-white for readability - matches our palette */
    --gold-color: #e3d163;        /* Warm gold - matches goldMine inner */
    --essence-color: #7047a3;     /* Purple for essence - matches necromancer color */
    --health-color: #4a7c59;      /* Forest green - matches grass */
    
    /* Opacity variables for use with solid colors */
    --semi-transparent: 0.6;
    --high-transparent: 0.8;
    --very-high-transparent: 0.95;
    --low-transparent: 0.3;
    --overlay-transparent: 0.75;
    --hover-transparent: 0.9;
    --full-transparent: 0.98;
    --near-full-transparent: 0.99;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    margin: 0;
    padding: 0;
    background-color: var(--primary-dark);
    background-image: radial-gradient(circle at center, var(--primary-bg) 0%, var(--primary-dark) 100%);
    color: var(--text-color);
    font-family: 'Crimson Pro', serif;
    overflow: hidden;
    line-height: 1.6;
}

#gameContainer {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 1.5rem;
}

canvas { 
    border: 2px solid var(--accent-color);
    box-shadow: 0 0 30px var(--shadow-color);
    background-color: var(--secondary-bg);
    max-width: 90%;
    border-radius: 8px;
    transition: transform 0.3s ease;
}

#towerMenu {
    width: 800px;
    max-width: 90%;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    justify-content: center;
    padding: 15px;
    background: var(--primary-dark);
    border-radius: 10px;
    border: 1px solid var(--accent-color);
    border-opacity: var(--low-transparent); /* Note: This won't work directly; see below */
    backdrop-filter: blur(5px);
}

.tower-option {
    padding: 8px 14px;
    background: linear-gradient(to bottom, var(--accent-color), var(--secondary-bg));
    opacity: var(--high-transparent);
    border: 1px solid var(--accent-color);
    color: var(--text-color);
    cursor: pointer;
    transition: all 0.3s;
    border-radius: 6px;
    min-width: 110px;
    text-align: center;
    font-family: 'Cinzel', serif;
    font-weight: 500;
    letter-spacing: 0.5px;
    text-shadow: 0 1px 3px #000; /* Black shadow, no rgba */
    box-shadow: 0 3px 6px #000;   /* Black shadow, no rgba */
}

.tower-option:hover { 
    background: linear-gradient(to bottom, var(--bright-accent), var(--accent-color));
    opacity: var(--hover-transparent);
    transform: translateY(-3px);
    box-shadow: 0 6px 12px #000;
}

.tower-option:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px #000;
}

#statsContainer {
    width: 800px;
    max-width: 90%;
    padding: 12px;
    background: var(--primary-dark);
    border-radius: 10px;
    border: 1px solid var(--accent-color);
    border-opacity: var(--low-transparent); /* Note: This won't work directly; see below */
    backdrop-filter: blur(5px);
}

#stats {
    display: flex;
    justify-content: space-around;
    gap: 20px;
    flex-wrap: wrap;
}

.stat {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 1.1rem;
}

.stat-icon {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    box-shadow: 0 0 8px #000;
    display: flex;
    justify-content: center;
    align-items: center;
}

#upgradeMenu { 
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(to bottom, var(--secondary-bg), var(--primary-dark));
    opacity: var(--very-high-transparent);
    color: var(--text-color);
    padding: 25px;
    border-radius: 12px;
    border: 2px solid var(--accent-color);
    display: none;
    z-index: 10;
    width: 450px;
    box-shadow: 0 0 40px var(--shadow-color);
    backdrop-filter: blur(10px);
}

#upgradeMenu h2 {
    text-align: center;
    color: var(--highlight-color);
    margin-top: 0;
    border-bottom: 1px solid var(--accent-color);
    padding-bottom: 15px;
    font-family: 'Cinzel', serif;
    letter-spacing: 1px;
    font-weight: 700;
}

.upgrade-option { 
    margin: 18px 0;
    padding: 18px;
    background: linear-gradient(to right, var(--secondary-bg), var(--primary-bg));
    opacity: var(--high-transparent);
    cursor: pointer;
    border-radius: 8px;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    border: 1px solid var(--accent-color);
    border-opacity: var(--low-transparent); /* Note: This won't work directly; see below */
    box-shadow: 0 4px 8px #000;
}

.upgrade-option:hover { 
    background: linear-gradient(to right, var(--accent-color), var(--bright-accent));
    opacity: var(--hover-transparent);
    transform: translateX(8px);
    box-shadow: 0 6px 12px #000;
}

.upgrade-icon {
    width: 48px;
    height: 48px;
    margin-right: 18px;
    background: linear-gradient(135deg, var(--accent-color), var(--secondary-bg));
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 22px;
    box-shadow: 0 3px 6px #000;
}

.upgrade-desc {
    flex-grow: 1;
}

.upgrade-title {
    font-weight: bold;
    margin-bottom: 6px;
    color: var(--highlight-color);
    font-size: 1.2rem;
    font-family: 'Cinzel', serif;
}

#overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #000;
    opacity: var(--overlay-transparent);
    display: none;
    z-index: 5;
    backdrop-filter: blur(3px);
}

#waveInfo {
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(to right, var(--secondary-bg), var(--primary-bg));
    opacity: var(--high-transparent);
    padding: 8px 20px;
    border-radius: 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    box-shadow: 0 4px 12px #000;
    border: 1px solid var(--accent-color);
    border-opacity: var(--low-transparent); /* Note: This won't work directly; see below */
    backdrop-filter: blur(5px);
}

#waveDisplay {
    font-weight: bold;
    color: var(--highlight-color);
}

.progress-bar {
    width: 220px;
    height: 12px;
    background: var(--primary-dark);
    border-radius: 6px;
    overflow: hidden;
    box-shadow: inset 0 1px 3px #000;
    border: 1px solid var(--accent-color);
    border-opacity: var(--low-transparent); /* Note: This won't work directly; see below */
}

.progress-fill {
    height: 100%;
    background: linear-gradient(to right, var(--accent-color), var(--highlight-color));
    width: 0%;
    box-shadow: 0 0 8px var(--shadow-color);
    transition: width 0.3s ease;
}

#startGameBtn {
    padding: 12px 35px;
    background: linear-gradient(to bottom, var(--bright-accent), var(--accent-color));
    color: white;
    border: none;
    border-radius: 30px;
    cursor: pointer;
    font-family: 'Cinzel', serif;
    font-weight: 500;
    font-size: 1.2rem;
    transition: all 0.3s;
    box-shadow: 0 6px 12px #000;
    text-shadow: 0 1px 2px #000;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 20;
}

#startGameBtn:hover {
    background: linear-gradient(to bottom, var(--highlight-color), var(--bright-accent));
    transform: translate(-50%, -50%) scale(1.05);
    box-shadow: 0 8px 16px #000;
}

#startGameBtn:active {
    transform: translate(-50%, -50%) scale(1);
    box-shadow: 0 4px 8px #000;
}

#tooltip {
    position: absolute;
    background: linear-gradient(to bottom, var(--primary-dark), var(--primary-dark));
    opacity: var(--very-high-transparent);
    color: var(--text-color);
    padding: 12px 15px;
    border-radius: 8px;
    display: none;
    z-index: 100;
    border: 1px solid var(--accent-color);
    pointer-events: none;
    max-width: 280px;
    box-shadow: 0 0 20px var(--shadow-color);
    font-size: 0.95rem;
    backdrop-filter: blur(5px);
}

#gameOverMenu, #victoryMenu {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(to bottom, var(--secondary-bg), var(--primary-dark));
    opacity: var(--full-transparent);
    color: white;
    padding: 40px;
    text-align: center;
    border-radius: 15px;
    border: 3px solid var(--accent-color);
    z-index: 20;
    display: none;
    box-shadow: 0 0 60px var(--shadow-color);
    backdrop-filter: blur(10px);
    min-width: 350px;
}

#gameOverMenu h2, #victoryMenu h2 {
    color: var(--highlight-color);
    font-size: 32px;
    margin-bottom: 20px;
    font-family: 'Cinzel', serif;
    text-shadow: 0 2px 4px #000;
}

#gameOverMenu p, #victoryMenu p {
    font-size: 18px;
    margin-bottom: 25px;
    line-height: 1.6;
}

.menu-button {
    margin-top: 25px;
    padding: 12px 25px;
    background: linear-gradient(to bottom, var(--bright-accent), var(--accent-color));
    border: none;
    color: white;
    cursor: pointer;
    border-radius: 8px;
    transition: all 0.3s;
    font-family: 'Cinzel', serif;
    font-size: 16px;
    letter-spacing: 1px;
    box-shadow: 0 4px 8px #000;
    text-shadow: 0 1px 2px #000;
}

.menu-button:hover {
    background: linear-gradient(to bottom, var(--highlight-color), var(--bright-accent));
    transform: scale(1.05) translateY(-3px);
    box-shadow: 0 6px 15px #000;
}

.menu-button:active {
    transform: scale(1) translateY(0);
    box-shadow: 0 3px 6px #000;
}

/* Stat icons with custom styling */
#shardsDisplay { color: var(--gold-color); font-weight: 600; }
#essenceDisplay, #essenceNeededDisplay { color: var(--essence-color); font-weight: 600; }
#populationDisplay, #maxPopulationDisplay { color: var(--essence-color); font-weight: 600; }
#hpDisplay { color: var(--health-color); font-weight: 600; }



#waveDisplay {
    display: inline-block;
}
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="waveInfo">
            <span>Wave: <span id="waveDisplay">1</span></span>
            <div class="progress-bar">
                <div class="progress-fill" id="waveProgress"></div>
            </div>
        </div>
        
        <div id="statsContainer">
            <div id="stats">
                <div class="stat">
                    <div class="stat-icon" style="background-color: var(--gold-color);"></div>
                    <span>Gold: <span id="shardsDisplay">50</span></span>
                </div>
                <div class="stat">
                    <div class="stat-icon" style="background-color: var(--essence-color);"></div>
                    <span>Essence: <span id="essenceDisplay">0</span>/<span id="essenceNeededDisplay">100</span></span>
                </div>
                <div class="stat">
                    <div class="stat-icon" style="background-color: var(--essence-color);"></div>
                    <span>Population: <span id="populationDisplay">0</span>/<span id="maxPopulationDisplay">5</span></span>
                </div>
                <div class="stat">
                    <div class="stat-icon" style="background-color: var(--health-color);"></div>
                    <span>Core: <span id="hpDisplay">100</span></span>
                </div>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="towerMenu">
            <div class="tower-option" data-type="shoot">Shoot (25)</div>
        </div>
        
        <button id="startGameBtn">Start Game</button>
    </div>
    
    <div id="overlay"></div>
    
    <div id="upgradeMenu">
        <h2>Level Up! Choose an Upgrade:</h2>
        <div id="upgradeOptions"></div>
    </div>
    
    <div id="tooltip"></div>
    
    <div id="gameOverMenu">
        <h2>Home Destroyed!</h2>
        <p>You survived <span id="gameOverWave">0</span> waves</p>
        <button class="menu-button" onclick="resetGame()">Try Again</button>
    </div>
    
    <div id="victoryMenu">
        <h2>Victory!</h2>
        <p>You've successfully defended your Home through all waves!</p>
        <button class="menu-button" onclick="resetGame()">Play Again</button>
    </div>
<script>

const CONFIG = {
    GRID_SIZE: 48,
    CANVAS_WIDTH: 768,
    CANVAS_HEIGHT: 576,
    get ROWS() { return parseInt(this.CANVAS_HEIGHT / this.GRID_SIZE) },
    get COLS() { return parseInt(this.CANVAS_WIDTH / this.GRID_SIZE) }
};

function calculateStats(stats, calcArray) {

    if( calcArray && calcArray.length > 0 ) {
        let additiveStats = {};
        let multiplicitiveStats = {};
        for(let key in stats) {
            additiveStats[key] = [];
            multiplicitiveStats[key] = [];
        }
        for(let effect of calcArray) {
            effect.apply(stats, additiveStats, multiplicitiveStats);
        }
        let addedEffects = {};
        for(let key in additiveStats){
            for(let val of additiveStats[key]){ 
                if(addedEffects[key]){
                    addedEffects[key] += val - 1;
                } else {
                    addedEffects[key] = val - 1;
                }
            }
        }

        for(let key in addedEffects) {
            if( stats[key] ) {
                stats[key] *= ( 1 + addedEffects[key] );
            }
        }

        let multipliedUpgrades = {};        
        for(let key in multiplicitiveStats){
            for(let val of multiplicitiveStats[key]){ 
                if(stats[key]){
                    stats[key] *= val;
                }
            }
        }
    }
}

class GameState {
    constructor() {
        this.entities = [];
        this.reset();
    }

    reset() {
        this.bloodShards = 200;
        this.essence = 0;
        this.level = 1;
        this.essenceToNextLevel = 100;
        this.bloodCoreHP = 100;
        this.entities = [];

        this.enemies = [];
        this.towers = [];
        this.projectiles = [];
        this.summons = [];
        this.others = [];

        this.wave = 1;
        this.maxWaves = 10;
        this.waveTimer = 0;
        this.waveDelay = 300;
        this.enemiesInWave = 10;
        this.enemiesSpawned = 110;
        this.spawnRate = 60;
        this.spawnCounter = 0;
        this.isLevelingUp = false;
        this.isPaused = false;
        this.selectedTowerType = null;
        this.timeScale = 1;
        this.stats = {
            maxBloodCoreHP: 100,
            bloodShardMultiplier: 1,            
            towerCostMod: 1,
            damageMultiplier: 1,
            healingMultiplier: 1,
            essenceMultiplier: 1,
            towerDamageReduction: 1,
            population: 0,
            maxPopulation: 5
        }
        this.defaultStats = {...this.stats};
        this.gameOver = false;
        this.victory = false;
        this.activeUpgrades = {};
    }

    addEntity(entity) {
        this.entities.push(entity);
    }
    removeEntity(entity) {
       
        let index = this.entities.indexOf(entity);
        if( index >= 0 ) {
            this.entities.splice(index, 1);
        }
    }
    hasTowerType(type) {
        return this.towers.some((tower) => {
            return tower.type === type;
        });
    }
}

class MapManager {
    generateMap() {
        const tileMap = Array(CONFIG.ROWS).fill().map(() =>
            Array(CONFIG.COLS).fill().map(() => ({ type: 'grass', tower: null, buildable: true }))
        );
        const path = this.generatePath();
        path.forEach(p => {
            if (p.x >= 0 && p.x < CONFIG.COLS && p.y >= 0 && p.y < CONFIG.ROWS) {
                tileMap[p.y][p.x].type = 'path';
                tileMap[p.y][p.x].buildable = false;
            }
        });
        tileMap[path[path.length - 1].y][path[path.length - 1].x].type = 'base';
        return { tileMap, path };
    }

    generatePath() {        
        let startX = 0;
        let startY = parseInt(CONFIG.ROWS / 2);
        let endX = CONFIG.COLS - 1;
        let endY = startY; 
        let yMin = 0;
        let yMax = CONFIG.ROWS - 1;
        // Initialize the path with the start point
        let currentX = startX;
        let currentY = startY;
        const path = [{ x: currentX, y: currentY }];

        // Track the current direction (right, up, or down)
        let currentDirection = "right"; // Start by moving right

        // Generate the path
        while (currentX != endX || currentY != endY) {
            // Define possible moves based on the current direction
            let moves = [];
            if (currentDirection === "right") {
                // If moving right, prioritize continuing right or turning up/down
                moves = [
                    { dx: 1, dy: 0 }, // Right
                    { dx: 0, dy: 1 }, // Up
                    { dx: 0, dy: -1 }, // Down
                ];

                //only move toward exit when on last column.
                if( currentX == endX && currentY > endY ) {
                    moves.splice(1, 1); 
                } else if( currentX == endX && currentY < endY ) {
                    moves.splice(2, 1);
                } else if (currentX == startX ) {
                    moves.splice(1, 2);//always go right first
                }
            } else if (currentDirection === "up" || currentDirection === "down") {
                // If moving up or down, prioritize continuing in that direction or turning right
                moves = [
                    { dx: 1, dy: 0 }, // Right
                    { dx: 0, dy: currentDirection === "up" ? 1 : -1 }, // Continue up/down
                ];
            }

            // Filter valid moves (stay within grid bounds and avoid backtracking)
            const validMoves = moves.filter(({ dx, dy }) => {
                const nextX = currentX + dx;
                const nextY = currentY + dy;
                return (
                    nextX >= startX &&
                    nextX <= endX &&
                    nextY >= yMin &&
                    nextY <= yMax &&
                    !path.some(point => point.x === nextX && point.y === nextY) // Avoid revisiting points
                );
            });
            if (validMoves.length > 0) {
                // Randomly select a valid move
                const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];

                // Update the current direction
                if (randomMove.dx === 1) {
                    currentDirection = "right"; // Moving right
                } else if (randomMove.dy === 1) {
                    currentDirection = "up"; // Moving up
                } else if (randomMove.dy === -1) {
                    currentDirection = "down"; // Moving down
                }

                // Update the current position
                currentX += randomMove.dx;
                currentY += randomMove.dy;

                // Add the new point to the path
                path.push({ x: currentX, y: currentY });
            } else {
                // No valid moves left (should not happen if grid is properly sized)
                break;
            }
        }

        return path;
    }

}
class UIManager { 
    constructor() {
        this.upgradeMenu = document.getElementById('upgradeMenu');
        this.upgradeOptionsDiv = document.getElementById('upgradeOptions');
        this.overlay = document.getElementById('overlay');
        this.tooltip = document.getElementById('tooltip');
        this.gameOverMenu = document.getElementById('gameOverMenu');
        this.victoryMenu = document.getElementById('victoryMenu');

        // Stats displays
        this.shardsDisplay = document.getElementById('shardsDisplay');
        this.essenceDisplay = document.getElementById('essenceDisplay');
        this.essenceNeededDisplay = document.getElementById('essenceNeededDisplay');
        this.populationDisplay = document.getElementById('populationDisplay');
        this.maxPopulationDisplay = document.getElementById('maxPopulationDisplay');
        this.hpDisplay = document.getElementById('hpDisplay');
        this.waveDisplay = document.getElementById('waveDisplay');
        this.waveProgress = document.getElementById('waveProgress');
        this.gameOverWave = document.getElementById('gameOverWave');
        this.towerMenu = document.getElementById('towerMenu');
    }

    reset() {
        this.gameOverMenu.style.display = 'none';
        this.victoryMenu.style.display = 'none';
        this.overlay.style.display = 'none';
        this.waveDisplay.textContent = '1';
        this.waveProgress.style.width = '0%';        
        let towerMenuOptions = '';
        for(let type in towersConfig) {
            if(towersConfig[type].cost > 0){
                towerMenuOptions += `<div class="tower-option" data-type="${type}">${towersConfig[type].title} (${towersConfig[type].cost})</div>`;
            }
        }
        this.towerMenu.innerHTML = towerMenuOptions;

    }

    updateWaveDisplay(waveNumber) {
        this.waveDisplay.textContent = waveNumber;
    }
}
class ImageManager {
    constructor() {
        this.images = {};
    }

    loadImages(prefix, config) {
        for (const [type, cfg] of Object.entries(config)) {
            this.images[`${prefix}_${type}`] = this.createPlaceholder(cfg);
            // Later: this.images[type] = this.loadRealImage(cfg.src);
        }
    }

    createPlaceholder(config) {
        return this.createImage(config); // Reuse existing function
    }

    getImage(prefix, type) {
        return this.images[`${prefix}_${type}`];
    }
        
    createImage(config) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        
        if (config.render) {
            canvas.width = config.render.canvasWidth;
            canvas.height = config.render.canvasHeight;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            (config.render.shapes || []).forEach(shape => {
                ctx.save(); // Save current state
                ctx.translate(shape.x, shape.y); // Move origin to shape center
                ctx.rotate((shape.rotation || 0) * Math.PI / 180); // Rotate canvas

                ctx.fillStyle = shape.color;

                if (shape.type === 'circle') {
                    ctx.beginPath();
                    ctx.arc(0, 0, shape.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                } 
                else if (shape.type === 'square') {
                    ctx.fillRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size);
                } 
                else if (shape.type === 'rect') {
                    ctx.fillRect(-shape.width / 2, -shape.height / 2, shape.width, shape.height);
                } 
                else if (shape.type === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(0, -shape.size / 2);
                    ctx.lineTo(-shape.size / 2, shape.size / 2);
                    ctx.lineTo(shape.size / 2, shape.size / 2);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore(); // Restore original state
            });
        } else {
            canvas.width = config.size;
            canvas.height = config.size;
            ctx.fillStyle = config.color;
            if (config.isCircle) {
                ctx.beginPath();
                ctx.arc(config.size/2, config.size/2, config.size/2, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillRect(0, 0, config.size, config.size);
            }
        }
        return canvas;
    }
}
class ExplosionManager {
    constructor() {
        this.explosions = [];
    }

    add(x, y, radius) {
        this.explosions.push({ x, y, radius, currentRadius: 0, maxRadius: radius, alpha: 1 });
    }

    update() {
        this.explosions = this.explosions.filter(exp => {
            exp.currentRadius += exp.maxRadius * 0.1;
            exp.alpha -= 0.05;
            return exp.alpha > 0;
        });
    }
}

class Effect { 
    constructor(config, applyFn, amount) {
        this.id = config.id;
        this.title = config.title;
        this.desc = config.desc;
        this.lifeTime = config.lifeTime;
        this.applyFn = applyFn;
        this.amount = amount;    
    }

    update() {
        this.lifeTime--;
        if( this.lifeTime <= 0) return false;
        return true;        
    }

    apply(s, add, mul) {
        this.applyFn(s, add, mul, this.amount);
    }
}
class Upgrade { 
    constructor(id, title, desc, icon, appliesTo, condition, apply, onAcquire) {
        this.id = id;
        this.title = title;
        this.desc = desc;
        this.icon = icon;
        this.appliesTo = appliesTo;
        this.conditionFn = condition;
        this.applyFn = apply;
        this.onAcquire = onAcquire;        
    }

    canApply(gameState) {
        return this.conditionFn(gameState);
    }

    apply(s, add, mul) {
        this.applyFn(s, add, mul);
    }
}

class Component {
    constructor(game, parent) {
        this.game = game;
        this.parent = parent;
    }
    getComponent(type) {
        return this.parent.getComponent(type);
    }
    update() {}
    destroy() {}
}

class Renderer extends Component {
    constructor(game, parent, image) {
        super(game, parent);
        this.ctx = game.ctx;
        this.image = image;
    }

    draw() {        
        this.ctx.drawImage(this.image, this.parent.position.x - this.image.width / 2, this.parent.position.y - this.image.width / 2);
    }
}

class Leveler extends Component {
    constructor(game, parent, level = 1) {
        super(game, parent);
        this.level = level;
    }
}

class Explosion extends Component {
    constructor(game, parent, radius) {
        super(game, parent);
        this.maxRadius = radius;
        this.currentRadius = 0;
        this.alpha = 1;
    }

    update() {
        this.currentRadius += this.maxRadius * 0.1;
        this.alpha -= 0.05;
        if( this.alpha < 0 ) {
            this.parent.destroy();
        }
    }

    draw() {
        this.game.ctx.beginPath();
        this.game.ctx.arc(this.parent.position.x, this.parent.position.y, this.currentRadius, 0, Math.PI * 2);
        this.game.ctx.fillStyle = `rgba(255, 200, 0, ${this.alpha * 0.5})`;
        this.game.ctx.fill();

        this.game.ctx.beginPath();
        this.game.ctx.arc(this.parent.position.x, this.parent.position.y, this.currentRadius * 0.7, 0, Math.PI * 2);
        this.game.ctx.fillStyle = `rgba(255, 100, 0, ${this.alpha})`;
        this.game.ctx.fill();
    
    }
}

class LifeSpan extends Component {
    constructor(game, parent, lifeSpan) {
        super(game, parent);
        this.lifeSpan = lifeSpan;
    }
    update() {        
        if( this.lifeSpan > 0 ) {
            this.lifeSpan--;
        } else {
            this.parent.destroy();
        }
    }
}

class Buildable extends Component {
    constructor(game, parent) {
        super(game, parent);
        this.placed = false;
    }
}

class PopulationBurden extends Component {
    constructor(game, parent) {
        super(game, parent);
        this.stats = this.parent.getComponent('stats').stats;        
    }
    update() {
        if(this.stats){ 
            if( this.stats.population ) {
                this.game.state.stats.population += this.stats.population;
            } 
            if( this.stats.supply ) {
                this.game.state.stats.maxPopulation += this.stats.supply;
            }
        }
    }
}

class Attacker extends Component {
    constructor(game, parent) {
        super(game, parent);     
        this.stats = this.getComponent('stats').stats;    
        this.level = 1;
        this.target = null;
        this.projectiles = [];  
        this.cooldown = 0;
    }

    update() {

        if (this.cooldown > 0) this.cooldown--;
                
        // Find target if none
        if (!this.target || this.target.getComponent('health').hp <= 0 || Math.hypot(this.target.position.x - this.parent.position.x, this.target.position.y - this.parent.position.y) > this.stats.range) {
            this.findTarget();
        }
        
        // Attack if ready and has target
        if (this.cooldown <= 0 && this.target) {
            this.attack();
        }

        if( this.cooldown <= 0 && this.stats.mineAmt > 0 ){
            this.gather();
        }
        return true;
    }
    
    findTarget() {
        this.target = null;
        let furthestEnemy = null;
        let furthestDistance = -1;
        const nearbyEnemies = this.game.spatialGrid.getNearbyEntities(
            this.parent.position.x, 
            this.parent.position.y, 
            this.stats.range
        );
        for (let enemy of nearbyEnemies) {
            let enemyHP = enemy.getComponent('health').hp;
            let followPath = enemy.getComponent('followPath');
            if (enemyHP <= 0) continue;          

            // Target furthest enemy along path (closest to core)
            if (followPath.pathIndex > furthestDistance) {
                furthestDistance = followPath.pathIndex;
                furthestEnemy = enemy;
            }
            
        }
        
        this.target = furthestEnemy;
    }

    gather() {
        this.game.state.bloodShards += this.stats.mineAmt;
        this.cooldown = this.stats.attackSpeed;
    }

    attack() {
        if (!this.target) return; 
        this.launchProjectile();
        this.cooldown = this.stats.attackSpeed;
    }
    
    launchProjectile() {
        let damage = this.stats.damage * this.game.state.stats.damageMultiplier;
        let projectileType = this.stats.projectile;
        // Critical hit calculation
        const isCritical = Math.random() < this.stats.critChance;
        if (isCritical) {
            damage *= this.stats.critMultiplier;
        } 
        
        this.game.createProjectile(projectileType, this.parent.position.x, this.parent.position.y, this.target, damage, isCritical, this.parent);
                
    }

}

class Health extends Component { 
    constructor( game, parent ) {
        super(game, parent);        
        let statsComp = parent.getComponent('stats');
        this.hp = statsComp.stats.hp;
        statsComp.addStat('maxHp', this.hp);
    }
    update() {        
        if (this.hp <= 0){            
            this.parent.destroy();
        }
    }
}

class EssenceBounty extends Component { 
    constructor( game, parent ) {
        super(game, parent);        
        this.statsComp = parent.getComponent('stats');
    }
    destroy() {               
        this.game.state.essence += this.statsComp.stats.essence * this.game.state.stats.essenceMultiplier;        
    }
}

class SpacialGridEntity extends Component { 
    update() {
        this.game.spatialGrid.insert(this.parent);
    }
    destroy() {
        this.game.spatialGrid.remove(this.parent);
    }
}

class Stats extends Component { 
    constructor( game, parent, type, stats ) {
        super(game, parent);
        this.type = type;
        this.stats = {...stats};
        this.defaultStats = {...this.stats};
        this.activeEffects = {};
    }
    update() {
        this.stats = {...this.defaultStats};
        this.applyEffects();
        this.applyUpgrades();
    }
    addStat(statName, statValue) {
        this.stats[statName] = statValue;
        this.defaultStats[statName] = statValue;
    }
    addEffect(effectConfig, effectFn, effectAmt) {        
        this.activeEffects[effectConfig.id] = new Effect( effectConfig, effectFn, effectAmt );
    }
    applyEffects() {
        let effectArr = [];
        for(let effectId in this.activeEffects) {
            if(this.activeEffects[effectId] && this.activeEffects[effectId].update()){
                effectArr.push(this.activeEffects[effectId]);
            } else {
                this.activeEffects[effectId] = undefined;
            }
        }        
        
        calculateStats(this.stats, effectArr);
    }
    
    applyUpgrades() {
        calculateStats(this.stats, this.game.state.activeUpgrades[this.type]);        
    }
}

class FollowPath extends Component {
    constructor(game, parent, pathIndex = 0) {
        super(game, parent);
        this.pathIndex = pathIndex;
        this.x = this.game.state.path[this.pathIndex].x;
        this.y = this.game.state.path[this.pathIndex].y;
        this.parent.position = { x: this.x * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2, y: this.y * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2 };        
    }

    update() {
        this.stats = this.getComponent('stats').stats;
        if (this.pathIndex < this.game.state.path.length - 1) {
            const target = this.game.state.path[this.pathIndex + 1];
            const dx = target.x * CONFIG.GRID_SIZE + (CONFIG.GRID_SIZE / 2) - this.parent.position.x;
            const dy = target.y * CONFIG.GRID_SIZE + (CONFIG.GRID_SIZE / 2) - this.parent.position.y;
            const dist = Math.hypot(dx, dy);

            if (dist > this.stats.speed) {
                this.parent.position.x += (dx / dist) * this.stats.speed;
                this.parent.position.y += (dy / dist) * this.stats.speed;
            } else {
                this.pathIndex++;
            }
            this.x = parseInt(this.parent.position.x / CONFIG.GRID_SIZE);
            this.y = parseInt(this.parent.position.y / CONFIG.GRID_SIZE);
        } else {
            this.game.state.bloodCoreHP -= 10;
            this.parent.destroy();
            return false;
        }
    }
}

class Projectile extends Component {
    constructor(game, parent, type, owner, target, stats) {
        super(game, parent);
        this.type = type;
        this.owner = owner;
        this.target = target;
        this.stats = stats;
        this.piercedEnemies = [];
        this.ownerStats = this.owner.getComponent("stats").stats;
        
    }

    update() {
     
        // Remove if target is gone
        if (!this.target || this.target.destroyed) {
            this.parent.destroy();
        }
        // Move towards target
        const dx = this.target.position.x - this.parent.position.x;
        const dy = this.target.position.y - this.parent.position.y;
        const distSq = dx * dx + dy * dy;
        
        // Hit detection
        if (distSq < 15 * 15 ) {
            let targetHealth = this.target.getComponent("health");
            if (this.stats.splashRadius > 0) {
                const nearbyEnemies = this.game.spatialGrid.getNearbyEntities(
                    this.parent.position.x, 
                    this.parent.position.y, 
                    this.stats.splashRadius
                );
                // Process only relevant enemies
                for (const enemy of nearbyEnemies) {
                    if (enemy.isDead) continue;
                    let enemyHealth = enemy.getComponent("health");
                    let enemyStats = enemy.getComponent("stats");
                    const dx = enemy.position.x - this.target.position.x;
                    const dy = enemy.position.y - this.target.position.y;
                    const distSq1 = dx * dx + dy * dy;
                    
                    // Compare with squared splash radius for efficiency
                    const splashRadiusSq = this.stats.splashRadius * this.stats.splashRadius;
                    if (distSq1 <= splashRadiusSq) {
                        // Calculate actual distance only when needed
                        const splashDist = Math.sqrt(distSq1);
                        enemyHealth.hp -= (this.stats.damage * (1 - (splashDist / this.stats.splashRadius) * 0.5));                     

                        if( this.ownerStats.slowEffect ) {
                            enemyStats.addEffect(effectsConfig.slow, effects.slow, this.ownerStats.slowEffect);
                        }
                    }
                }
                let explosion = new Entity(this.game, this.parent.position.x, this.parent.position.y);
                explosion.addRenderer(Explosion, this.stats.splashRadius);
                this.game.state.addEntity(explosion);
            } else {
                // Apply damage
                targetHealth.hp -= this.stats.damage;

                if( this.ownerStats.slowEffect ) {
                    this.target.addEffect(effectsConfig.slow, effects.slow, this.ownerStats.slowEffect );
                }
            }

            //summon skeleton
            if (this.ownerStats.summonChance > 0 && 
                targetHealth.hp <= 0 && 
                Math.random() < this.ownerStats.summonChance - 1) {
                    this.game.createSummon(this.target.x, this.target.y, 'skeleton');
            }

            // Apply tower special effects
            if (this.ownerStats.leech > 0) {
                const healing = this.stats.damage * this.ownerStats.leech * this.game.state.stats.healingMultiplier;
                this.game.state.bloodCoreHP = Math.min(this.game.state.stats.maxBloodCoreHP, this.game.state.bloodCoreHP + healing);
            }
            if (this.ownerStats.thief && this.ownerStats.thief != 0) {
                const stealAmt = this.stats.damage * this.ownerStats.thief * this.game.state.stats.bloodShardMultiplier;
                this.game.state.bloodShards += stealAmt;
            }
            // Piercing logic
            if (this.stats.piercing > 0 && this.piercedEnemies.length < this.stats.piercing) {
                this.piercedEnemies.push(this.target);
                const nearbyEnemies = this.game.spatialGrid.getNearbyEntities(
                    this.parent.position.x, 
                    this.parent.position.y, 
                    this.stats.range
                );
                // Find a new target
                let newTarget = null;
                for (let enemy of nearbyEnemies) {
                    if (!enemy.isDead && !this.piercedEnemies.includes(enemy)) {
                        const dx = enemy.position.x - this.parent.position.x;
                        const dy = enemy.position.y - this.parent.position.y;
                        const distSq2 = dx * dx + dy * dy;
                        if (distSq2 < this.ownerStats.range * this.ownerStats.range) {
                            newTarget = enemy;
                            break;
                        }
                    }
                }
                
                if (newTarget) {
                    this.target = newTarget;   
                    return;                 
                } 
            }
            
            this.parent.destroy();
        }
        
        // Move projectile
        let dist = Math.sqrt(distSq);
        const speed = this.stats.speed * this.game.state.timeScale;
        this.parent.position.x += (dx / dist) * speed;
        this.parent.position.y += (dy / dist) * speed;
    }
}

class SpatialGrid {
    constructor(worldWidth, worldHeight, cellSize) {
        this.cellSize = cellSize;
        this.cols = Math.ceil(worldWidth / cellSize);
        this.rows = Math.ceil(worldHeight / cellSize);
        this.grid = new Array(this.cols * this.rows).fill().map(() => []);
        
        // Track which cell each entity is in
        this.entityCells = new Map(); // Map of entity -> cell index
    }
    
    getIndex(x, y) {
        // Clamp coordinates to world boundaries
        const clampedX = Math.max(0, Math.min(x, this.cols * this.cellSize - 1));
        const clampedY = Math.max(0, Math.min(y, this.rows * this.cellSize - 1));
        
        const col = Math.floor(clampedX / this.cellSize);
        const row = Math.floor(clampedY / this.cellSize);
        return row * this.cols + col;
    }

    insert(entity) {
        const newIndex = this.getIndex(entity.position.x, entity.position.y);
        const oldIndex = this.entityCells.get(entity);
        
        // If entity moved to a new cell
        if (oldIndex !== newIndex) {
            // Remove from old cell if it exists
            if (oldIndex !== undefined) {
                const oldCell = this.grid[oldIndex];
                const entityIndex = oldCell.indexOf(entity);
                if (entityIndex !== -1) {
                    oldCell.splice(entityIndex, 1);
                }
            }
            
            // Add to new cell
            if (newIndex >= 0 && newIndex < this.grid.length) {
                this.grid[newIndex].push(entity);
                this.entityCells.set(entity, newIndex);
            }
        }
    }
    
    remove(entity) {
        const index = this.entityCells.get(entity);
        if (index !== undefined) {
            const cell = this.grid[index];
            const entityIndex = cell.indexOf(entity);
            if (entityIndex !== -1) {
                cell.splice(entityIndex, 1);
            }
            this.entityCells.delete(entity);
        }
    }
    
    getNearbyEntities(x, y, radius) {
        const nearby = [];
        
        // Get cells that could contain entities within radius
        const startCol = Math.max(0, Math.floor((x - radius) / this.cellSize));
        const endCol = Math.min(this.cols - 1, Math.floor((x + radius) / this.cellSize));
        const startRow = Math.max(0, Math.floor((y - radius) / this.cellSize));
        const endRow = Math.min(this.rows - 1, Math.floor((y + radius) / this.cellSize));
        
        // Collect potential candidates from relevant cells
        for (let row = startRow; row <= endRow; row++) {
            for (let col = startCol; col <= endCol; col++) {
                const index = row * this.cols + col;
                if (index >= 0 && index < this.grid.length) {
                    this.grid[index].forEach(entity => nearby.push(entity));
                }
            }
        }
        
        return nearby;
    }
    
    clear() {
        this.grid = this.grid.map(() => []);
        this.entityCells.clear();
    }
    
    // Optional: Only clear but maintain all entity positions
    // Useful for when reusing the same grid across updates
    resetKeepingEntities() {
        const allEntities = [];
        this.entityCells.forEach((_, entity) => {
            allEntities.push(entity);
        });
        
        this.clear();
        
        allEntities.forEach(entity => {
            this.insert(entity);
        });
    }
}


class ArrayTracker extends Component {
    constructor(game, parent, arr) {
        super(game, parent);
        this.arr = arr;
        this.game.state[this.arr].push(this.parent);
    }

    destroy(){
        let index = this.game.state[this.arr].indexOf(this.parent);
        this.game.state[this.arr].splice(index, 1);        
    }
}    
 
class Entity {
    constructor(game, x, y) {
        this.game = game;
        this.position = { x: x, y: y };
        this.components = [];
        this.destroyed = false;        
        this.id = ++game.entityId;
    }

    getComponent(name) {
        return this.components[name.toLowerCase()];
    }
    addRenderer(ComponentClass, ...params) {
        this.renderer = this.addComponent(ComponentClass, ...params);
        return this.renderer;
    }
    addComponent(ComponentClass, ...params) {
        const component = new ComponentClass(this.game, this, ...params);
        this.components[ComponentClass.name.toLowerCase()] = component;
        return component;
    }
    removeComponent(component) {
        let index = this.components.indexOf(component);
        if( index >= 0 ) {
            this.components.splice(index, 1);
        }
    }
    update() {   
  
        for(let c in this.components) {
            this.components[c].update();   
            if(this.destroyed) break;
        }
        return !this.destroyed;
    }
    draw() {
        if( this.renderer ) {
            this.renderer.draw();
        }
    }
    destroy() {
        this.destroyed = true;
        for(let c in this.components) {
            this.components[c].destroy();   
        }
    }
}

const projectilesConfig = {
    prismShard: { render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"circle","x":32,"y":32,"size":16,"color":"#ffffff"},{"type":"circle","x":32,"y":28,"size":10,"color":"#e0e0ff"},{"type":"circle","x":32,"y":36,"size":10,"color":"#e0e0ff"}]} },
    radiantBeam: { render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"rect","x":32,"y":32,"width":20,"height":6,"color":"#ffd700"},{"type":"rect","x":32,"y":30,"width":12,"height":4,"color":"#fffacd"}]} },
    celestialOrb: { render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"circle","x":32,"y":32,"size":16,"color":"#87ceeb"},{"type":"circle","x":32,"y":32,"size":10,"color":"#b0e0e6"},{"type":"circle","x":28,"y":28,"size":6,"color":"#e0ffff"}]} },
    starFragment: { render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"square","x":32,"y":32,"size":12,"color":"#f0e68c"},{"type":"circle","x":32,"y":24,"size":8,"color":"#fffacd"},{"type":"circle","x":32,"y":40,"size":8,"color":"#fffacd"}]} },
    shadowBane: { render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"circle","x":32,"y":32,"size":14,"color":"#ba55d3"},{"type":"circle","x":32,"y":28,"size":8,"color":"#dda0dd"},{"type":"circle","x":32,"y":36,"size":8,"color":"#dda0dd"}]} },
    solarFlare: { render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"circle","x":32,"y":32,"size":16,"color":"#ff4500"},{"type":"circle","x":32,"y":28,"size":12,"color":"#ff8c00"},{"type":"circle","x":32,"y":24,"size":8,"color":"#fffacd"}]} },
    etherMist: { render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"circle","x":32,"y":32,"size":20,"color":"#4682b4"},{"type":"circle","x":28,"y":28,"size":12,"color":"#87ceeb"},{"type":"circle","x":36,"y":36,"size":12,"color":"#87ceeb"}]} },
}; 
const towersConfig = {
    keep: { title: 'Citadel', mineAmt: 1, attackSpeed: 50, render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"circle","x":32,"y":32,"size":54,"color":"#37474F"},{"type":"circle","x":32,"y":32,"size":48,"color":"#455A64"},{"type":"rect","x":32,"y":32,"width":36,"height":36,"color":"#546E7A","rotation":45},{"type":"rect","x":32,"y":32,"width":30,"height":30,"color":"#607D8B","rotation":45},{"type":"rect","x":32,"y":20,"width":24,"height":32,"color":"#263238"},{"type":"rect","x":32,"y":14,"width":18,"height":20,"color":"#37474F"},{"type":"rect","x":32,"y":6,"width":12,"height":8,"color":"#455A64"},{"type":"circle","x":32,"y":32,"size":16,"color":"#1A237E"},{"type":"circle","x":32,"y":32,"size":12,"color":"#303F9F"},{"type":"circle","x":32,"y":32,"size":8,"color":"#3F51B5"},{"type":"rect","x":32,"y":52,"width":20,"height":6,"color":"#263238"},{"type":"triangle","x":26,"y":26,"size":8,"color":"#303F9F","rotation":0},{"type":"triangle","x":38,"y":26,"size":8,"color":"#303F9F","rotation":0},{"type":"triangle","x":26,"y":38,"size":8,"color":"#303F9F","rotation":180},{"type":"triangle","x":38,"y":38,"size":8,"color":"#303F9F","rotation":180},{"type":"circle","x":32,"y":4,"size":6,"color":"#7986CB"}]} },
    sentry: { title: 'Photon Sentry', info: 'Defensive attack sentry.', cost: 25, population: 1, range: 120, damage: 2, attackSpeed: 20, projectile: 'prismShard', critChance: 0.05, critMultiplier: 1.5, render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"circle","x":32,"y":32,"size":48,"color":"#444444"},{"type":"circle","x":32,"y":32,"size":30,"color":"#1e90ff"},{"type":"circle","x":32,"y":32,"size":46,"color":"#333333"},{"type":"circle","x":32,"y":32,"size":42,"color":"#444444"},{"type":"circle","x":20,"y":20,"size":8,"color":"#00bfff"},{"type":"circle","x":44,"y":20,"size":8,"color":"#00bfff"},{"type":"circle","x":20,"y":44,"size":8,"color":"#00bfff"},{"type":"circle","x":44,"y":44,"size":8,"color":"#00bfff"},{"type":"rect","x":32,"y":20,"width":10,"height":28,"color":"#555555"},{"type":"circle","x":32,"y":32,"size":16,"color":"#333333"},{"type":"circle","x":32,"y":8,"size":14,"color":"#00bfff"}]} },
    fusionCore: { title: 'Fusion Core', info: 'Creates additional energy every second.', cost: 50, population: 1, attackSpeed: 50, critMultiplier: 1, mineAmt: 1, render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"circle","x":32,"y":32,"size":48,"color":"#333344"},{"type":"circle","x":32,"y":32,"size":40,"color":"#222233"},{"type":"circle","x":32,"y":32,"size":30,"color":"#7a19ff"},{"type":"circle","x":32,"y":32,"size":20,"color":"#d11fff"},{"type":"circle","x":32,"y":32,"size":12,"color":"#ff00ff"},{"type":"circle","x":22,"y":22,"size":8,"color":"#00ffff","rotation":45},{"type":"circle","x":42,"y":22,"size":8,"color":"#00ffff","rotation":45},{"type":"circle","x":22,"y":42,"size":8,"color":"#00ffff","rotation":45},{"type":"circle","x":42,"y":42,"size":8,"color":"#00ffff","rotation":45},{"type":"square","x":32,"y":32,"size":36,"color":"rgba(122, 25, 255, 0.2)","rotation":45},{"type":"square","x":32,"y":32,"size":28,"color":"rgba(209, 31, 255, 0.2)","rotation":45},{"type":"triangle","x":32,"y":16,"size":10,"color":"#00ffff","rotation":0},{"type":"triangle","x":32,"y":48,"size":10,"color":"#00ffff","rotation":180},{"type":"triangle","x":16,"y":32,"size":10,"color":"#00ffff","rotation":270},{"type":"triangle","x":48,"y":32,"size":10,"color":"#00ffff","rotation":90}]} },
    barracks: { title: 'Barracks', info: 'Provides 5 additional max population.', cost: 100, attackSpeed: 1000, critChance: 0.1, critMultiplier: 2, supply: 5, render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"rect","x":32,"y":32,"width":50,"height":40,"color":"#303F9F"},{"type":"rect","x":32,"y":32,"width":46,"height":36,"color":"#3F51B5"},{"type":"rect","x":32,"y":20,"width":36,"height":10,"color":"#1A237E"},{"type":"rect","x":32,"y":44,"width":36,"height":10,"color":"#1A237E"},{"type":"rect","x":32,"y":32,"width":30,"height":20,"color":"#0D47A1"},{"type":"circle","x":32,"y":32,"size":16,"color":"#03A9F4"},{"type":"circle","x":32,"y":32,"size":10,"color":"#00BCD4"},{"type":"rect","x":32,"y":52,"width":24,"height":6,"color":"#4FC3F7"},{"type":"rect","x":20,"y":30,"width":6,"height":14,"color":"#4FC3F7"},{"type":"rect","x":44,"y":30,"width":6,"height":14,"color":"#4FC3F7"},{"type":"triangle","x":22,"y":22,"size":8,"color":"#00BCD4","rotation":0},{"type":"triangle","x":42,"y":22,"size":8,"color":"#00BCD4","rotation":0},{"type":"square","x":32,"y":32,"size":28,"color":"rgba(33, 150, 243, 0.2)","rotation":45},{"type":"rect","x":32,"y":10,"width":8,"height":4,"color":"#F44336"}]} },
    fabricator: { title: 'Fabricator', info: 'Can be upgraded to summon drones from defeated enemies.', cost: 200, population: 4, range: 150, damage: 8, attackSpeed: 30, projectile: 'celestialOrb', piercing: 1, critChance: 0.15, critMultiplier: 1.8, render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"circle","x":32,"y":32,"size":48,"color":"#455A64"},{"type":"circle","x":32,"y":32,"size":40,"color":"#37474F"},{"type":"circle","x":32,"y":32,"size":32,"color":"#263238"},{"type":"circle","x":32,"y":32,"size":24,"color":"#00E676"},{"type":"circle","x":32,"y":32,"size":16,"color":"#00C853"},{"type":"square","x":32,"y":32,"size":32,"color":"rgba(0, 230, 118, 0.2)","rotation":45},{"type":"circle","x":20,"y":20,"size":6,"color":"#18FFFF"},{"type":"circle","x":44,"y":20,"size":6,"color":"#18FFFF"},{"type":"circle","x":20,"y":44,"size":6,"color":"#18FFFF"},{"type":"circle","x":44,"y":44,"size":6,"color":"#18FFFF"},{"type":"rect","x":32,"y":15,"width":20,"height":5,"color":"#607D8B"},{"type":"rect","x":32,"y":49,"width":20,"height":5,"color":"#607D8B"},{"type":"rect","x":15,"y":32,"width":5,"height":20,"color":"#607D8B"},{"type":"rect","x":49,"y":32,"width":5,"height":20,"color":"#607D8B"},{"type":"circle","x":32,"y":32,"size":8,"color":"#B2FF59"},{"type":"circle","x":32,"y":32,"size":4,"color":"#EEFF41"}]} },
    drone: { title: 'Drone', info: 'Raise the dead.', population: 1, range: 80, damage: 5, attackSpeed: 30, projectile: 'starFragment', critMultiplier: 1, lifeSpan: 500, render: {"canvasWidth":32,"canvasHeight":32,"shapes":[{"type":"circle","x":16,"y":16,"size":14,"color":"#263238"},{"type":"circle","x":16,"y":16,"size":10,"color":"#00E676"},{"type":"circle","x":16,"y":16,"size":6,"color":"#18FFFF"},{"type":"circle","x":16,"y":16,"size":3,"color":"#EEFF41"},{"type":"rect","x":16,"y":8,"width":2,"height":4,"color":"#607D8B"},{"type":"rect","x":16,"y":24,"width":2,"height":4,"color":"#607D8B"},{"type":"rect","x":8,"y":16,"width":4,"height":2,"color":"#607D8B"},{"type":"rect","x":24,"y":16,"width":4,"height":2,"color":"#607D8B"},{"type":"circle","x":16,"y":8,"size":3,"color":"#00C853"},{"type":"circle","x":16,"y":24,"size":3,"color":"#00C853"},{"type":"circle","x":8,"y":16,"size":3,"color":"#00C853"},{"type":"circle","x":24,"y":16,"size":3,"color":"#00C853"}]} },
    exoTrooper: { title: 'Exo Trooper', info: 'Projectiles chain between enemies.', cost: 70, population: 3, range: 100, damage: 10, attackSpeed: 25, projectile: 'shadowBane', piercing: 2, critChance: 0.1, critMultiplier: 1.7, render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"circle","x":32,"y":48,"size":36,"color":"#455A64"},{"type":"circle","x":32,"y":48,"size":30,"color":"#607D8B"},{"type":"rect","x":32,"y":32,"width":10,"height":32,"color":"#37474F"},{"type":"circle","x":32,"y":16,"size":16,"color":"#90A4AE"},{"type":"circle","x":32,"y":16,"size":12,"color":"#29B6F6"},{"type":"circle","x":32,"y":16,"size":8,"color":"#40C4FF"},{"type":"triangle","x":24,"y":12,"size":6,"color":"#81D4FA","rotation":270},{"type":"triangle","x":40,"y":12,"size":6,"color":"#81D4FA","rotation":90},{"type":"triangle","x":32,"y":8,"size":6,"color":"#81D4FA","rotation":0},{"type":"triangle","x":32,"y":24,"size":6,"color":"#81D4FA","rotation":180},{"type":"rect","x":32,"y":48,"width":24,"height":6,"color":"#263238"},{"type":"rect","x":32,"y":36,"width":20,"height":4,"color":"#546E7A"},{"type":"rect","x":32,"y":30,"width":16,"height":4,"color":"#546E7A"},{"type":"circle","x":32,"y":16,"size":4,"color":"#E1F5FE"}]} },
    neutronArc: { title: 'Neutron Arc', info: 'Projectiles explode in an AoE.', cost: 90, population: 3, range: 90, damage: 6, attackSpeed: 35, projectile: 'solarFlare', critChance: 0.05, critMultiplier: 2, splashRadius: 45, burnDamage: 2, render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"circle","x":32,"y":40,"size":40,"color":"#424242"},{"type":"circle","x":32,"y":40,"size":36,"color":"#616161"},{"type":"rect","x":32,"y":34,"width":24,"height":30,"color":"#37474F"},{"type":"rect","x":32,"y":27,"width":20,"height":18,"color":"#263238"},{"type":"rect","x":24,"y":20,"width":6,"height":16,"color":"#546E7A"},{"type":"rect","x":32,"y":20,"width":6,"height":16,"color":"#546E7A"},{"type":"rect","x":40,"y":20,"width":6,"height":16,"color":"#546E7A"},{"type":"triangle","x":24,"y":12,"size":6,"color":"#C62828","rotation":0},{"type":"triangle","x":32,"y":12,"size":6,"color":"#C62828","rotation":0},{"type":"triangle","x":40,"y":12,"size":6,"color":"#C62828","rotation":0},{"type":"rect","x":24,"y":16,"width":4,"height":2,"color":"#FFCDD2"},{"type":"rect","x":32,"y":16,"width":4,"height":2,"color":"#FFCDD2"},{"type":"rect","x":40,"y":16,"width":4,"height":2,"color":"#FFCDD2"},{"type":"rect","x":32,"y":46,"width":28,"height":8,"color":"#455A64"}]} },
    chrono: { title: 'Chrono Dampener', info: 'Projectiles explode in AoE and slow.', cost: 100, population: 3, range: 90, damage: 2, attackSpeed: 50, projectile: 'etherMist', critMultiplier: 1, splashRadius: 30, slowEffect: 0.7, render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"circle","x":32,"y":40,"size":40,"color":"#4A148C"},{"type":"circle","x":32,"y":40,"size":36,"color":"#6A1B9A"},{"type":"circle","x":32,"y":40,"size":26,"color":"#4A148C"},{"type":"circle","x":32,"y":40,"size":22,"color":"#9C27B0"},{"type":"circle","x":32,"y":40,"size":16,"color":"#AA00FF"},{"type":"rect","x":32,"y":24,"width":8,"height":24,"color":"#7B1FA2"},{"type":"circle","x":32,"y":16,"size":14,"color":"#CE93D8"},{"type":"circle","x":32,"y":16,"size":10,"color":"#E1BEE7"},{"type":"square","x":32,"y":16,"size":16,"color":"rgba(206, 147, 216, 0.5)","rotation":45},{"type":"square","x":32,"y":16,"size":20,"color":"rgba(206, 147, 216, 0.3)","rotation":45},{"type":"circle","x":32,"y":40,"size":14,"color":"#4A148C","rotation":45},{"type":"circle","x":25,"y":30,"size":6,"color":"#E040FB"},{"type":"circle","x":39,"y":30,"size":6,"color":"#E040FB"},{"type":"rect","x":32,"y":48,"width":28,"height":6,"color":"#4527A0"}]} },
};
const enemiesConfig = {
    zombie: { color: '#646464', size: 40, hp: 30, speed: 0.8, value: 5, essence: 10, isCircle: true, render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"circle","x":32,"y":32,"size":34,"color":"#6A1B9A"},{"type":"circle","x":32,"y":32,"size":24,"color":"#9C27B0"},{"type":"circle","x":32,"y":32,"size":16,"color":"#8E24AA"},{"type":"circle","x":32,"y":24,"size":12,"color":"#7B1FA2"},{"type":"circle","x":26,"y":26,"size":10,"color":"#7B1FA2"},{"type":"circle","x":38,"y":26,"size":10,"color":"#7B1FA2"},{"type":"circle","x":26,"y":28,"size":6,"color":"#F50057"},{"type":"circle","x":38,"y":28,"size":6,"color":"#F50057"},{"type":"triangle","x":21,"y":34,"size":10,"color":"#9C27B0","rotation":270},{"type":"triangle","x":43,"y":34,"size":10,"color":"#9C27B0","rotation":90},{"type":"triangle","x":28,"y":48,"size":8,"color":"#9C27B0","rotation":180},{"type":"triangle","x":36,"y":48,"size":8,"color":"#9C27B0","rotation":180}]} },
    skeleton: { color: '#e5e4cf', size: 28, hp: 20, speed: 1.2, value: 7, essence: 12, isCircle: true, render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"rect","x":32,"y":32,"width":30,"height":40,"color":"#2E7D32","rotation":0},{"type":"triangle","x":32,"y":14,"size":24,"color":"#388E3C","rotation":0},{"type":"rect","x":20,"y":32,"width":16,"height":6,"color":"#43A047","rotation":0},{"type":"rect","x":44,"y":32,"width":16,"height":6,"color":"#43A047","rotation":0},{"type":"circle","x":24,"y":24,"size":12,"color":"#66BB6A"},{"type":"circle","x":40,"y":24,"size":12,"color":"#66BB6A"},{"type":"circle","x":24,"y":24,"size":8,"color":"#1B5E20"},{"type":"circle","x":40,"y":24,"size":8,"color":"#1B5E20"},{"type":"circle","x":24,"y":24,"size":4,"color":"#76FF03"},{"type":"circle","x":40,"y":24,"size":4,"color":"#76FF03"},{"type":"rect","x":32,"y":40,"width":20,"height":6,"color":"#2E7D32"},{"type":"triangle","x":32,"y":50,"size":16,"color":"#388E3C","rotation":180}]} },
    ghost: { color: '#f7f7f0', size: 30, hp: 15, speed: 1.5, value: 10, essence: 15, isCircle: true, render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"circle","x":32,"y":32,"size":30,"color":"#0D47A1"},{"type":"rect","x":32,"y":32,"width":36,"height":20,"color":"#1565C0"},{"type":"triangle","x":14,"y":32,"size":10,"color":"#1976D2","rotation":270},{"type":"triangle","x":50,"y":32,"size":10,"color":"#1976D2","rotation":90},{"type":"circle","x":32,"y":28,"size":14,"color":"#1E88E5"},{"type":"circle","x":32,"y":26,"size":8,"color":"#2196F3"},{"type":"circle","x":24,"y":30,"size":6,"color":"#90CAF9"},{"type":"circle","x":40,"y":30,"size":6,"color":"#90CAF9"},{"type":"circle","x":24,"y":30,"size":3,"color":"#E3F2FD"},{"type":"circle","x":40,"y":30,"size":3,"color":"#E3F2FD"},{"type":"triangle","x":32,"y":40,"size":12,"color":"#1565C0","rotation":180},{"type":"triangle","x":32,"y":44,"size":8,"color":"#0D47A1","rotation":180}]} },
    wraith: { color: '#2f2f2f', size: 32, hp: 25, speed: 1.8, value: 12, essence: 18, dodgeChance: 0.2, isCircle: true, render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"rect","x":32,"y":32,"width":34,"height":20,"color":"#B71C1C","rotation":0},{"type":"triangle","x":32,"y":20,"size":28,"color":"#C62828","rotation":0},{"type":"triangle","x":32,"y":44,"size":28,"color":"#C62828","rotation":180},{"type":"circle","x":22,"y":26,"size":10,"color":"#D32F2F"},{"type":"circle","x":42,"y":26,"size":10,"color":"#D32F2F"},{"type":"circle","x":22,"y":26,"size":6,"color":"#FFEB3B"},{"type":"circle","x":42,"y":26,"size":6,"color":"#FFEB3B"},{"type":"rect","x":32,"y":32,"width":12,"height":6,"color":"#D50000"},{"type":"rect","x":14,"y":32,"width":10,"height":4,"color":"#B71C1C","rotation":45},{"type":"rect","x":50,"y":32,"width":10,"height":4,"color":"#B71C1C","rotation":-45},{"type":"rect","x":32,"y":42,"width":18,"height":4,"color":"#EF5350"}]} },
    bloodBeast: { color: '#c93838', size: 40, hp: 50, speed: 0.6, value: 15, essence: 20, regen: 0.5, isCircle: true, render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"circle","x":32,"y":32,"size":28,"color":"#4A148C"},{"type":"circle","x":32,"y":32,"size":24,"color":"#6A1B9A"},{"type":"circle","x":32,"y":22,"size":12,"color":"#7B1FA2"},{"type":"circle","x":32,"y":24,"size":8,"color":"#9C27B0"},{"type":"rect","x":20,"y":36,"width":16,"height":4,"color":"#AB47BC","rotation":-30},{"type":"rect","x":44,"y":36,"width":16,"height":4,"color":"#AB47BC","rotation":30},{"type":"rect","x":24,"y":42,"width":14,"height":4,"color":"#AB47BC","rotation":-20},{"type":"rect","x":40,"y":42,"width":14,"height":4,"color":"#AB47BC","rotation":20},{"type":"rect","x":28,"y":46,"width":10,"height":4,"color":"#AB47BC","rotation":-10},{"type":"rect","x":36,"y":46,"width":10,"height":4,"color":"#AB47BC","rotation":10},{"type":"circle","x":26,"y":28,"size":6,"color":"#E1BEE7"},{"type":"circle","x":38,"y":28,"size":6,"color":"#E1BEE7"},{"type":"circle","x":26,"y":28,"size":3,"color":"#4A148C"},{"type":"circle","x":38,"y":28,"size":3,"color":"#4A148C"}]} },
    banshee: { color: '#b04785', size: 28, hp: 20, speed: 1.4, value: 8, essence: 14, screamDamage: 5, isCircle: true, render: {"canvasWidth":64,"canvasHeight":64,"shapes":[{"type":"square","x":32,"y":32,"size":30,"color":"#004D40","rotation":45},{"type":"circle","x":32,"y":32,"size":20,"color":"#00695C"},{"type":"circle","x":32,"y":32,"size":14,"color":"#00796B"},{"type":"circle","x":32,"y":32,"size":8,"color":"#009688"},{"type":"triangle","x":20,"y":20,"size":10,"color":"#00897B","rotation":315},{"type":"triangle","x":44,"y":20,"size":10,"color":"#00897B","rotation":45},{"type":"triangle","x":20,"y":44,"size":10,"color":"#00897B","rotation":225},{"type":"triangle","x":44,"y":44,"size":10,"color":"#00897B","rotation":135},{"type":"circle","x":26,"y":26,"size":6,"color":"#B2DFDB"},{"type":"circle","x":38,"y":26,"size":6,"color":"#B2DFDB"},{"type":"circle","x":26,"y":26,"size":3,"color":"#E0F2F1"},{"type":"circle","x":38,"y":26,"size":3,"color":"#E0F2F1"},{"type":"rect","x":32,"y":36,"width":10,"height":4,"color":"#004D40"}]} },
};
const upgradesConfig = {
    // Bat Swarm Upgrades
    sentryFrenzy: { desc: '+25% Attack Speed', value: .75 },
    sentryIntelligence: { desc: '+15% Damage and +10% Range', damage: 1.15, range: 1.1 },
    dematerializeSentry: { desc: 'Heal 0.5% Core HP per hit', leech: 0.005 },

    // Necromancer Upgrades
    necroSummon: { desc: '10% chance to raise a skeleton when killing an enemy', summonChance: 1.1 },
    necroMastery: { desc: '+20% Range and projectiles pierce one additional enemy', range: 1.2, piercing: 1 },

    // Shadow Turret Upgrades
    shadowPierce: { desc: 'Projectiles pierce 2 additional enemies', piercing: 2 },
    shadowReach: { desc: '+30% Range', range: 1.3 },
    shadowCrit: { desc: '+10% Critical Chance', critChance: 0.1 },

    // Soul Pyre Upgrades
    pyreBurn: { desc: '+50% Burn Damage', burnDamage: 1 },
    pyreBlaze: { desc: '+20% Damage and +10% Attack Speed', damage: 1.2, attackSpeed: 1.1 },
    pyreSoul: { desc: '+10% splash radius', splashRadius: 1.1 },

    // Mist Shrine Upgrades
    mistSlow: { desc: 'Slow effect increased by 20%', slowEffect: 0.8 },
    mistSpread: { desc: '+25% Range and +1 Piercing', range: 1.25, piercing: 1 },

    // Global Upgrades
    bloodEff: { desc: 'Towers cost 15% less Blood Shards', value: 0.85 },
    bloodCore: { desc: 'Increase max Core HP by 20% and heal 30 HP', maxHpMultiplier: 1.2, healAmount: 30 },
    bloodHarvest: { desc: 'Gain 25% more Blood Shards from enemies', value: 1.25 },
    essenceExtraction: { desc: 'Gain 25% more Essence from enemies', value: 1.25 },
    bloodFrenzy: { desc: 'All towers deal 20% more damage', damageMultiplier: 1.2 },
    bloodRegeneration: { desc: 'All healing effects are 25% more effective', healingMultiplier: 1.25 },
    essenceOverflow: { desc: 'Gain 10% more Essence when above 50% Core HP', value: 1.1 },
    darkResilience: { desc: 'Towers take 20% less damage from enemy abilities', towerDamageReduction: 0.8 }
};
const effectsConfig = {
    slow: { id: 'slow', title: 'Slow', desc: 'Target is slowed', stat: 'speed', lifeTime: 100 }
}

const effects = {
    slow: (stats, additiveStats, multiplicitiveStats, slowAmount) => {
        stats[effectsConfig.slow.stat] *= slowAmount;
    }
}

const upgrades = [
    // Bat Swarm Upgrades
    new Upgrade(
        'sentryFrenzy',
        'Sentry Frenzy',
        'Sentry Swarm: ' + upgradesConfig.sentryFrenzy.desc,
        '',
        'sentry',
        (state) => true,
        (stats, additiveStats, multiplicitiveStats) => {
            multiplicitiveStats['attackSpeed'].push(upgradesConfig.batFrenzy.value);
        }
    ),
    new Upgrade(
        'sentryIntelligence',
        'Sentry Intelligence',
        'Sentry Swarm: ' + upgradesConfig.batSwarm.desc,
        '',
        'sentry',
        (state) => true,
        (stats, additiveStats, multiplicitiveStats) => {            
            multiplicitiveStats['damage'].push(upgradesConfig.batSwarm.damage);
            multiplicitiveStats['range'].push(upgradesConfig.batSwarm.range);        
        }
    ),

    // Necromancer Upgrades
    new Upgrade(
        'necroSummon',
        'Raise Dead',
        'Necromancer: ' + upgradesConfig.necroSummon.desc,
        '',
        'necromancer',
        (state) => true,
        (stats, additiveStats, multiplicitiveStats) => {
            stats.summonChance = 1;
            additiveStats['summonChance'].push(upgradesConfig.necroSummon.summonChance);
        }
    ),

     // Shadow Turret Upgrades
    new Upgrade(
        'shadowReach',
        'Extended Darkness',
        'Shadow Turret: ' + upgradesConfig.shadowReach.desc,
        '',
        'shadowTurret',
        (state) => true,
        (stats, additiveStats, multiplicitiveStats) => {
            additiveStats['range'].push(upgradesConfig.shadowReach.range);
        }
    ),

    // Soul Pyre Upgrades
    new Upgrade(
        'pyreSoul',
        'Radiant Soul',
        'Soul Pyre: ' + upgradesConfig.pyreSoul.desc,
        '',
        'soulPyre',
        (state) => true,
        (stats, additiveStats, multiplicitiveStats) => {
            additiveStats['splashRadius'].push(upgradesConfig.pyreSoul.splashRadius);
        }
    ),

    // Mist Shrine Upgrades
    new Upgrade(
        'mistSlow',
        'Chilling Mist',
        'Mist Shrine: ' + upgradesConfig.mistSlow.desc,
        '',
        'mistShrine',
        (state) => true,
        (stats, additiveStats, multiplicitiveStats) => {
            multiplicitiveStats['slowEffect'].push(upgradesConfig.mistSlow.slowEffect);
        }
    ),
    // Global Upgrades
    new Upgrade(
        'homeReinforcement',
        'Reinforcement',
        upgradesConfig.bloodCore.desc,
        '',
        'global',
        (state) => true,
        (stats) => {
            stats.maxBloodCoreHP *= upgradesConfig.bloodCore.maxHpMultiplier;
        },
        (state) => {
            state.bloodCoreHP = Math.min(state.stats.maxBloodCoreHP, state.bloodCoreHP + upgradesConfig.bloodCore.healAmount);
        }
    ),
    new Upgrade(
        'essenceExtraction',
        'Essence Extraction',
        upgradesConfig.essenceExtraction.desc,
        '',
        'global',
        (state) => true,
        (stats) => {
            stats.essenceMultiplier *= upgradesConfig.essenceExtraction.value;
        }
    ),
    new Upgrade(
        'essenceOverflow',
        'Essence Overflow',
        upgradesConfig.essenceOverflow.desc,
        '',
        'global',
        (state) => state.bloodCoreHP > state.stats.maxBloodCoreHP / 2,
        (stats) => {
            stats.essenceMultiplier *= upgradesConfig.essenceOverflow.value;
        }
    ),

];


const enemyConstructors = {
    'zombie': class zombieEnemy extends Entity {
        constructor(state, image) {
            super(state, 'zombie', enemiesConfig.zombie, image );
        }
    },
    'skeleton': class skeletonEnemy extends Entity {
        constructor(state, image) {
            super(state, 'skeleton', enemiesConfig.skeleton, image );
        }
    },
    'ghost': class ghostEnemy extends Entity {
        constructor(state, image) {
            super(state, 'ghost', enemiesConfig.ghost, image);
        }
    },
    'wraith': class WraithEnemy extends Entity {
        constructor(state, image) {
            super(state, 'wraith', enemiesConfig.wraith, image);
        }
    },
    'bloodBeast': class BloodBeastEnemy extends Entity {
        constructor(state, image) {
            super(state, 'bloodBeast', enemiesConfig.bloodBeast, image);
        }
    },
    'banshee': class BansheeEnemy extends Entity {
        constructor(state, image) {
            super(state, 'banshee', enemiesConfig.banshee, image);
        }
    }
};
const towerConstructors = {
    'batSwarm': class BatSwarmTower extends Entity {
        constructor(state, x, y, image) {
            super(state, x, y, 'batSwarm', towersConfig.batSwarm, image );
        }
    },
    'miner': class MinerTower extends Entity {
        constructor(state, x, y, image) {
            super(state, x, y, 'miner', towersConfig.miner, image );
        }
    },
    'supplyDepot': class SupplyDepotTower extends Entity {
        constructor(state, x, y, image) {
            super(state, x, y, 'supplyDepot', towersConfig.supplyDepot, image );
        }
    },
    'necromancer': class NecromancerTower extends Entity {
        constructor(state, x, y, image) {
            super(state, x, y, 'necromancer', towersConfig.necromancer, image );
        }
    },
    'skeleton': class SkeletonTower extends Entity {
        constructor(state, x, y, image) {
            super(state, x, y, 'skeleton', towersConfig.skeleton, image );
        }
    },
    'shadowTurret': class ShadowTurretTower extends Entity {
        constructor(state, x, y, image) {
            super(state, x, y, 'shadowTurret', towersConfig.shadowTurret, image);
        }
    },
    'soulPyre': class SoulPyreTower extends Entity {
        constructor(state, x, y, image) {
            super(state, x, y, 'soulPyre', towersConfig.soulPyre, image);
        }
    },
    'mistShrine': class MistShrineTower extends Entity {
        constructor(state, x, y, image) {
            super(state, x, y, 'mistShrine', towersConfig.mistShrine, image);
        }
    }
};


class GameRenderer {
    constructor(game) {        
        this.game = game;

        this.ctx = game.canvas.getContext('2d');
        this.selectedTowerType = null;
        this.hoverCell = { x: -1, y: -1 };
        this.showRange = false;
    }

    clearScreen() {        
        this.ctx.clearRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
    }

    render(state, map) {
        this.clearScreen();
        this.drawMap(map.tileMap, map.path);    
    }

    drawMap(tileMap, path) {
        this.ctx.fillStyle = '#2b2b3d';
        this.ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

        for (let y = 0; y < CONFIG.ROWS; y++) {
            for (let x = 0; x < CONFIG.COLS; x++) {
                const tile = tileMap[y][x];
                this.ctx.fillStyle = tile.type === 'grass' ? '#4a7c59' : tile.type === 'path' ? '#9c826a' : '#3d88c8';
                this.ctx.fillRect(x * CONFIG.GRID_SIZE, y * CONFIG.GRID_SIZE, CONFIG.GRID_SIZE, CONFIG.GRID_SIZE);
                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.strokeRect(x * CONFIG.GRID_SIZE, y * CONFIG.GRID_SIZE, CONFIG.GRID_SIZE, CONFIG.GRID_SIZE);
            }
        }

        this.ctx.strokeStyle = '#ffd166';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(path[0].x * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2, path[0].y * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2);
        path.slice(1).forEach(p => this.ctx.lineTo(p.x * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2, p.y * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2));
        this.ctx.stroke();
    }

}

class Game {
    constructor() {
        this.state = new GameState();
        this.mapManager = new MapManager();
        this.uiManager = new UIManager();
        this.spatialGrid = new SpatialGrid(CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT, CONFIG.GRID_SIZE * 3);
        this.entityId = 0;

        this.canvas = document.getElementById("gameCanvas");
        this.ctx = this.canvas.getContext("2d");
        this.imageManager = new ImageManager();
        this.imageManager.loadImages('tower', towersConfig);
        this.imageManager.loadImages('enemy', enemiesConfig);
        this.imageManager.loadImages('projectile', projectilesConfig);

        this.canvas.setAttribute('width', CONFIG.CANVAS_WIDTH);
        this.canvas.setAttribute('height', CONFIG.CANVAS_HEIGHT);

        this.entitiesToAdd = [];
        this.renderer = new GameRenderer(this);
        this.uiManager.reset();
    }

    showUpgradeMenu() {
        if (this.state.isLevelingUp) return; // Prevent re-triggering
        
        this.state.isLevelingUp = true;
        this.state.isPaused = true;
        
        this.uiManager.upgradeMenu.style.display = 'block';
        this.uiManager.overlay.style.display = 'block';
        this.uiManager.upgradeOptionsDiv.innerHTML = '';
        
        // Filter upgrades based on conditions
        const availableUpgrades = upgrades.filter(upgrade => upgrade.canApply(this.state));
        

        
        // Choose 3 random upgrades
        const options = [];
        while (options.length < 3 && availableUpgrades.length > 0) {
            const index = Math.floor(Math.random() * availableUpgrades.length);
            options.push(availableUpgrades[index]);
            availableUpgrades.splice(index, 1);
        }
        
        // Create upgrade options
        options.forEach(upgrade => {
            const div = document.createElement('div');
            div.className = 'upgrade-option';
            div.innerHTML = `
                <div class="upgrade-icon">${upgrade.icon}</div>
                <div class="upgrade-desc">
                    <div class="upgrade-title">${upgrade.title}</div>
                    ${upgrade.desc}
                </div>
            `;
            div.onclick = () => this.selectUpgrade(upgrade);
            this.uiManager.upgradeOptionsDiv.appendChild(div);
        });
    }

    selectUpgrade(upgrade) {       
        // Add to active upgrades list if not already
        if (!this.state.activeUpgrades[upgrade.appliesTo]) {
            this.state.activeUpgrades[upgrade.appliesTo] = [upgrade];
        } else {
            this.state.activeUpgrades[upgrade.appliesTo].push(upgrade);
        }

        this.applyActiveUpgrades();
        if(upgrade.onAcquire) {
            upgrade.onAcquire(this.state);
        }
        
        upgradeMenu.style.display = 'none';
        overlay.style.display = 'none';
        
        this.state.essence -= this.state.essenceToNextLevel;
        this.state.level++;
        this.state.essenceToNextLevel = Math.floor(this.state.essenceToNextLevel * 1.4);        
        
        this.state.isLevelingUp = false;
        this.state.isPaused = false;
    }


    // Wave management
    updateWave() {
        // Spawn enemies
        if (this.state.enemiesSpawned < this.state.enemiesInWave) {
            this.state.spawnCounter++;
            
            if (this.state.spawnCounter >= this.state.spawnRate) {
                this.createEnemy();
                this.state.enemiesSpawned++;
                this.state.spawnCounter = 0;
                
                // Update wave progress
                waveProgress.style.width = (this.state.enemiesSpawned / this.state.enemiesInWave * 100) + '%';
            }
        } 
        // Move to next wave if all enemies defeated
        else if (this.state.enemies.length === 0 && this.state.enemiesSpawned >= this.state.enemiesInWave) {
            this.state.waveTimer++;
            
            if (this.state.waveTimer >= this.state.waveDelay) {
                this.startNextWave();
            }
        }
    }

    startNextWave() {
        this.state.wave++;
        waveDisplay.textContent = this.state.wave;
        
        // Check for victory
        if (this.state.wave > this.state.maxWaves) {
            this.gameVictory();
            return;
        }
        
        this.state.enemiesInWave = 10 * (this.state.wave * 2);
        this.state.enemiesSpawned = 0;
        this.state.spawnRate = Math.max(10, 60 - (this.state.wave * 3));
        this.state.spawnCounter = 0;
        this.state.waveTimer = 0;
        
        // Reset wave progress bar
        waveProgress.style.width = '0%';
    }

    applyActiveUpgrades() {
        this.state.stats = {...this.state.defaultStats};
        calculateStats(this.state.stats, this.state.activeUpgrades['global']);    
    }
  
    // Tower placement system
    setupTowerPlacement() {
        let endY = parseInt(CONFIG.ROWS / 2) * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2;
        let endX = (CONFIG.COLS - 1) * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2;

        const keep =  this.createTower(endX, endY, 'keep');
        keep.placed = true;
        const towerButtons = document.querySelectorAll('.tower-option');
        towerButtons.forEach(button => {
            button.addEventListener('click', () => {
                if( this.state.isPaused ) return;
                const type = button.getAttribute('data-type');
                let cost = towersConfig[type].cost;
                const finalCost = Math.floor(cost * this.state.stats.towerCostMod);
                
                let populationCost = towersConfig[type].population || 0;
                if (this.state.bloodShards >= finalCost && this.state.stats.population + populationCost <= this.state.stats.maxPopulation) {
                    this.state.selectedTowerType = type;
                    if(this.state.previewTower) {
                        this.state.previewTower.destroy();
                    }
                    this.state.previewTower = this.createPreviewTower(-100, -100, this.state.selectedTowerType, true);
                }
            });
            
            // Show tooltip with info
            button.addEventListener('mouseover', (e) => {
                const type = button.getAttribute('data-type');
                let info = towersConfig[type].info;
                
                this.showTooltip(e.clientX, e.clientY, info);
            });
            
            button.addEventListener('mouseout', () => {
                this.hideTooltip();
            });
        });
        
        this.canvas.addEventListener('mousemove', (e) => {
            if (!this.state.selectedTowerType) return;
            
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if(this.state.previewTower){
                this.state.previewTower.position.x = parseInt(x / CONFIG.GRID_SIZE) * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2;
                this.state.previewTower.position.y = parseInt(y / CONFIG.GRID_SIZE) * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2;
            }
            
            // Check if position is valid
            const isValidPosition = this.checkValidTowerPosition(x, y);
            this.canvas.style.cursor = isValidPosition ? 'pointer' : 'not-allowed';

            if (this.state.selectedTowerType) return;
            
            // Check if hovering over a tower
            let hoveredTower = null;
            for (const tower of this.state.towers) {
                const dist = Math.hypot(tower.x - x, tower.y - y);
                if (dist < 20) {
                    hoveredTower = tower;
                    break;
                }
            }
            
            if (hoveredTower) {
                // Show tower stats
                let info = `${hoveredTower.type} (Level ${hoveredTower.level})\n`;
                
                info += `Damage: ${Math.round(hoveredTower.stats.damage * this.state.stats.damageMultiplier * 10) / 10}\n`;
                info += `Attack Speed: ${Math.round(1000 / hoveredTower.stats.attackSpeed)} per sec\n`;
                info += `Range: ${hoveredTower.stats.range}\n`;
                info += `Crit Chance: ${Math.round(hoveredTower.stats.critChance * 100)}%\n`;
                
                if (hoveredTower.stats.leech > 0) {
                    info += `Life Leech: ${Math.round(hoveredTower.stats.leech * 100 * this.state.stats.healingMultiplier) / 100} HP per hit\n`;
                }
                
                if (hoveredTower.stats.piercing > 0) {
                    info += `Piercing: ${hoveredTower.stats.piercing} enemies\n`;
                }
                
                if (hoveredTower.stats.summonChance > 0) {
                    info += `Summon Chance: ${Math.round(hoveredTower.stats.summonChance * 100)}%\n`;
                }
                
                this.showTooltip(e.clientX, e.clientY, info);
                
                // Show range indicator
                hoveredTower.showRange = true;
            } else {
                this.hideTooltip();
                this.state.towers.forEach(t => t.showRange = false);
            }
        });

        this.canvas.addEventListener('mouseout', () => {
            this.hideTooltip();
        });
        this.canvas.addEventListener('click', (e) => {
            if (!this.state.selectedTowerType) return;
            
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (this.checkValidTowerPosition(x, y)) {
                // Create the tower
                let cost = towersConfig[this.state.selectedTowerType].cost;
                let populationCost = towersConfig[this.state.selectedTowerType].population || 0;
                
                const finalCost = Math.floor(cost * this.state.stats.towerCostMod);
                
                if (this.state.bloodShards >= finalCost && this.state.stats.population + populationCost <= this.state.stats.maxPopulation) {
                    let towerX = parseInt(x / CONFIG.GRID_SIZE) * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2;
                    let towerY = parseInt(y / CONFIG.GRID_SIZE) * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2;
                    const tower =  this.createTower(towerX, towerY, this.state.selectedTowerType);
                    tower.placed = true;
                    this.state.bloodShards -= finalCost;
                    this.state.previewTower.destroy();
                    this.state.previewTower = null;
                    // Clear selection
                    this.state.selectedTowerType = null;
                    this.canvas.style.cursor = 'default';
                }
            }
        });
        
        // Cancel tower placement with right click
        this.canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (this.state.selectedTowerType) {
                this.state.selectedTowerType = null;
                this.canvas.style.cursor = 'default';
            }
        });
    }

    checkValidTowerPosition(x, y) {
        // Check if too close to path
        for (let i = 0; i < this.state.path.length - 1; i++) {
            const p1 = this.state.path[i];
            const p2 = this.state.path[i + 1];
            
            // Calculate distance from point to line segment
            const distance = this.distToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
            if (distance < 30) return false;
        }
        
        // Check if too close to other towers
        for (const tower of this.state.towers) {
            const dist = Math.hypot(tower.x - x, tower.y - y);
            if (dist < 40) return false;
        }
                
        return true;
    }

    // Calculate distance from point to line segment (for path collision)
    distToSegment(x, y, x1, y1, x2, y2) {
        const A = x - x1;
        const B = y - y1;
        const C = x2 - x1;
        const D = y2 - y1;
        
        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        
        if (len_sq !== 0) param = dot / len_sq;
        
        let xx, yy;
        
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }
        
        const dx = x - xx;
        const dy = y - yy;
        
        return Math.sqrt(dx * dx + dy * dy);
    }

    // Game-over and reset functions
    gameOver() {
        this.state.gameOver = true;
        this.state.isPaused = true;
        gameOverWave.textContent = this.state.wave;
        gameOverMenu.style.display = 'block';
        overlay.style.display = 'block';
    }

    gameVictory() {
        this.state.victory = true;
        this.state.isPaused = true;
        victoryMenu.style.display = 'block';
        overlay.style.display = 'block';
    }

    // Tooltip system
    showTooltip(x, y, text) {
        tooltip.style.display = 'block';
        tooltip.style.left = (x + 10) + 'px';
        tooltip.style.top = (y + 10) + 'px';
        tooltip.textContent = text;
    }

    hideTooltip() {
        tooltip.style.display = 'none';
    }

    // Game Loop
    update() {
        if (this.state.gameOver || this.state.victory || this.state.isLevelingUp) return;
        
        this.applyActiveUpgrades();
        
        let entitiesToRemove = [];
        for( let i = this.state.entities.length - 1; i >= 0; i-- ) {
            let e = this.state.entities[i];
            let result = e.update();
            if( !result ) {               
                this.state.entities.splice(i, 1);
            }
            e.draw();
        }   

        this.entitiesToAdd.forEach((entity) => this.state.addEntity(entity));
        this.entitiesToAdd = [];
        // Update wave status
        this.updateWave();
        // Level Up check
        if (this.state.essence >= this.state.essenceToNextLevel && !this.state.isLevelingUp) {
            this.showUpgradeMenu();
        }
        
        // Game over check
        if (this.state.bloodCoreHP <= 0 && !this.state.gameOver) {
            this.gameOver();
        }      
    }

    // Draw function
    draw() {
                
        this.drawStats();  

        // Draw wave timer
        if (this.state.enemies.length === 0 && this.state.enemiesSpawned >= this.state.enemiesInWave && !this.state.victory) {
            const countdown = Math.ceil((this.state.waveDelay - this.state.waveTimer) / 60);
            this.ctx.fillStyle = 'white';
            this.ctx.font = '20px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(`Next Wave in ${countdown}...`, this.canvas.width / 2, 50);
        }
    }
    // Stats updating
    drawStats() {
        this.uiManager.shardsDisplay.textContent = Math.floor(this.state.bloodShards);
        this.uiManager.essenceDisplay.textContent = Math.floor(this.state.essence);
        this.uiManager.essenceNeededDisplay.textContent = Math.floor(this.state.essenceToNextLevel);
        this.uiManager.hpDisplay.textContent = Math.floor(this.state.bloodCoreHP);
        this.uiManager.populationDisplay.textContent = Math.floor(this.state.stats.population);
        this.uiManager.maxPopulationDisplay.textContent = Math.floor(this.state.stats.maxPopulation);     
    }
    // Drawing the path
    drawPath() {
        this.ctx.strokeStyle = 'rgba(100, 0, 0, 0.5)';
        this.ctx.lineWidth = 30;
        this.ctx.beginPath();
        this.ctx.moveTo(this.state.path[0].x, this.state.path[0].y);
        
        for (let i = 1; i < this.state.path.length; i++) {
            this.ctx.lineTo(this.state.path[i].x, this.state.path[i].y);
        }
        
        this.ctx.stroke();
        
        // Draw path borders
        this.ctx.strokeStyle = 'rgba(150, 0, 0, 0.7)';
        this.ctx.lineWidth = 2;
        
        this.ctx.beginPath();
        this.ctx.moveTo(this.state.path[0].x, this.state.path[0].y - 15);
        for (let i = 1; i < this.state.path.length; i++) {
            this.ctx.lineTo(this.state.path[i].x, this.state.path[i].y - 15);
        }
        this.ctx.stroke();
        
        this.ctx.beginPath();
        this.ctx.moveTo(this.state.path[0].x, this.state.path[0].y + 15);
        for (let i = 1; i < this.state.path.length; i++) {
            this.ctx.lineTo(this.state.path[i].x, this.state.this.state.path[i].y + 15);
        }
        this.ctx.stroke();
    }

    // Main Loop
    gameLoop() {
        this.renderer.render(this.state, { tileMap: this.state.tileMap, path: this.state.path });
        if (!this.state.isPaused) {
            this.update();
        } 
        this.draw();
    }

    addEntity(entity) {
        this.entitiesToAdd.push(entity);
    }
    // Initialize the game
    init() {
        const { tileMap, path } = this.mapManager.generateMap();
        this.state.tileMap = tileMap;
        this.state.path = path;
        this.reset();            
        game.gameInterval = setInterval(() => { game.gameLoop(); }, 10);
        this.state.isPaused = true;
        
        this.setupTowerPlacement();
        this.drawStats();
    }
    reset() { 
        this.state.reset();
        this.uiManager.reset();
    }
    createProjectile(type, x, y, target, damage, isCritical, owner) {
        let ownerStats = owner.getComponent('stats').stats;
        let stats = {            
            speed: 5,
            damage: damage,
            isCritical: isCritical,
            piercing: ownerStats.piercing || 0,
            splashRadius: ownerStats.splashRadius || 0
        };

        let entity = new Entity(this, x, y);
        entity.addRenderer(Renderer, this.imageManager.getImage("projectile", type));
        entity.addComponent(Stats, type, stats);
        entity.addComponent(Projectile, type, owner, target, stats );
        this.addEntity(entity);     
    }
    createTower(x, y, type) {
        let stats = towersConfig[type];
        let entity = new Entity(this, x, y);
        entity.addRenderer(Renderer, this.imageManager.getImage("tower", type));
        entity.addComponent(Stats, type, stats);
        entity.addComponent(Leveler);
        entity.addComponent(Buildable);
        entity.addComponent(PopulationBurden);
        entity.addComponent(Attacker);
        entity.addComponent(ArrayTracker, "towers");
        
        this.addEntity(entity);      
        return entity;  
    }
    createPreviewTower(x, y, type) {
        let stats = towersConfig[type];
        let entity = new Entity(this, x, y);
        entity.addRenderer(Renderer, this.imageManager.getImage("tower", type));
        entity.addComponent(Stats, type, stats);
        entity.addComponent(Buildable);
        
        this.addEntity(entity);        
        return entity;
    }
    removeSummon(summon) {
        this.state.removeEntity(summon);
    }
    createSummon(x, y, type, isPreview) {
        const TowerClass = towerConstructors[type];
        if (TowerClass) {
            const tower = new TowerClass(this.state, x, y, this.imageManager.getImage('tower', type));
            if(!isPreview) {
                this.addEntity(tower);
            }
            return tower;
        }
        throw new Error(`Unknown tower type: ${type}`);
    }
    createEnemy() {        
        let types = [];
        for(let type in enemiesConfig) {
            types.push(type);
        }
        let type = types[Math.floor(Math.random() * types.length)];
        let stats = enemiesConfig[type];
        let entity = new Entity(this, 0, 0);
        entity.addRenderer(Renderer, this.imageManager.getImage("enemy", type));
        entity.addComponent(Stats, type, stats);
        entity.addComponent(Health);
        entity.addComponent(EssenceBounty);
        entity.addComponent(FollowPath);
        entity.addComponent(SpacialGridEntity);
        entity.addComponent(ArrayTracker, "enemies");
        this.addEntity(entity);
    }
    applyUpgrade(upgradeId) {
        const upgrade = upgrades.find(u => u.id === upgradeId);
        if (upgrade && upgrade.canApply(this.state)) {
            upgrade.apply(this.state);
            this.uiManager.updateUpgrades(); // Hypothetical UI update
        }
    }
}

const game = new Game();  
function main() {  
    game.init();
    document.getElementById('startGameBtn').addEventListener('click', (e) => {    
        game.state.isPaused = false;
        e.target.setAttribute('style','display:none;');
    });
}

function resetGame() {
    game.reset();
}

window.onload = main; // Or attach to a start button
</script>
	
	
</body>

</html>