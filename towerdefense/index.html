<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600;700&family=Cinzel:wght@500;700&display=swap" rel="stylesheet">
    <style>

:root {
    /* Solid hex colors */
    --primary-dark: #0f2418;      /* Deep forest green */
    --primary-bg: #1a3526;        /* Dark moss green */
    --secondary-bg: #224031;      /* Muted pine green */
    --accent-color: #4a7c59;      /* Fresh green (main accent) - matches grass */
    --bright-accent: #5a9e6f;     /* Lighter, vibrant green */
    --highlight-color: #6abe54;   /* Soft green highlight - matches necroOrb */
    --shadow-color: #3a443c;      /* Darker green for shadows */
    --text-color: #f7f7f0;        /* Off-white for readability - matches our palette */
    --gold-color: #e3d163;        /* Warm gold - matches goldMine inner */
    --essence-color: #7047a3;     /* Purple for essence - matches necromancer color */
    --health-color: #4a7c59;      /* Forest green - matches grass */
    
    /* Opacity variables for use with solid colors */
    --semi-transparent: 0.6;
    --high-transparent: 0.8;
    --very-high-transparent: 0.95;
    --low-transparent: 0.3;
    --overlay-transparent: 0.75;
    --hover-transparent: 0.9;
    --full-transparent: 0.98;
    --near-full-transparent: 0.99;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    margin: 0;
    padding: 0;
    background-color: var(--primary-dark);
    background-image: radial-gradient(circle at center, var(--primary-bg) 0%, var(--primary-dark) 100%);
    color: var(--text-color);
    font-family: 'Crimson Pro', serif;
    overflow: hidden;
    line-height: 1.6;
}

#gameContainer {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 1.5rem;
}

canvas { 
    border: 2px solid var(--accent-color);
    box-shadow: 0 0 30px var(--shadow-color);
    background-color: var(--secondary-bg);
    max-width: 90%;
    border-radius: 8px;
    transition: transform 0.3s ease;
}

#towerMenu {
    width: 800px;
    max-width: 90%;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    justify-content: center;
    padding: 15px;
    background: var(--primary-dark);
    border-radius: 10px;
    border: 1px solid var(--accent-color);
    border-opacity: var(--low-transparent); /* Note: This won't work directly; see below */
    backdrop-filter: blur(5px);
}

.tower-option {
    padding: 8px 14px;
    background: linear-gradient(to bottom, var(--accent-color), var(--secondary-bg));
    opacity: var(--high-transparent);
    border: 1px solid var(--accent-color);
    color: var(--text-color);
    cursor: pointer;
    transition: all 0.3s;
    border-radius: 6px;
    min-width: 110px;
    text-align: center;
    font-family: 'Cinzel', serif;
    font-weight: 500;
    letter-spacing: 0.5px;
    text-shadow: 0 1px 3px #000; /* Black shadow, no rgba */
    box-shadow: 0 3px 6px #000;   /* Black shadow, no rgba */
}

.tower-option:hover { 
    background: linear-gradient(to bottom, var(--bright-accent), var(--accent-color));
    opacity: var(--hover-transparent);
    transform: translateY(-3px);
    box-shadow: 0 6px 12px #000;
}

.tower-option:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px #000;
}

#statsContainer {
    width: 800px;
    max-width: 90%;
    padding: 12px;
    background: var(--primary-dark);
    border-radius: 10px;
    border: 1px solid var(--accent-color);
    border-opacity: var(--low-transparent); /* Note: This won't work directly; see below */
    backdrop-filter: blur(5px);
}

#stats {
    display: flex;
    justify-content: space-around;
    gap: 20px;
    flex-wrap: wrap;
}

.stat {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 1.1rem;
}

.stat-icon {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    box-shadow: 0 0 8px #000;
    display: flex;
    justify-content: center;
    align-items: center;
}

#upgradeMenu { 
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(to bottom, var(--secondary-bg), var(--primary-dark));
    opacity: var(--very-high-transparent);
    color: var(--text-color);
    padding: 25px;
    border-radius: 12px;
    border: 2px solid var(--accent-color);
    display: none;
    z-index: 10;
    width: 450px;
    box-shadow: 0 0 40px var(--shadow-color);
    backdrop-filter: blur(10px);
}

#upgradeMenu h2 {
    text-align: center;
    color: var(--highlight-color);
    margin-top: 0;
    border-bottom: 1px solid var(--accent-color);
    padding-bottom: 15px;
    font-family: 'Cinzel', serif;
    letter-spacing: 1px;
    font-weight: 700;
}

.upgrade-option { 
    margin: 18px 0;
    padding: 18px;
    background: linear-gradient(to right, var(--secondary-bg), var(--primary-bg));
    opacity: var(--high-transparent);
    cursor: pointer;
    border-radius: 8px;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    border: 1px solid var(--accent-color);
    border-opacity: var(--low-transparent); /* Note: This won't work directly; see below */
    box-shadow: 0 4px 8px #000;
}

.upgrade-option:hover { 
    background: linear-gradient(to right, var(--accent-color), var(--bright-accent));
    opacity: var(--hover-transparent);
    transform: translateX(8px);
    box-shadow: 0 6px 12px #000;
}

.upgrade-icon {
    width: 48px;
    height: 48px;
    margin-right: 18px;
    background: linear-gradient(135deg, var(--accent-color), var(--secondary-bg));
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 22px;
    box-shadow: 0 3px 6px #000;
}

.upgrade-desc {
    flex-grow: 1;
}

.upgrade-title {
    font-weight: bold;
    margin-bottom: 6px;
    color: var(--highlight-color);
    font-size: 1.2rem;
    font-family: 'Cinzel', serif;
}

#overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #000;
    opacity: var(--overlay-transparent);
    display: none;
    z-index: 5;
    backdrop-filter: blur(3px);
}

#waveInfo {
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(to right, var(--secondary-bg), var(--primary-bg));
    opacity: var(--high-transparent);
    padding: 8px 20px;
    border-radius: 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    box-shadow: 0 4px 12px #000;
    border: 1px solid var(--accent-color);
    border-opacity: var(--low-transparent); /* Note: This won't work directly; see below */
    backdrop-filter: blur(5px);
}

#waveDisplay {
    font-weight: bold;
    color: var(--highlight-color);
}

.progress-bar {
    width: 220px;
    height: 12px;
    background: var(--primary-dark);
    border-radius: 6px;
    overflow: hidden;
    box-shadow: inset 0 1px 3px #000;
    border: 1px solid var(--accent-color);
    border-opacity: var(--low-transparent); /* Note: This won't work directly; see below */
}

.progress-fill {
    height: 100%;
    background: linear-gradient(to right, var(--accent-color), var(--highlight-color));
    width: 0%;
    box-shadow: 0 0 8px var(--shadow-color);
    transition: width 0.3s ease;
}

#startGameBtn {
    padding: 12px 35px;
    background: linear-gradient(to bottom, var(--bright-accent), var(--accent-color));
    color: white;
    border: none;
    border-radius: 30px;
    cursor: pointer;
    font-family: 'Cinzel', serif;
    font-weight: 500;
    font-size: 1.2rem;
    transition: all 0.3s;
    box-shadow: 0 6px 12px #000;
    text-shadow: 0 1px 2px #000;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 20;
}

#startGameBtn:hover {
    background: linear-gradient(to bottom, var(--highlight-color), var(--bright-accent));
    transform: translate(-50%, -50%) scale(1.05);
    box-shadow: 0 8px 16px #000;
}

#startGameBtn:active {
    transform: translate(-50%, -50%) scale(1);
    box-shadow: 0 4px 8px #000;
}

#tooltip {
    position: absolute;
    background: linear-gradient(to bottom, var(--primary-dark), var(--primary-dark));
    opacity: var(--very-high-transparent);
    color: var(--text-color);
    padding: 12px 15px;
    border-radius: 8px;
    display: none;
    z-index: 100;
    border: 1px solid var(--accent-color);
    pointer-events: none;
    max-width: 280px;
    box-shadow: 0 0 20px var(--shadow-color);
    font-size: 0.95rem;
    backdrop-filter: blur(5px);
}

#gameOverMenu, #victoryMenu {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(to bottom, var(--secondary-bg), var(--primary-dark));
    opacity: var(--full-transparent);
    color: white;
    padding: 40px;
    text-align: center;
    border-radius: 15px;
    border: 3px solid var(--accent-color);
    z-index: 20;
    display: none;
    box-shadow: 0 0 60px var(--shadow-color);
    backdrop-filter: blur(10px);
    min-width: 350px;
}

#gameOverMenu h2, #victoryMenu h2 {
    color: var(--highlight-color);
    font-size: 32px;
    margin-bottom: 20px;
    font-family: 'Cinzel', serif;
    text-shadow: 0 2px 4px #000;
}

#gameOverMenu p, #victoryMenu p {
    font-size: 18px;
    margin-bottom: 25px;
    line-height: 1.6;
}

.menu-button {
    margin-top: 25px;
    padding: 12px 25px;
    background: linear-gradient(to bottom, var(--bright-accent), var(--accent-color));
    border: none;
    color: white;
    cursor: pointer;
    border-radius: 8px;
    transition: all 0.3s;
    font-family: 'Cinzel', serif;
    font-size: 16px;
    letter-spacing: 1px;
    box-shadow: 0 4px 8px #000;
    text-shadow: 0 1px 2px #000;
}

.menu-button:hover {
    background: linear-gradient(to bottom, var(--highlight-color), var(--bright-accent));
    transform: scale(1.05) translateY(-3px);
    box-shadow: 0 6px 15px #000;
}

.menu-button:active {
    transform: scale(1) translateY(0);
    box-shadow: 0 3px 6px #000;
}

/* Stat icons with custom styling */
#shardsDisplay { color: var(--gold-color); font-weight: 600; }
#essenceDisplay, #essenceNeededDisplay { color: var(--essence-color); font-weight: 600; }
#populationDisplay, #maxPopulationDisplay { color: var(--essence-color); font-weight: 600; }
#hpDisplay { color: var(--health-color); font-weight: 600; }



#waveDisplay {
    display: inline-block;
}
    </style>
</head>
<body>
<div id="appContainer">
    <div id="gameContainer">
        <div id="waveInfo">
            <span>Wave: <span id="waveDisplay">1</span></span>
            <div class="progress-bar">
                <div class="progress-fill" id="waveProgress"></div>
            </div>
        </div>
        
        <div id="statsContainer">
            <div id="stats">
                <div class="stat">
                    <div class="stat-icon" style="background-color: var(--gold-color);"></div>
                    <span>Gold: <span id="shardsDisplay">50</span></span>
                </div>
                <div class="stat">
                    <div class="stat-icon" style="background-color: var(--essence-color);"></div>
                    <span>Essence: <span id="essenceDisplay">0</span>/<span id="essenceNeededDisplay">100</span></span>
                </div>
                <div class="stat">
                    <div class="stat-icon" style="background-color: var(--essence-color);"></div>
                    <span>Population: <span id="populationDisplay">0</span>/<span id="maxPopulationDisplay">5</span></span>
                </div>
                <div class="stat">
                    <div class="stat-icon" style="background-color: var(--health-color);"></div>
                    <span>Core: <span id="hpDisplay">100</span></span>
                </div>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="towerMenu">
            <div class="tower-option" data-type="shoot">Shoot (25)</div>
        </div>
        
        <button id="startGameBtn" style="display:none">Start Game</button>
    </div>
    
    <div id="overlay"></div>
    
    <div id="upgradeMenu">
        <h2>Level Up! Choose an Upgrade:</h2>
        <div id="upgradeOptions"></div>
    </div>
    
    <div id="tooltip"></div>
    
    <div id="gameOverMenu">
        <h2>Home Destroyed!</h2>
        <p>You survived <span id="gameOverWave">0</span> waves</p>
        <button class="menu-button"">Try Again</button>
    </div>
    
    <div id="victoryMenu">
        <h2>Victory!</h2>
        <p>You've successfully defended your Home through all waves!</p>
        <button class="menu-button">Play Again</button>
    </div>
</div>
<script type="module">
        
    import * as THREE from './three.module.min.js';
        
    const CONFIG = {
        GRID_SIZE: 48,
        CANVAS_WIDTH: 768,
        CANVAS_HEIGHT: 384,
        get ROWS() { return parseInt((this.CANVAS_HEIGHT * 2) / this.GRID_SIZE) },
        get COLS() { return parseInt(this.CANVAS_WIDTH / this.GRID_SIZE) }
    };

    function calculateStats(stats, calcArray) {

        if( calcArray && calcArray.length > 0 ) {
            let additiveStats = {};
            let multiplicitiveStats = {};
            for(let key in stats) {
                additiveStats[key] = [];
                multiplicitiveStats[key] = [];
            }
            for(let effect of calcArray) {
                effect.apply(stats, additiveStats, multiplicitiveStats);
            }
            let addedEffects = {};
            for(let key in additiveStats){
                for(let val of additiveStats[key]){ 
                    if(addedEffects[key]){
                        addedEffects[key] += val - 1;
                    } else {
                        addedEffects[key] = val - 1;
                    }
                }
            }

            for(let key in addedEffects) {
                if( stats[key] ) {
                    stats[key] *= ( 1 + addedEffects[key] );
                }
            }

            let multipliedUpgrades = {};        
            for(let key in multiplicitiveStats){
                for(let val of multiplicitiveStats[key]){ 
                    if(stats[key]){
                        stats[key] *= val;
                    }
                }
            }
        }
    }
    class CoordinateTranslator {
        constructor(config) {
            this.tileWidth = config.GRID_SIZE;
            this.tileHeight = config.GRID_SIZE * 0.5;
            this.canvasWidth = config.CANVAS_WIDTH;
            this.canvasHeight = config.CANVAS_HEIGHT;
        }

        // Pixel (top-down) to Grid
        pixelToGrid(pixelX, pixelY) {
            return {
                x: pixelX / this.tileWidth,
                y: pixelY / this.tileWidth
            };
        }

        // Grid to Isometric (exactly matches drawMap)
        gridToIso(gridX, gridY) {
            const isoX = (gridX - gridY) * (this.tileWidth / 2) + this.canvasWidth / 2;
            const isoY = (gridX + gridY) * (this.tileHeight / 2);
            return { x: isoX, y: isoY };
        }

        // Pixel (top-down) to Isometric
        pixelToIso(pixelX, pixelY) {
            const grid = this.pixelToGrid(pixelX, pixelY);
            return this.gridToIso(grid.x, grid.y);
        }

        isoToGrid(isoX, isoY) {
            const adjustedX = isoX - this.canvasWidth / 2;
            const adjustedY = isoY;
            const gridX = (adjustedX / (this.tileWidth / 2) + adjustedY / (this.tileHeight / 2)) / 2;
            const gridY = (adjustedY / (this.tileHeight / 2) - adjustedX / (this.tileWidth / 2)) / 2;
            return { x: gridX, y: gridY };
        }

        isoToPixel(isoX, isoY) {
            const grid = this.isoToGrid(isoX, isoY);
            return {
                x: grid.x * this.tileWidth,
                y: grid.y * this.tileWidth// Double y to match top-down pixel space
            };
        }

        // Snap grid coordinates to nearest integer
        snapToGrid(gridX, gridY) {
            return { x: Math.floor(gridX), y: Math.floor(gridY) };
        }
    }

    class GameState {
        constructor() {
            this.entities = [];
            this.reset();
        }

        reset() {            
            this.bloodShards = 200;
            this.essence = 0;
            this.level = 1;
            this.essenceToNextLevel = 100;
            this.bloodCoreHP = 100;
            this.entities = [];
            this.mousePosition = { x: 0, y: 0, isoX: 0, isoY: 0, gridX: 0, gridY: 0 };
            this.enemies = [];
            this.towers = [];
            this.projectiles = [];
            this.summons = [];
            this.others = [];

            this.wave = 1;
            this.maxWaves = 10;
            this.waveTimer = 0;
            this.waveDelay = 300;
            this.enemiesInWave = 10;
            this.enemiesSpawned = 110;
            this.spawnRate = 60;
            this.spawnCounter = 0;
            this.isLevelingUp = false;
            this.isPaused = false;
            this.selectedTowerType = null;
            this.timeScale = 1;
            this.stats = {
                maxBloodCoreHP: 100,
                bloodShardMultiplier: 1,            
                towerCostMod: 1,
                damageMultiplier: 1,
                healingMultiplier: 1,
                essenceMultiplier: 1,
                towerDamageReduction: 1,
                population: 0,
                maxPopulation: 5
            }
            this.defaultStats = {...this.stats};
            this.gameOver = false;
            this.victory = false;
            this.activeUpgrades = {};
        }

        addEntity(entity) {
            this.entities.push(entity);
        }
        removeEntity(entity) {
        
            let index = this.entities.indexOf(entity);
            if( index >= 0 ) {
                this.entities.splice(index, 1);
            }
        }
        hasTowerType(type) {
            return this.towers.some((tower) => {
                return tower.type === type;
            });
        }
    }

    class MapManager {
        generateMap() {
            const tileMap = Array(CONFIG.ROWS).fill().map(() =>
                Array(CONFIG.COLS).fill().map(() => ({ type: 'grass', tower: null, buildable: true }))
            );
            const path = this.generatePath();
            path.forEach(p => {
                if (p.x >= 0 && p.x < CONFIG.COLS && p.y >= 0 && p.y < CONFIG.ROWS) {
                    tileMap[p.y][p.x].type = 'path';
                    tileMap[p.y][p.x].buildable = false;
                }
            });
            tileMap[path[path.length - 1].y][path[path.length - 1].x].type = 'base';
            return { tileMap, path };
        }

        generatePath() {        
            let startX = 0;
            let startY = parseInt(CONFIG.ROWS / 2);
            let endX = CONFIG.COLS - 1;
            let endY = startY; 
            let yMin = 0;
            let yMax = CONFIG.ROWS - 1;
            // Initialize the path with the start point
            let currentX = startX;
            let currentY = startY;
            const path = [{ x: currentX, y: currentY }];

            // Track the current direction (right, up, or down)
            let currentDirection = "right"; // Start by moving right

            // Generate the path
            while (currentX != endX || currentY != endY) {
                // Define possible moves based on the current direction
                let moves = [];
                if (currentDirection === "right") {
                    // If moving right, prioritize continuing right or turning up/down
                    moves = [
                        { dx: 1, dy: 0 }, // Right
                        { dx: 0, dy: 1 }, // Up
                        { dx: 0, dy: -1 }, // Down
                    ];

                    //only move toward exit when on last column.
                    if( currentX == endX && currentY > endY ) {
                        moves.splice(1, 1); 
                    } else if( currentX == endX && currentY < endY ) {
                        moves.splice(2, 1);
                    } else if (currentX == startX ) {
                        moves.splice(1, 2);//always go right first
                    }
                } else if (currentDirection === "up" || currentDirection === "down") {
                    // If moving up or down, prioritize continuing in that direction or turning right
                    moves = [
                        { dx: 1, dy: 0 }, // Right
                        { dx: 0, dy: currentDirection === "up" ? 1 : -1 }, // Continue up/down
                    ];
                }

                // Filter valid moves (stay within grid bounds and avoid backtracking)
                const validMoves = moves.filter(({ dx, dy }) => {
                    const nextX = currentX + dx;
                    const nextY = currentY + dy;
                    return (
                        nextX >= startX &&
                        nextX <= endX &&
                        nextY >= yMin &&
                        nextY <= yMax &&
                        !path.some(point => point.x === nextX && point.y === nextY) // Avoid revisiting points
                    );
                });
                if (validMoves.length > 0) {
                    // Randomly select a valid move
                    const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];

                    // Update the current direction
                    if (randomMove.dx === 1) {
                        currentDirection = "right"; // Moving right
                    } else if (randomMove.dy === 1) {
                        currentDirection = "up"; // Moving up
                    } else if (randomMove.dy === -1) {
                        currentDirection = "down"; // Moving down
                    }

                    // Update the current position
                    currentX += randomMove.dx;
                    currentY += randomMove.dy;

                    // Add the new point to the path
                    path.push({ x: currentX, y: currentY });
                } else {
                    // No valid moves left (should not happen if grid is properly sized)
                    break;
                }
            }

            return path;
        }

    }
    class UIManager { 
        constructor() {
            this.upgradeMenu = document.getElementById('upgradeMenu');
            this.upgradeOptionsDiv = document.getElementById('upgradeOptions');
            this.overlay = document.getElementById('overlay');
            this.tooltip = document.getElementById('tooltip');
            this.gameOverMenu = document.getElementById('gameOverMenu');
            this.victoryMenu = document.getElementById('victoryMenu');

            // Stats displays
            this.shardsDisplay = document.getElementById('shardsDisplay');
            this.essenceDisplay = document.getElementById('essenceDisplay');
            this.essenceNeededDisplay = document.getElementById('essenceNeededDisplay');
            this.populationDisplay = document.getElementById('populationDisplay');
            this.maxPopulationDisplay = document.getElementById('maxPopulationDisplay');
            this.hpDisplay = document.getElementById('hpDisplay');
            this.waveDisplay = document.getElementById('waveDisplay');
            this.waveProgress = document.getElementById('waveProgress');
            this.gameOverWave = document.getElementById('gameOverWave');
            this.towerMenu = document.getElementById('towerMenu');
            let towerMenuOptions = '';
            for(let type in gameConfig.towers) {
                if(gameConfig.towers[type].cost > 0){
                    towerMenuOptions += `<div class="tower-option" data-type="${type}">${gameConfig.towers[type].title} (${gameConfig.towers[type].cost})</div>`;
                }
            }
            this.towerMenu.innerHTML = towerMenuOptions;
        }

        reset() {
            this.gameOverMenu.style.display = 'none';
            this.victoryMenu.style.display = 'none';
            this.overlay.style.display = 'none';
            this.waveDisplay.textContent = '1';
            this.waveProgress.style.width = '0%';        


        }

        updateWaveDisplay(waveNumber) {
            this.waveDisplay.textContent = waveNumber;
        }
    }
    class ImageManager {
        constructor() {
            this.images = {};
        }

        async loadImages(prefix, config) {
            for (const [type, cfg] of Object.entries(config)) {
                if(!cfg.render) continue;
                this.images[`${prefix}_${type}`] = await this.createPlaceholder(cfg);
                // Later: this.images[type] = this.loadRealImage(cfg.src);
            }
        }

        async createPlaceholder(config) {
            const images = await this.captureObjectImagesFromJSON(config);
            let canvases = [];
            images.forEach((img, index) => {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                canvases.push(canvas);
            });
            return canvases
        }

        getImages(prefix, type) {
            return this.images[`${prefix}_${type}`];
        }

        async captureObjectImagesFromJSON(shapeData) {
            const size = 64; // Image size
            const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.setSize(size, size);
            
            // Create an offscreen render target
            const renderTarget = new THREE.WebGLRenderTarget(size, size);
            renderTarget.texture.flipY = true; // Flip the texture vertically

            // Create scene and lights
            const scene = new THREE.Scene();
            const light = new THREE.AmbientLight(0xffffff, 5);
            scene.add(light);

            // Create objects from JSON and add to scene
            const objectGroup = this.createObjectsFromJSON(shapeData.render);
            scene.add(objectGroup);

            // Create 4 orthographic cameras (Front, Left, Right, Back)
            const frustumSize = 48;
            const cameraDistance = 64;
            const aspect = 1;
            const cameras = [
                new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000), // Front
                new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000), // Left
                new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000), // Right
                new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000)  // Back
            ];

            // Position each camera at different angles
            cameras[0].position.set(cameraDistance, cameraDistance, cameraDistance); // Front
            cameras[1].position.set(-cameraDistance, cameraDistance, cameraDistance); // Left
            cameras[2].position.set(cameraDistance, cameraDistance, -cameraDistance); // Right
            cameras[3].position.set(-cameraDistance, cameraDistance, -cameraDistance); // Back

            cameras.forEach(camera => camera.lookAt(0, 0, 0));

            // Capture images
            const images = [];
            for (const camera of cameras) {
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Read pixels from render target
                const buffer = new Uint8Array(size * size * 4);
                renderer.readRenderTargetPixels(renderTarget, 0, 0, size, size, buffer);

                // Flip the buffer vertically
                const flippedBuffer = new Uint8Array(size * size * 4);
                for (let y = 0; y < size; y++) {
                    const srcRowStart = y * size * 4;
                    const destRowStart = (size - 1 - y) * size * 4;
                    flippedBuffer.set(buffer.subarray(srcRowStart, srcRowStart + size * 4), destRowStart);
                }

                const imageData = new ImageData(new Uint8ClampedArray(flippedBuffer), size, size);
                const imageBitmap = await createImageBitmap(imageData);
                images.push(imageBitmap);
            }

            // Cleanup
            renderer.setRenderTarget(null);
            renderer.dispose();
            renderTarget.dispose();

            return images;
        }

        /**
         * Creates 3D objects from shape data.
         * @param {Object} shapeData - The JSON object containing shape definitions.
         * @returns {THREE.Group} - A group containing all 3D objects.
         */
        createObjectsFromJSON(shapeData) {
            const group = new THREE.Group(); // Group to hold all shapes

            shapeData.shapes.forEach(shape => {
                let geometry, material, mesh;

                // Create material with the specified color
                material = new THREE.MeshStandardMaterial({ color: shape.color });

                
                // Create geometry based on shape type
                if (shape.type === 'sphere') {
                    geometry = new THREE.SphereGeometry(shape.size / 2, 32, 32);
                }
                else if (shape.type === 'cube') {
                    geometry = new THREE.BoxGeometry(shape.size, shape.size, shape.size);
                }
                else if (shape.type === 'box') {
                    geometry = new THREE.BoxGeometry(shape.width, shape.height, shape.depth || shape.width);
                }
                else if (shape.type === 'cylinder') {
                    geometry = new THREE.CylinderGeometry(shape.size / 2, shape.size / 2, shape.height, 32);
                }
                else if (shape.type === 'cone') {
                    geometry = new THREE.ConeGeometry(shape.size / 2, shape.height, 32);
                }
                else if (shape.type === 'torus') {
                    geometry = new THREE.TorusGeometry(shape.size / 2, shape.tubeSize || shape.size / 6, 16, 100);
                }
                else if (shape.type === 'tetrahedron') {
                    geometry = new THREE.TetrahedronGeometry(shape.size / 2);
                }
                
                if (geometry) {
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.userData.isShape = true;
                    
                    // Position and rotation
                    mesh.position.set(shape.x || 0, shape.y || 0, shape.z || 0);
                    
                    // Handle rotation (convert from degrees to radians)
                    if (shape.rotationX) mesh.rotation.x = shape.rotationX * Math.PI / 180;
                    if (shape.rotationY) mesh.rotation.y = shape.rotationY * Math.PI / 180;
                    if (shape.rotationZ) mesh.rotation.z = shape.rotationZ * Math.PI / 180;
                    
                    group.add(mesh);
                }
            });

            return group;
        }
        
        createImage(config) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            
            if (config.render) {
                canvas.width = config.render.canvasWidth;
                canvas.height = config.render.canvasHeight;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                (config.render.shapes || []).forEach(shape => {
                    ctx.save(); // Save current state
                    ctx.translate(shape.x, shape.y); // Move origin to shape center
                    ctx.rotate((shape.rotation || 0) * Math.PI / 180); // Rotate canvas

                    ctx.fillStyle = shape.color;

                    if (shape.type === 'circle') {
                        ctx.beginPath();
                        ctx.arc(0, 0, shape.size / 2, 0, Math.PI * 2);
                        ctx.fill();
                    } 
                    else if (shape.type === 'square') {
                        ctx.fillRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size);
                    } 
                    else if (shape.type === 'rect') {
                        ctx.fillRect(-shape.width / 2, -shape.height / 2, shape.width, shape.height);
                    } 
                    else if (shape.type === 'triangle') {
                        ctx.beginPath();
                        ctx.moveTo(0, -shape.size / 2);
                        ctx.lineTo(-shape.size / 2, shape.size / 2);
                        ctx.lineTo(shape.size / 2, shape.size / 2);
                        ctx.closePath();
                        ctx.fill();
                    }

                    ctx.restore(); // Restore original state
                });
            } else {
                canvas.width = config.size;
                canvas.height = config.size;
                ctx.fillStyle = config.color;
                if (config.isCircle) {
                    ctx.beginPath();
                    ctx.arc(config.size/2, config.size/2, config.size/2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillRect(0, 0, config.size, config.size);
                }
            }
            return canvas;
        }
    }

    class Effect { 
        constructor(config, applyFn, amount) {
            this.id = config.id;
            this.title = config.title;
            this.desc = config.desc;
            this.lifeTime = config.lifeTime;
            this.applyFn = applyFn;
            this.amount = amount;    
        }

        update() {
            this.lifeTime--;
            if( this.lifeTime <= 0) return false;
            return true;        
        }

        apply(s, add, mul) {
            this.applyFn(s, add, mul, this.amount);
        }
    }
    class Upgrade { 
        constructor(id, title, desc, icon, appliesTo, condition, apply, onAcquire) {
            this.id = id;
            this.title = title;
            this.desc = desc;
            this.icon = icon;
            this.appliesTo = appliesTo;
            this.conditionFn = condition;
            this.applyFn = apply;
            this.onAcquire = onAcquire;        
        }

        canApply(gameState) {
            return this.conditionFn(gameState);
        }

        apply(s, add, mul) {
            this.applyFn(s, add, mul);
        }
    }

    class Component {
        constructor(game, parent) {
            this.game = game;
            this.parent = parent;
        }
        getComponent(type) {
            return this.parent.getComponent(type);
        }
        update() {}
        destroy() {}
    }

    class Renderer extends Component {
        constructor(game, parent, image, offsetY) {
            super(game, parent);
            this.ctx = game.ctx;
            this.image = image;        
            this.lastX = 0;
            this.lastY = 0;
            this.currentFrame = 0;
            this.offsetY = offsetY;
        }
        update() {
            const dx = this.parent.position.x - this.lastX; // Change in x
            const dy = this.parent.position.y - this.lastY; // Change in y

            // Determine primary direction based on magnitude of movement
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal movement dominates
                if (dx > 0) {
                    this.currentFrame = 1; // Right
                } else if (dx < 0) {
                    this.currentFrame = 2; // Left
                }
            } else if (Math.abs(dy) >= Math.abs(dx)) {
                // Vertical movement dominates or equal to horizontal
                if (dy > 0) {
                    this.currentFrame = 0; // Down
                } else if (dy < 0) {
                    this.currentFrame = 3; // Up
                }
            }

            // Update last known position
            this.lastX = this.parent.position.x;
            this.lastY = this.parent.position.y;
        }

        draw() {
            if (this.image && this.image.length > this.currentFrame) {
                const pixelX = this.parent.position.x;
                const pixelY = this.parent.position.y;

                // Convert pixel to isometric
                const isoPos = translator.pixelToIso(pixelX, pixelY);

                const imgWidth = this.image[this.currentFrame].width;
                const imgHeight = this.image[this.currentFrame].height;
                
                const drawX = isoPos.x - imgWidth / 2;
                const drawY = isoPos.y - imgHeight / 2;

                this.ctx.drawImage(this.image[this.currentFrame], drawX, drawY);

            }
        }
      
    }
    class HitEffectParticle extends Component {
        constructor(game, parent, damageType) {
            super(game, parent);
            this.damageType = damageType || "default";
            this.particles = [];
            
            // Spawn particles based on damage type
            const particleCount = 5;
            for (let i = 0; i < particleCount; i++) {
                this.particles.push({
                    x: 0, // Relative to parent
                    y: 0,
                    vx: (Math.random() - 0.5) * 4, // Velocity (-2 to 2)
                    vy: (Math.random() - 0.5) * 4,
                    size: Math.random() * 3 + 1, // 1-4 pixels
                    alpha: 1, // Fades from 1 to 0
                    color: this.getColor()
                });
            }
        }

        getColor() {
            switch (this.damageType) {
                case "electric": return "rgba(0, 255, 255, "; // Cyan for electric
                case "fire": return "rgba(255, 165, 0, "; // Orange for fire
                case "ice": return "rgba(128, 128, 255, "; // Blue for ice
                case "plasma": return "rgba(255, 0, 255, "; // Purple for plasma
                default: return "rgba(255, 255, 255, "; // White fallback
            }
        }

        update() {
            const lifespanComp = this.parent.getComponent("LifeSpan");
            if (!lifespanComp) return; // Safety check

            const fadeFactor = lifespanComp.lifeSpan / 30; // Normalize to initial lifespan (30 frames)
            for (let particle of this.particles) {
                particle.x += particle.vx * this.game.state.timeScale;
                particle.y += particle.vy * this.game.state.timeScale;
                particle.alpha = fadeFactor; // Fade based on remaining lifespan
                particle.size *= 0.98; // Slight shrink per frame
            }
        }
    }
    class HitEffectRenderer extends Component {
        constructor(game, parent, image, offsetY) {
            super(game, parent);
            this.ctx = game.ctx;
        }

        draw() {
            const particleComp = this.parent.getComponent("HitEffectParticle");
            if (!particleComp || !particleComp.particles.length) return;

            const basePos = translator.pixelToIso(this.parent.position.x, this.parent.position.y);

            for (let particle of particleComp.particles) {
                this.ctx.fillStyle = `${particle.color}${particle.alpha})`;
                this.ctx.beginPath();
                const drawX = basePos.x + particle.x;
                const drawY = basePos.y + particle.y;
                this.ctx.arc(drawX, drawY, particle.size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }
    class LightningRenderer extends Component {
        constructor(game, parent, ownerStats) {
            super(game, parent);
            this.ctx = game.ctx;
            this.startOffsetY = ownerStats.projectileStartOffsetY || CONFIG.GRID_SIZE / 2;
        }

        draw() {
            const projectile = this.parent.getComponent("ChainProjectile");
            if (!projectile || !projectile.chainTargets.length) return;

            this.ctx.strokeStyle = "rgba(0, 255, 255, 0.8)"; // Cyan lightning
            this.ctx.lineWidth = 2;
            let stats = this.parent.getComponent('stats').stats;
            // Start from Tesla Coil (parent position)
            let startPos = translator.pixelToIso(this.parent.position.x, this.parent.position.y);
            startPos.y -= this.startOffsetY;//dont shoot off the ground
            for (let i = 0; i < projectile.chainTargets.length; i++) {
                const target = projectile.chainTargets[i];
                if (!target || target.destroyed) continue;

                const endPos = translator.pixelToIso(target.position.x, target.position.y);
                this.drawLightning(startPos, endPos);

                // Next arc starts from this target
                startPos = endPos;
            }
        }

        drawLightning(startPos, endPos) {
            this.ctx.beginPath();            
            this.ctx.moveTo(startPos.x, startPos.y);

            const segments = 8; // Number of zigzag points
            const dx = (endPos.x - startPos.x) / segments;
            const dy = (endPos.y - startPos.y) / segments;

            let currentX = startPos.x;
            let currentY = startPos.y;

            for (let i = 1; i < segments; i++) {
                currentX += dx;
                currentY += dy;

                // Add random offset for jagged effect
                const offsetX = (Math.random() - 0.5) * 10; // Max 10px jitter
                const offsetY = (Math.random() - 0.5) * 10;

                this.ctx.lineTo(currentX + offsetX, currentY + offsetY);
            }

            this.ctx.lineTo(endPos.x, endPos.y);
            this.ctx.stroke();
        }
    }
    class ChainProjectile extends Component {
        constructor(game, parent, type, owner, target, stats) {
            super(game, parent);
            this.type = type;
            this.def = gameConfig.projectiles[this.type];
            this.owner = owner;
            this.target = target;
            this.stats = stats;
            this.piercedEnemies = [];
            this.ownerStats = this.owner.getComponent("stats").stats;
            this.chainTargets = []; // Store all targets hit in one frame
            this.hasStruck = false; // Flag to strike only once
        }

        update() {
            if (this.hasStruck) {
                this.parent.destroy(); // Destroy after one frame of striking
                return;
            }

            if (!this.target || this.target.destroyed) {
                this.parent.destroy();
                return;
            }

            // Strike the initial target
            let targetHealth = this.target.getComponent("health");
            targetHealth.hp -= this.stats.damage;
            this.piercedEnemies.push(this.target);
            this.chainTargets.push(this.target);
            this.game.createHitEffect(this.target.position.x, this.target.position.y, this.def.hitEffectType);

            // Chain to nearby enemies
            if (this.stats.piercing > 0 && this.piercedEnemies.length <= this.stats.piercing) {
                const nearbyEnemies = this.game.spatialGrid.getNearbyEntities(
                    this.target.position.x, 
                    this.target.position.y, 
                    this.ownerStats.range
                );

                for (let enemy of nearbyEnemies) {
                    if (enemy.destroyed || this.piercedEnemies.includes(enemy)) continue;
                    const dx = enemy.position.x - this.target.position.x;
                    const dy = enemy.position.y - this.target.position.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq <= this.ownerStats.range * this.ownerStats.range) {
                        let enemyHealth = enemy.getComponent("health");
                        enemyHealth.hp -= this.stats.damage;
                        this.piercedEnemies.push(enemy);
                        this.chainTargets.push(enemy);
                        this.game.createHitEffect(enemy.position.x, enemy.position.y, this.def.hitEffectType);
                        if (this.piercedEnemies.length > this.stats.piercing) break;
                    }
                }
            }

            // Apply additional effects (e.g., slow, leech) to all hit targets
            for (let enemy of this.chainTargets) {
                if (this.ownerStats.slowEffect) {
                    enemy.getComponent("stats").addEffect(gameConfig.effects.slow, effects.slow, this.ownerStats.slowEffect);
                }
                if (this.ownerStats.leech > 0) {
                    const healing = this.stats.damage * this.ownerStats.leech * this.game.state.stats.healingMultiplier;
                    this.game.state.bloodCoreHP = Math.min(this.game.state.stats.maxBloodCoreHP, this.game.state.bloodCoreHP + healing);
                }
                if (this.ownerStats.thief && this.ownerStats.thief != 0) {
                    const stealAmt = this.stats.damage * this.ownerStats.thief * this.game.state.stats.bloodShardMultiplier;
                    this.game.state.bloodShards += stealAmt;
                }
            }

            this.hasStruck = true; // Mark as struck, render lightning this frame
        }
    }
    class RangeIndicator extends Component {
        constructor(game, parent, image, offsetY) {
            super(game, parent);
            this.ctx = game.ctx;
        }
        draw() {

            let statsComp = this.getComponent('stats');
            if (statsComp && statsComp.stats.range) {
                this.drawRangeIndicator(statsComp.stats.range);
            }
        }

        drawRangeIndicator(range) {            
            const pixelX = this.parent.position.x;
            const pixelY = this.parent.position.y;
            let gridPos = translator.pixelToGrid(pixelX, pixelY);
            gridPos = translator.snapToGrid(gridPos.x, gridPos.y);
            if( gridPos.x == this.game.state.mousePosition.gridX && gridPos.y == this.game.state.mousePosition.gridY ) {
                const isoPos = translator.pixelToIso(pixelX, pixelY);
                // Convert range from grid units to isometric pixel units
                const isoRangeX = range;         // X-axis range remains roughly the same in isometric space
                const isoRangeY = range * 0.5;   // Y-axis range is halved due to isometric compression

                // Set styling for the range indicator
                this.ctx.beginPath();
                this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)'; // Red with transparency
                this.ctx.lineWidth = 2;

                // Draw an ellipse to represent the range in isometric space
                this.ctx.ellipse(
                    isoPos.x,           // Center x in isometric coords
                    isoPos.y,           // Center y in isometric coords
                    isoRangeX,          // X radius (wider due to isometric projection)
                    isoRangeY,          // Y radius (shorter due to flattening)
                    0,                  // Rotation (none needed for isometric)
                    0,                  // Start angle
                    2 * Math.PI         // End angle (full circle)
                );

                this.ctx.stroke();
                this.ctx.closePath();
            }
        }
    }

    class Leveler extends Component {
        constructor(game, parent, level = 1) {
            super(game, parent);
            this.level = level;
        }
    }

    class Explosion extends Component {
        constructor(game, parent, radius) {
            super(game, parent);
            this.maxRadius = radius;
            this.currentRadius = 0;
            this.alpha = 1;
        }

        update() {
            this.currentRadius += this.maxRadius * 0.1;
            this.alpha -= 0.05;
            if( this.alpha < 0 ) {
                this.parent.destroy();
            }
        }

        draw() {
            const pixelX = this.parent.position.x;
            const pixelY = this.parent.position.y;

            // Convert pixel to isometric
            const isoPos = translator.pixelToIso(pixelX, pixelY);
            const isoRadiusX = this.currentRadius;         // X-axis range remains roughly the same in isometric space
            const isoRadiusY = this.currentRadius * 0.5;   // Y-axis range is halved due to isometric compression

            this.game.ctx.beginPath();
            this.game.ctx.ellipse(
                    isoPos.x,           // Center x in isometric coords
                    isoPos.y,           // Center y in isometric coords
                    isoRadiusX,          // X radius (wider due to isometric projection)
                    isoRadiusY,          // Y radius (shorter due to flattening)
                    0,                  // Rotation (none needed for isometric)
                    0,                  // Start angle
                    2 * Math.PI         // End angle (full circle)
                );
            this.game.ctx.fillStyle = `rgba(255, 200, 0, ${this.alpha * 0.5})`;
            this.game.ctx.fill();

            this.game.ctx.beginPath();
            this.game.ctx.ellipse(
                    isoPos.x,           // Center x in isometric coords
                    isoPos.y,           // Center y in isometric coords
                    isoRadiusX * .7,          // X radius (wider due to isometric projection)
                    isoRadiusY * .7,          // Y radius (shorter due to flattening)
                    0,                  // Rotation (none needed for isometric)
                    0,                  // Start angle
                    2 * Math.PI         // End angle (full circle)
                );
            this.game.ctx.fillStyle = `rgba(255, 100, 0, ${this.alpha})`;
            this.game.ctx.fill();
        
        }
    }

    class LifeSpan extends Component {
        constructor(game, parent, lifeSpan) {
            super(game, parent);
            this.lifeSpan = lifeSpan;
        }
        update() {        
            if( this.lifeSpan > 0 ) {
                this.lifeSpan--;
            } else {
                this.parent.destroy();
            }
        }
    }

    class Buildable extends Component {
        constructor(game, parent) {
            super(game, parent);
            this.placed = false;
        }
    }

    class PopulationBurden extends Component {
        constructor(game, parent) {
            super(game, parent);
            this.stats = this.parent.getComponent('stats').stats;        
        }
        update() {
            if(this.stats){ 
                if( this.stats.population ) {
                    this.game.state.stats.population += this.stats.population;
                } 
                if( this.stats.supply ) {
                    this.game.state.stats.maxPopulation += this.stats.supply;
                }
            }
        }
    }

    class Attacker extends Component {
        constructor(game, parent) {
            super(game, parent);     
            this.stats = this.getComponent('stats').stats;    
            this.level = 1;
            this.target = null;
            this.projectiles = [];  
            this.cooldown = 0;
        }

        update() {

            if (this.cooldown > 0) this.cooldown--;
                    
            // Find target if none
            if (!this.target || this.target.getComponent('health').hp <= 0 || Math.hypot(this.target.position.x - this.parent.position.x, this.target.position.y - this.parent.position.y) > this.stats.range) {
                this.findTarget();
            }
            
            // Attack if ready and has target
            if (this.cooldown <= 0 && this.target) {
                this.attack();
            }

            if( this.cooldown <= 0 && this.stats.mineAmt > 0 ){
                this.gather();
            }
            return true;
        }
        
        findTarget() {
            this.target = null;
            let furthestEnemy = null;
            let furthestDistance = -1;
            const nearbyEnemies = this.game.spatialGrid.getNearbyEntities(
                this.parent.position.x, 
                this.parent.position.y, 
                this.stats.range
            );
            for (let enemy of nearbyEnemies) {
                let enemyHP = enemy.getComponent('health').hp;
                let followPath = enemy.getComponent('followPath');
                if (enemyHP <= 0) continue;          

                // Target furthest enemy along path (closest to core)
                if (followPath.pathIndex > furthestDistance) {
                    furthestDistance = followPath.pathIndex;
                    furthestEnemy = enemy;
                }
                
            }
            
            this.target = furthestEnemy;
        }

        gather() {
            this.game.state.bloodShards += this.stats.mineAmt;
            this.cooldown = this.stats.attackSpeed;
        }

        attack() {
            if (!this.target) return; 
            this.launchProjectile();
            this.cooldown = this.stats.attackSpeed;
        }
        
        launchProjectile() {
            let damage = this.stats.damage * this.game.state.stats.damageMultiplier;
            let projectileType = this.stats.projectile;
            // Critical hit calculation
            const isCritical = Math.random() < this.stats.critChance;
            if (isCritical) {
                damage *= this.stats.critMultiplier;
            } 
            
            this.game.createProjectile(projectileType, this.parent.position.x, this.parent.position.y, this.target, damage, isCritical, this.parent);
                    
        }

    }

    class Health extends Component { 
        constructor( game, parent ) {
            super(game, parent);        
            let statsComp = parent.getComponent('stats');
            this.hp = statsComp.stats.hp;
            statsComp.addStat('maxHp', this.hp);
        }
        update() {        
            if (this.hp <= 0){            
                this.parent.destroy();
            }
        }

        draw() {
            let statsComp = this.parent.getComponent('stats');
            const healthPercentage = this.hp / statsComp.stats.maxHp;
            const barWidth = 30;
            this.game.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';

            const isoPos = translator.pixelToIso(this.parent.position.x, this.parent.position.y)

            this.game.ctx.fillRect(isoPos.x - barWidth/2, isoPos.y - CONFIG.GRID_SIZE, barWidth, 5);
            this.game.ctx.fillStyle = healthPercentage > 0.5 ? 'rgba(0, 255, 0, 0.5)' : healthPercentage > 0.25 ? 'rgba(255, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
            this.game.ctx.fillRect(isoPos.x - barWidth/2, isoPos.y - CONFIG.GRID_SIZE, barWidth * healthPercentage, 5);
        }
    }

    class EssenceBounty extends Component { 
        constructor( game, parent ) {
            super(game, parent);        
            this.statsComp = parent.getComponent('stats');
        }
        destroy() {               
            this.game.state.essence += this.statsComp.stats.essence * this.game.state.stats.essenceMultiplier;        
        }
    }

    class SpacialGridEntity extends Component { 
        update() {
            this.game.spatialGrid.insert(this.parent);
        }
        destroy() {
            this.game.spatialGrid.remove(this.parent);
        }
    }

    class Stats extends Component { 
        constructor( game, parent, type, stats ) {
            super(game, parent);
            this.type = type;
            this.stats = {...stats};
            this.defaultStats = {...this.stats};
            this.activeEffects = {};
        }
        update() {
            this.stats = {...this.defaultStats};
            this.applyEffects();
            this.applyUpgrades();
        }
        addStat(statName, statValue) {
            this.stats[statName] = statValue;
            this.defaultStats[statName] = statValue;
        }
        addEffect(effectConfig, effectFn, effectAmt) {        
            this.activeEffects[effectConfig.id] = new Effect( effectConfig, effectFn, effectAmt );
        }
        applyEffects() {
            let effectArr = [];
            for(let effectId in this.activeEffects) {
                if(this.activeEffects[effectId] && this.activeEffects[effectId].update()){
                    effectArr.push(this.activeEffects[effectId]);
                } else {
                    this.activeEffects[effectId] = undefined;
                }
            }        
            
            calculateStats(this.stats, effectArr);
        }
        
        applyUpgrades() {
            calculateStats(this.stats, this.game.state.activeUpgrades[this.type]);        
        }
    }

    class FollowPath extends Component {
        constructor(game, parent, pathIndex = 0) {
            super(game, parent);
            this.pathIndex = pathIndex;
            this.x = this.game.state.path[this.pathIndex].x;
            this.y = this.game.state.path[this.pathIndex].y;
            this.parent.position = { x: this.x * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2, y: this.y * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2 };        
        }

        update() {
            this.stats = this.getComponent('stats').stats;
            if (this.pathIndex < this.game.state.path.length - 1) {
                const target = this.game.state.path[this.pathIndex + 1];
                const dx = target.x * CONFIG.GRID_SIZE + (CONFIG.GRID_SIZE / 2) - this.parent.position.x;
                const dy = target.y * CONFIG.GRID_SIZE + (CONFIG.GRID_SIZE / 2) - this.parent.position.y;
                const dist = Math.hypot(dx, dy);

                if (dist > this.stats.speed) {
                    this.parent.position.x += (dx / dist) * this.stats.speed;
                    this.parent.position.y += (dy / dist) * this.stats.speed;
                } else {
                    this.pathIndex++;
                }
                this.x = parseInt(this.parent.position.x / CONFIG.GRID_SIZE);
                this.y = parseInt(this.parent.position.y / CONFIG.GRID_SIZE);
            } else {
                this.game.state.bloodCoreHP -= this.stats.value;
                this.parent.destroy();
                return false;
            }
        }
    }

    class Projectile extends Component {
        constructor(game, parent, type, owner, target, stats) {
            super(game, parent);
            this.type = type;
            this.def = gameConfig.projectiles[this.type];
            this.owner = owner;
            this.target = target;
            this.stats = stats;
            this.piercedEnemies = [];
            this.ownerStats = this.owner.getComponent("stats").stats;
            
        }

        update() {
        
            // Remove if target is gone
            if (!this.target || this.target.destroyed) {
                this.parent.destroy();
            }
            // Move towards target
            const dx = this.target.position.x - this.parent.position.x;
            const dy = this.target.position.y - this.parent.position.y;
            const distSq = dx * dx + dy * dy;
            
            // Hit detection
            if (distSq < 15 * 15 ) {
                let targetHealth = this.target.getComponent("health");
                if (this.stats.splashRadius > 0) {
                    const nearbyEnemies = this.game.spatialGrid.getNearbyEntities(
                        this.parent.position.x, 
                        this.parent.position.y, 
                        this.stats.splashRadius
                    );
                    // Process only relevant enemies
                    for (const enemy of nearbyEnemies) {
                        if (enemy.isDead) continue;
                        let enemyHealth = enemy.getComponent("health");
                        let enemyStats = enemy.getComponent("stats");
                        const dx = enemy.position.x - this.target.position.x;
                        const dy = enemy.position.y - this.target.position.y;
                        const distSq1 = dx * dx + dy * dy;
                        
                        // Compare with squared splash radius for efficiency
                        const splashRadiusSq = this.stats.splashRadius * this.stats.splashRadius;
                        if (distSq1 <= splashRadiusSq) {
                            // Calculate actual distance only when needed
                            const splashDist = Math.sqrt(distSq1);
                            enemyHealth.hp -= (this.stats.damage * (1 - (splashDist / this.stats.splashRadius) * 0.5));                     
                            this.game.createHitEffect(enemy.position.x, enemy.position.y, this.def.hitEffectType);
                            if( this.ownerStats.slowEffect ) {
                                enemyStats.addEffect(gameConfig.effects.slow, effects.slow, this.ownerStats.slowEffect);
                            }
                        }
                    }
                    let explosion = new Entity(this.game, this.parent.position.x, this.parent.position.y);
                    explosion.addRenderer(Explosion, this.stats.splashRadius);
                    this.game.state.addEntity(explosion);
                } else {
                    let def = gameConfig.projectiles[this.type];
                    // Apply damage
                    targetHealth.hp -= this.stats.damage;
                    this.game.createHitEffect(this.target.position.x, this.target.position.y, def.hitEffectType);
                    if( this.ownerStats.slowEffect ) {
                        this.target.addEffect(gameConfig.effects.slow, effects.slow, this.ownerStats.slowEffect );
                    }
                }

                //summon skeleton
                if (this.ownerStats.summonChance > 0 && 
                    targetHealth.hp <= 0 && 
                    Math.random() < this.ownerStats.summonChance - 1) {
                        this.game.createSummon(this.target.position.x, this.target.position.y, this.ownerStats.summonType);
                }

                // Apply tower special effects
                if (this.ownerStats.leech > 0) {
                    const healing = this.stats.damage * this.ownerStats.leech * this.game.state.stats.healingMultiplier;
                    this.game.state.bloodCoreHP = Math.min(this.game.state.stats.maxBloodCoreHP, this.game.state.bloodCoreHP + healing);
                }
                if (this.ownerStats.thief && this.ownerStats.thief != 0) {
                    const stealAmt = this.stats.damage * this.ownerStats.thief * this.game.state.stats.bloodShardMultiplier;
                    this.game.state.bloodShards += stealAmt;
                }
                // Piercing logic
                if (this.stats.piercing > 0 && this.piercedEnemies.length < this.stats.piercing) {
                    this.piercedEnemies.push(this.target);
                    const nearbyEnemies = this.game.spatialGrid.getNearbyEntities(
                        this.parent.position.x, 
                        this.parent.position.y, 
                        this.ownerStats.range
                    );
                    // Find a new target
                    let newTarget = null;
                    for (let enemy of nearbyEnemies) {
                        if (!enemy.destroyed && !this.piercedEnemies.includes(enemy)) {
                            const dx = enemy.position.x - this.parent.position.x;
                            const dy = enemy.position.y - this.parent.position.y;
                            const distSq2 = dx * dx + dy * dy;
                            if (distSq2 < this.ownerStats.range * this.ownerStats.range) {
                                newTarget = enemy;
                                break;
                            }
                        }
                    }
                    
                    if (newTarget) {
                        this.target = newTarget;   
                        return;                 
                    } 
                } 
                
                this.parent.destroy();
            }
            
            // Move projectile
            let dist = Math.sqrt(distSq);
            const speed = this.stats.speed * this.game.state.timeScale;
            this.parent.position.x += (dx / dist) * speed;
            this.parent.position.y += (dy / dist) * speed;
        }
    }

    class SpatialGrid {
        constructor(worldWidth, worldHeight, cellSize) {
            this.cellSize = cellSize;
            this.cols = Math.ceil(worldWidth / cellSize);
            this.rows = Math.ceil(worldHeight / cellSize);
            this.grid = new Array(this.cols * this.rows).fill().map(() => []);
            
            // Track which cell each entity is in
            this.entityCells = new Map(); // Map of entity -> cell index
        }
        
        getIndex(x, y) {
            // Clamp coordinates to world boundaries
            const clampedX = Math.max(0, Math.min(x, this.cols * this.cellSize - 1));
            const clampedY = Math.max(0, Math.min(y, this.rows * this.cellSize - 1));
            
            const col = Math.floor(clampedX / this.cellSize);
            const row = Math.floor(clampedY / this.cellSize);
            return row * this.cols + col;
        }

        insert(entity) {
            const newIndex = this.getIndex(entity.position.x, entity.position.y);
            const oldIndex = this.entityCells.get(entity);
            
            // If entity moved to a new cell
            if (oldIndex !== newIndex) {
                // Remove from old cell if it exists
                if (oldIndex !== undefined) {
                    const oldCell = this.grid[oldIndex];
                    const entityIndex = oldCell.indexOf(entity);
                    if (entityIndex !== -1) {
                        oldCell.splice(entityIndex, 1);
                    }
                }
                
                // Add to new cell
                if (newIndex >= 0 && newIndex < this.grid.length) {
                    this.grid[newIndex].push(entity);
                    this.entityCells.set(entity, newIndex);
                }
            }
        }
        
        remove(entity) {
            const index = this.entityCells.get(entity);
            if (index !== undefined) {
                const cell = this.grid[index];
                const entityIndex = cell.indexOf(entity);
                if (entityIndex !== -1) {
                    cell.splice(entityIndex, 1);
                }
                this.entityCells.delete(entity);
            }
        }
        
        getNearbyEntities(x, y, radius) {
            const nearby = [];
            const max = 3;
            // Get cells that could contain entities within radius
            const startCol = Math.max(0, Math.floor((x - radius) / this.cellSize));
            const endCol = Math.min(this.cols - 1, Math.floor((x + radius) / this.cellSize));
            const startRow = Math.max(0, Math.floor((y - radius) / this.cellSize));
            const endRow = Math.min(this.rows - 1, Math.floor((y + radius) / this.cellSize));
            
            // Collect potential candidates from relevant cells
            for (let row = startRow; row <= endRow && nearby.length < max; row++) {
                for (let col = startCol; col <= endCol && nearby.length < max; col++) {
                    const index = row * this.cols + col;
                    if (index >= 0 && index < this.grid.length) {
                        for( let i = 0; i < this.grid[index].length; i++){
                            let entity = this.grid[index][i];
                            if( nearby.length < max) {
                                nearby.push(entity);
                            } else {
                                break;
                            }
                        }
                    }
                }
            }
            
            return nearby;
        }
        
        clear() {
            this.grid = this.grid.map(() => []);
            this.entityCells.clear();
        }
        
        // Optional: Only clear but maintain all entity positions
        // Useful for when reusing the same grid across updates
        resetKeepingEntities() {
            const allEntities = [];
            this.entityCells.forEach((_, entity) => {
                allEntities.push(entity);
            });
            
            this.clear();
            
            allEntities.forEach(entity => {
                this.insert(entity);
            });
        }
    }


    class ArrayTracker extends Component {
        constructor(game, parent, arr) {
            super(game, parent);
            this.arr = arr;
            if(!this.game.state[this.arr]){
                this.game.state[this.arr] = [];
            }
            this.game.state[this.arr].push(this.parent);
        }

        destroy(){
            let index = this.game.state[this.arr].indexOf(this.parent);
            this.game.state[this.arr].splice(index, 1);        
        }
    }    
    
    class Entity {
        constructor(game, x, y) {
            this.game = game;
            this.position = { x: x, y: y };
            this.components = [];
            this.renderers = [];
            this.destroyed = false;        
            this.id = ++game.entityId;
        }

        getComponent(name) {
            return this.components[name.toLowerCase()];
        }
        addRenderer(ComponentClass, ...params) {
            let renderer = this.addComponent(ComponentClass, ...params);
            this.renderers.push(renderer);
            return renderer;
        }
        addComponent(ComponentClass, ...params) {
            const component = new ComponentClass(this.game, this, ...params);
            this.components[ComponentClass.name.toLowerCase()] = component;
            return component;
        }
        removeComponent(component) {
            let index = this.components.indexOf(component);
            if( index >= 0 ) {
                this.components.splice(index, 1);
            }
        }
        update() {   
    
            for(let c in this.components) {
                this.components[c].update();   
                if(this.destroyed) break;
            }
            return !this.destroyed;
        }
        draw() {
            if( this.renderers.length ) {
                this.renderers.forEach( (r) => r.draw() );
            }
        }
        destroy() {
            this.destroyed = true;
            for(let c in this.components) {
                this.components[c].destroy();   
            }
        }
    }

    class MapRenderer {
        constructor(game) {        
            this.game = game;
            this.ctx = game.canvas.getContext('2d');
            this.selectedTowerType = null;
            this.hoverCell = { x: -1, y: -1 };
            this.showRange = false;
            this.isMapCached = false; // Flag to track if map needs redrawing
            
            // Create off-screen canvas for caching
            this.mapCacheCanvas = document.createElement('canvas');
            this.mapCacheCanvas.width = CONFIG.CANVAS_WIDTH;
            this.mapCacheCanvas.height = CONFIG.CANVAS_HEIGHT;
            this.mapCacheCtx = this.mapCacheCanvas.getContext('2d');

            
            this.envCacheCanvasBG = document.createElement('canvas');
            this.envCacheCanvasBG.width = CONFIG.CANVAS_WIDTH;
            this.envCacheCanvasBG.height = CONFIG.CANVAS_HEIGHT / 2;
            this.envCacheCtxBG = this.envCacheCanvasBG.getContext('2d');

            this.envCacheCanvasFG = document.createElement('canvas');
            this.envCacheCanvasFG.width = CONFIG.CANVAS_WIDTH;
            this.envCacheCanvasFG.height = CONFIG.CANVAS_HEIGHT / 2;
            this.envCacheCtxFG = this.envCacheCanvasFG.getContext('2d');
        }

        clearScreen() {        
            this.ctx.clearRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
        }

        // Call this when map data changes or on initialization
        cacheMap(tileMap, path) {
            // Clear the cache canvas
            this.mapCacheCtx.clearRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            
            // Draw the map onto the cache canvas
            this.drawMap(tileMap, path);
            
            // Mark cache as valid
            this.isMapCached = true;
        }

        renderBG(state, map) {
            this.clearScreen();
            
            // Generate cache if not already done
            if (!this.isMapCached) {
                this.cacheMap(map.tileMap, map.path);
            }
            
            // Draw cached map image to main canvas
            this.ctx.drawImage(this.mapCacheCanvas, 0, 0);
            this.ctx.drawImage(this.envCacheCanvasBG, 0, 0);
        }
        renderFG() {  
            this.ctx.drawImage(this.envCacheCanvasFG, 0, CONFIG.CANVAS_HEIGHT / 2);
        }

        drawMap(tileMap, path) {
            this.mapCacheCtx.fillStyle = '#4a7c59';
            this.mapCacheCtx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

            const tileWidth = CONFIG.GRID_SIZE;
            const tileHeight = CONFIG.GRID_SIZE * 0.5;
            
            for (let y = 0; y < CONFIG.ROWS; y++) {
                for (let x = 0; x < CONFIG.COLS; x++) {
                    const tile = tileMap[y][x];
                    const isoX = (x - y) * (tileWidth / 2) + CONFIG.CANVAS_WIDTH / 2;
                    const isoY = (x + y) * (tileHeight / 2);

                    this.mapCacheCtx.fillStyle = tile.type === 'grass' ? '#4a7c59' : 
                                    tile.type === 'path' ? '#9c826a' : 
                                    '#3d88c8';

                    this.mapCacheCtx.beginPath();
                    this.mapCacheCtx.moveTo(isoX, isoY);
                    this.mapCacheCtx.lineTo(isoX + tileWidth / 2, isoY + tileHeight / 2);
                    this.mapCacheCtx.lineTo(isoX, isoY + tileHeight);
                    this.mapCacheCtx.lineTo(isoX - tileWidth / 2, isoY + tileHeight / 2);
                    this.mapCacheCtx.closePath();
                    this.mapCacheCtx.fill();

                    this.mapCacheCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                    this.mapCacheCtx.stroke();
                }
            }

            this.mapCacheCtx.strokeStyle = '#ffd166';
            this.mapCacheCtx.lineWidth = 2;
            this.mapCacheCtx.beginPath();
            
            const firstIsoX = (path[0].x - path[0].y) * (tileWidth / 2) + CONFIG.CANVAS_WIDTH / 2;
            const firstIsoY = (path[0].x + path[0].y) * (tileHeight / 2) + tileHeight / 2;
            this.mapCacheCtx.moveTo(firstIsoX, firstIsoY);

            path.slice(1).forEach(p => {
                const isoX = (p.x - p.y) * (tileWidth / 2) + CONFIG.CANVAS_WIDTH / 2;
                const isoY = (p.x + p.y) * (tileHeight / 2) + tileHeight / 2;
                this.mapCacheCtx.lineTo(isoX, isoY);
            });
            
            this.mapCacheCtx.stroke();
            this.drawEnvironment();
        }

        drawEnvironment() {

            let itemAmt = CONFIG.COLS * CONFIG.ROWS;
            let environmentTypes = [];
            for(let envType in gameConfig.environment){
                environmentTypes.push(envType);
            }
            let items = [];            
            for(let i = 0; i < itemAmt; i++) {
                // Define the game board boundaries
                const boardMinX = 0;
                const boardMaxX = CONFIG.COLS * CONFIG.GRID_SIZE;
                const boardMinY = 0;
                const boardMaxY = CONFIG.ROWS * CONFIG.GRID_SIZE;
                
                // Generate a random position that's outside the board but within a reasonable distance
                let x, y;
                
                // Expand the area where we can place objects
                const expandAmount = CONFIG.COLS * CONFIG.GRID_SIZE / 2; // Adjust this value as needed
                
                // Randomly choose whether to place on x-axis or y-axis outside the board
                if (Math.random() < 0.5) {
                    // Place on the left or right of the board
                    x = Math.random() < 0.5 ? 
                        boardMinX - Math.random() * expandAmount : // Left side
                        boardMaxX + Math.random() * expandAmount;  // Right side
                    
                    // Random y position with a bit of a buffer
                    y = (boardMinY) + Math.random() * (boardMaxY - boardMinY);
                } else {
                    // Place on the top or bottom of the board
                    y = Math.random() < 0.5 ? 
                        boardMinY - Math.random() * expandAmount : // Top side
                        boardMaxY + Math.random() * expandAmount;  // Bottom side
                    
                    // Random x position with a bit of a buffer
                    x = (boardMinX) + Math.random() * (boardMaxX - boardMinX);
                }
                
                // Double-check that the position is actually outside the board
                if (x < boardMinX || x > boardMaxX || y < boardMinY || y > boardMaxY) {
                    const type = environmentTypes[Math.floor(Math.random() * environmentTypes.length)];
                    const images = this.game.imageManager.getImages("environment", type);
                    items.push( { img: images[0], x: x, y: y});
                } else {
                    i--; // Position inside board, try again
                }
            }

            items.sort((a, b) => {
                return (a.y * CONFIG.COLS + a.x) - (b.y * CONFIG.COLS + b.x)
            });

            items.forEach((item) => {            
                // Convert pixel to isometric
                const isoPos = translator.pixelToIso(item.x, item.y);
                const image = item.img;
                const imgWidth = image.width;
                const imgHeight = image.height;
                
                const drawX = isoPos.x - imgWidth / 2;
                const drawY = isoPos.y - imgHeight / 2;
                if( drawY < CONFIG.CANVAS_HEIGHT / 2 ) {
                    this.envCacheCtxBG.drawImage(image, drawX, drawY);
                } else {
                    this.envCacheCtxFG.drawImage(image, drawX, drawY - CONFIG.CANVAS_HEIGHT / 2);
                }
            });
        }
    }

    class Game {
        constructor() {
            this.state = new GameState();
            this.mapManager = new MapManager();
            this.uiManager = new UIManager();
            this.spatialGrid = new SpatialGrid(CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_WIDTH, CONFIG.GRID_SIZE * 2);
            this.entityId = 0;

            this.canvas = document.getElementById("gameCanvas");
            this.ctx = this.canvas.getContext("2d");
            this.imageManager = new ImageManager();

            this.canvas.setAttribute('width', CONFIG.CANVAS_WIDTH);
            this.canvas.setAttribute('height', CONFIG.CANVAS_HEIGHT);

            this.entitiesToAdd = [];
            this.mapRenderer = new MapRenderer(this);
            this.uiManager.reset();
        }

        showUpgradeMenu() {
            if (this.state.isLevelingUp) return; // Prevent re-triggering
            
            this.state.isLevelingUp = true;
            this.state.isPaused = true;
            
            this.uiManager.upgradeMenu.style.display = 'block';
            this.uiManager.overlay.style.display = 'block';
            this.uiManager.upgradeOptionsDiv.innerHTML = '';
            
            // Filter upgrades based on conditions
            const availableUpgrades = upgrades.filter(upgrade => upgrade.canApply(this.state));
            

            
            // Choose 3 random upgrades
            const options = [];
            while (options.length < 3 && availableUpgrades.length > 0) {
                const index = Math.floor(Math.random() * availableUpgrades.length);
                options.push(availableUpgrades[index]);
                availableUpgrades.splice(index, 1);
            }
            
            // Create upgrade options
            options.forEach(upgrade => {
                const div = document.createElement('div');
                div.className = 'upgrade-option';
                div.innerHTML = `
                    <div class="upgrade-icon">${upgrade.icon}</div>
                    <div class="upgrade-desc">
                        <div class="upgrade-title">${upgrade.title}</div>
                        ${upgrade.desc}
                    </div>
                `;
                div.onclick = () => this.selectUpgrade(upgrade);
                this.uiManager.upgradeOptionsDiv.appendChild(div);
            });
        }

        selectUpgrade(upgrade) {       
            // Add to active upgrades list if not already
            if (!this.state.activeUpgrades[upgrade.appliesTo]) {
                this.state.activeUpgrades[upgrade.appliesTo] = [upgrade];
            } else {
                this.state.activeUpgrades[upgrade.appliesTo].push(upgrade);
            }

            this.applyActiveUpgrades();
            if(upgrade.onAcquire) {
                upgrade.onAcquire(this.state);
            }
            
            upgradeMenu.style.display = 'none';
            overlay.style.display = 'none';
            
            this.state.essence -= this.state.essenceToNextLevel;
            this.state.level++;
            this.state.essenceToNextLevel = Math.floor(this.state.essenceToNextLevel * 1.4);        
            
            this.state.isLevelingUp = false;
            this.state.isPaused = false;
        }


        // Wave management
        updateWave() {
            // Spawn enemies
            if (this.state.enemiesSpawned < this.state.enemiesInWave) {
                this.state.spawnCounter++;
                
                if (this.state.spawnCounter >= this.state.spawnRate) {
                    this.createEnemy(this.state.enemiesSpawned == parseInt(this.state.enemiesInWave / 2) ? "boss" : "");//spawn boss halfway through
                    this.state.enemiesSpawned++;
                    this.state.spawnCounter = 0;
                    
                    // Update wave progress
                    waveProgress.style.width = (this.state.enemiesSpawned / this.state.enemiesInWave * 100) + '%';
                }
            } 
            // Move to next wave if all enemies defeated
            else if (this.state.enemies.length === 0 && this.state.enemiesSpawned >= this.state.enemiesInWave) {
                this.state.waveTimer++;
                
                if (this.state.waveTimer >= this.state.waveDelay) {
                    this.startNextWave();
                }
            }
        }

        startNextWave() {
            this.state.wave++;
            waveDisplay.textContent = this.state.wave;
            
            // Check for victory
            // if (this.state.wave > this.state.maxWaves) {
            //     this.gameVictory();
            //     return;
            // }
            
            this.state.enemiesInWave = 10 * (this.state.wave * .5);
            this.state.enemiesSpawned = 0;
            this.state.spawnRate = Math.max(10, 60 - (this.state.wave));
            this.state.spawnCounter = 0;
            this.state.waveTimer = 0;
            
            // Reset wave progress bar
            waveProgress.style.width = '0%';
        }

        applyActiveUpgrades() {
            this.state.stats = {...this.state.defaultStats};
            calculateStats(this.state.stats, this.state.activeUpgrades['global']);    
        }
    
        // Tower placement system
        setupTowerPlacement() {
            let endY = parseInt(CONFIG.ROWS / 2) * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2;
            let endX = (CONFIG.COLS - 1) * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2;

            const keep =  this.createTower(endX, endY, 'keep');
            keep.placed = true;
            const towerButtons = document.querySelectorAll('.tower-option');
            towerButtons.forEach(button => {
                button.addEventListener('click', () => {
                    if( this.state.isPaused ) return;
                    const type = button.getAttribute('data-type');
                    let cost = gameConfig.towers[type].cost;
                    const finalCost = Math.floor(cost * this.state.stats.towerCostMod);
                    
                    let populationCost = gameConfig.towers[type].population || 0;
                    if (this.state.bloodShards >= finalCost && this.state.stats.population + populationCost <= this.state.stats.maxPopulation) {
                        this.state.selectedTowerType = type;
                        if(this.state.previewTower) {
                            this.state.previewTower.destroy();
                        }
                        this.state.previewTower = this.createPreviewTower(-100, -100, this.state.selectedTowerType, true);
                    }
                });
                
                // Show tooltip with info
                button.addEventListener('mouseover', (e) => {
                    const type = button.getAttribute('data-type');
                    let info = gameConfig.towers[type].info;
                    
                    this.showTooltip(e.clientX, e.clientY, info);
                });
                
                button.addEventListener('mouseout', () => {
                    this.hideTooltip();
                });
            });
            
            this.canvas.addEventListener('mousemove', (e) => {
                if (!this.state.selectedTowerType && !this.state.towers.length) return;

                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const gridPos = translator.isoToGrid(mouseX, mouseY);
                const snappedGrid = translator.snapToGrid(gridPos.x, gridPos.y);
                const isoSnappedGridPos = translator.gridToIso(snappedGrid.x, snappedGrid.y);
                const pixelIsoPos = translator.pixelToIso( mouseX, mouseY );
                this.state.mousePosition = { x: mouseX, y: mouseY, isoX: pixelIsoPos.x, isoY: pixelIsoPos.y, gridX: snappedGrid.x, gridY: snappedGrid.y };


                if (this.state.selectedTowerType && this.state.previewTower) {
                    const snappedPixelPos = translator.isoToPixel(isoSnappedGridPos.x, isoSnappedGridPos.y); // If checkValidTowerPosition needs pixels
                    this.state.previewTower.position.x = snappedPixelPos.x + CONFIG.GRID_SIZE / 2;
                    this.state.previewTower.position.y = snappedPixelPos.y + CONFIG.GRID_SIZE / 2; // Adjust if centering needed
                    const isValidPosition = this.checkValidTowerPosition(snappedPixelPos.x, snappedPixelPos.y);
                    this.canvas.style.cursor = isValidPosition ? 'pointer' : 'not-allowed';
                }

                let hoveredTower = null;
                for (const tower of this.state.towers) {
                    const towerIso = translator.pixelToIso(tower.x, tower.y);
                    const dist = Math.hypot(towerIso.x - mouseX, towerIso.y + translator.tileHeight / 2 - mouseY);
                    if (dist < 20) {
                        hoveredTower = tower;
                        break;
                    }
                }

                if (hoveredTower) {
                    let info = `${hoveredTower.type} (Level ${hoveredTower.level})\n`;
                    info += `Damage: ${Math.round(hoveredTower.stats.damage * this.state.stats.damageMultiplier * 10) / 10}\n`;
                    info += `Attack Speed: ${Math.round(1000 / hoveredTower.stats.attackSpeed)} per sec\n`;
                    info += `Range: ${hoveredTower.stats.range}\n`;
                    info += `Crit Chance: ${Math.round(hoveredTower.stats.critChance * 100)}%\n`;
                    if (hoveredTower.stats.leech > 0) {
                        info += `Life Leech: ${Math.round(hoveredTower.stats.leech * 100 * this.state.stats.healingMultiplier) / 100} HP per hit\n`;
                    }
                    if (hoveredTower.stats.piercing > 0) {
                        info += `Piercing: ${hoveredTower.stats.piercing} enemies\n`;
                    }
                    if (hoveredTower.stats.summonChance > 0) {
                        info += `Summon Chance: ${Math.round(hoveredTower.stats.summonChance * 100)}%\n`;
                    }

                    this.showTooltip(e.clientX, e.clientY, info);
                    hoveredTower.showRange = true;
                } else {
                    this.hideTooltip();
                    this.state.towers.forEach(t => t.showRange = false);
                }
            });

            this.canvas.addEventListener('mouseout', () => {
                this.hideTooltip();
            });
            this.canvas.addEventListener('click', (e) => {
                if (!this.state.selectedTowerType) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Convert mouse (isometric pixel) to grid
                const gridPos = translator.isoToGrid(mouseX, mouseY);
                const snappedGrid = translator.snapToGrid(gridPos.x, gridPos.y);

                // Convert snapped grid back to isometric for preview
                const isoSnappedGridPos = translator.gridToIso(snappedGrid.x, snappedGrid.y); 
                const snappedPixelPos = translator.isoToPixel(isoSnappedGridPos.x, isoSnappedGridPos.y); // If checkValidTowerPosition needs pixels
                
                if (this.checkValidTowerPosition(snappedPixelPos.x + CONFIG.GRID_SIZE / 2, snappedPixelPos.y + CONFIG.GRID_SIZE / 2)) {
                    // Create the tower
                    let cost = gameConfig.towers[this.state.selectedTowerType].cost;
                    let populationCost = gameConfig.towers[this.state.selectedTowerType].population || 0;
                    
                    const finalCost = Math.floor(cost * this.state.stats.towerCostMod);
                    
                    if (this.state.bloodShards >= finalCost && this.state.stats.population + populationCost <= this.state.stats.maxPopulation) {
                        const tower = this.createTower(snappedPixelPos.x + CONFIG.GRID_SIZE / 2, snappedPixelPos.y + CONFIG.GRID_SIZE / 2, this.state.selectedTowerType);
                        tower.placed = true;
                        this.state.bloodShards -= finalCost;
                        this.state.previewTower.destroy();
                        this.state.previewTower = null;
                        // Clear selection
                        this.state.selectedTowerType = null;
                        this.canvas.style.cursor = 'default';
                    }
                }
            });
            
            // Cancel tower placement with right click
            this.canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (this.state.selectedTowerType) {
                    this.state.selectedTowerType = null;
                    this.canvas.style.cursor = 'default';
                }
            });
        }

        checkValidTowerPosition(posX, posY) {
            // Check if too close to path
            for (let i = 0; i < this.state.path.length - 1; i++) {
                const p1 = this.state.path[i];
                
                // Calculate distance from point to line segment
                const dist = Math.hypot(posX - p1.x, posY - p1.y);
                if (dist < CONFIG.GRID_SIZE) return false;
            }
            
            // Check if too close to other towers
            for (const tower of this.state.towers) {
                
                const towerGridPos = translator.isoToGrid(tower.position.x, tower.position.y);
                const dist = Math.hypot(towerGridPos.x - posX, towerGridPos.y - posY);
                if (dist < CONFIG.GRID_SIZE) return false;
            }
                    
            return true;
        }
        // Game-over and reset functions
        gameOver() {
            this.state.gameOver = true;
            this.state.isPaused = true;
            gameOverWave.textContent = this.state.wave;
            gameOverMenu.style.display = 'block';
            overlay.style.display = 'block';
        }

        gameVictory() {
            this.state.victory = true;
            this.state.isPaused = true;
            victoryMenu.style.display = 'block';
            overlay.style.display = 'block';
        }

        // Tooltip system
        showTooltip(x, y, text) {
            tooltip.style.display = 'block';
            tooltip.style.left = (x + 10) + 'px';
            tooltip.style.top = (y + 10) + 'px';
            tooltip.textContent = text;
        }

        hideTooltip() {
            tooltip.style.display = 'none';
        }

        // Game Loop
        update() {
            if (this.state.gameOver || this.state.victory || this.state.isLevelingUp) return;
            
            this.applyActiveUpgrades();
            this.state.entities.sort((a, b) => {
                return (b.position.y * CONFIG.COLS + b.position.x) - (a.position.y * CONFIG.COLS + a.position.x)
            });
            let entitiesToRemove = [];

            for( let i = this.state.entities.length - 1; i >= 0; i-- ) {
                let e = this.state.entities[i];
                let result = e.update();
                if( !result ) {               
                    this.state.entities.splice(i, 1);
                }
                e.draw();
            }   

            this.entitiesToAdd.forEach((entity) => this.state.addEntity(entity));
            this.entitiesToAdd = [];
            // Update wave status
            this.updateWave();
            // Level Up check
            if (this.state.essence >= this.state.essenceToNextLevel && !this.state.isLevelingUp) {
                this.showUpgradeMenu();
            }
            
            // Game over check
            if (this.state.bloodCoreHP <= 0 && !this.state.gameOver) {
                this.gameOver();
            }      
        }

        // Draw function
        draw() {
                    
            this.drawStats();  

            // Draw wave timer
            if (this.state.enemies.length === 0 && this.state.enemiesSpawned >= this.state.enemiesInWave && !this.state.victory) {
                const countdown = Math.ceil((this.state.waveDelay - this.state.waveTimer) / 60);
                this.ctx.fillStyle = 'white';
                this.ctx.font = '20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`Next Wave in ${countdown}...`, this.canvas.width / 2, 50);
            }
        }
        // Stats updating
        drawStats() {
            this.uiManager.shardsDisplay.textContent = Math.floor(this.state.bloodShards);
            this.uiManager.essenceDisplay.textContent = Math.floor(this.state.essence);
            this.uiManager.essenceNeededDisplay.textContent = Math.floor(this.state.essenceToNextLevel);
            this.uiManager.hpDisplay.textContent = Math.floor(this.state.bloodCoreHP);
            this.uiManager.populationDisplay.textContent = Math.floor(this.state.stats.population);
            this.uiManager.maxPopulationDisplay.textContent = Math.floor(this.state.stats.maxPopulation);     
        }
        // Drawing the path
        drawPath() {
            this.ctx.strokeStyle = 'rgba(100, 0, 0, 0.5)';
            this.ctx.lineWidth = 30;
            this.ctx.beginPath();
            this.ctx.moveTo(this.state.path[0].x, this.state.path[0].y);
            
            for (let i = 1; i < this.state.path.length; i++) {
                this.ctx.lineTo(this.state.path[i].x, this.state.path[i].y);
            }
            
            this.ctx.stroke();
            
            // Draw path borders
            this.ctx.strokeStyle = 'rgba(150, 0, 0, 0.7)';
            this.ctx.lineWidth = 2;
            
            this.ctx.beginPath();
            this.ctx.moveTo(this.state.path[0].x, this.state.path[0].y - 15);
            for (let i = 1; i < this.state.path.length; i++) {
                this.ctx.lineTo(this.state.path[i].x, this.state.path[i].y - 15);
            }
            this.ctx.stroke();
            
            this.ctx.beginPath();
            this.ctx.moveTo(this.state.path[0].x, this.state.path[0].y + 15);
            for (let i = 1; i < this.state.path.length; i++) {
                this.ctx.lineTo(this.state.path[i].x, this.state.this.state.path[i].y + 15);
            }
            this.ctx.stroke();
        }

        // Main Loop
        gameLoop() {
            this.mapRenderer.renderBG(this.state, { tileMap: this.state.tileMap, path: this.state.path });
            if (!this.state.isPaused) {
                this.update();
            } 
            this.mapRenderer.renderFG();
            this.draw();
        }

        addEntity(entity) {
            this.entitiesToAdd.push(entity);
        }
        // Initialize the game
        async init() {
            const { tileMap, path } = this.mapManager.generateMap();
            this.state.tileMap = tileMap;
            this.state.path = path;
            this.reset();            

            for(let objectType in gameConfig) {
                for(let object in gameConfig[objectType]) {
                    if(!gameConfig[objectType][object].render){
                        break;
                    }
                    await this.imageManager.loadImages(objectType, gameConfig[objectType]);
                }
            }
            game.gameInterval = setInterval(() => { game.gameLoop(); }, 10);
            this.state.isPaused = true;
            
            this.setupTowerPlacement();
            this.drawStats();
        }
        isPositionInCorner(x, y, cols, rows) {
            // Convert grid coordinates to relative positions (0 to 1 range)
            const relX = x / cols;
            const relY = y / rows;
            
            // In an isometric view, the diamond shape is defined by:
            // Top corner: (0.5, 0)
            // Right corner: (1, 0.5)
            // Bottom corner: (0.5, 1)
            // Left corner: (0, 0.5)
            
            // Calculate distance from the center line of the diamond
            const distFromDiagonal1 = Math.abs(relX + relY - 1);
            const distFromDiagonal2 = Math.abs(relX - relY);
            
            // If the point is far from both diagonals, it's in a corner
            const cornerThreshold = 0.2; // Adjust this value to control how much of the corners to fill
            return distFromDiagonal1 > cornerThreshold || distFromDiagonal2 > cornerThreshold;
        }
        reset() { 
            this.state.reset();
            this.uiManager.reset();
        }
        createProjectile(type, x, y, target, damage, isCritical, owner) {
            let ownerStats = owner.getComponent('stats').stats;
            let def = gameConfig.projectiles[type];
            let stats = {            
                speed: 5,
                damage: damage,
                isCritical: isCritical,
                piercing: ownerStats.piercing || 0,
                splashRadius: ownerStats.splashRadius || 0
            };

            let entity = new Entity(this, x, y);
            entity.addComponent(Stats, type, stats);
            if( def.customRenderer == "lightning" ) {
                entity.addRenderer(LightningRenderer, ownerStats);
                entity.addComponent(ChainProjectile, type, owner, target, stats );
            } else {
                entity.addRenderer(Renderer, this.imageManager.getImages("projectiles", type), 0);
                entity.addComponent(Projectile, type, owner, target, stats );
            }
            this.addEntity(entity);     
        }
        createTower(x, y, type, tracker="towers") {
            let stats = gameConfig.towers[type];
            let entity = new Entity(this, x, y);
            entity.addRenderer(Renderer, this.imageManager.getImages("towers", type), stats.drawOffsetY ? stats.drawOffsetY : 0 );
            entity.addComponent(Stats, type, stats);
            entity.addComponent(Leveler);
            entity.addComponent(Buildable);
            entity.addComponent(PopulationBurden);
            entity.addComponent(Attacker);
            entity.addRenderer(RangeIndicator);
            entity.addComponent(ArrayTracker, tracker);
            
            this.addEntity(entity);      
            return entity;  
        }
        createPreviewTower(x, y, type) {
            let stats = gameConfig.towers[type];
            let entity = new Entity(this, x, y);
            entity.addRenderer(Renderer, this.imageManager.getImages("towers", type),  stats.drawOffsetY ? stats.drawOffsetY : 0);
            entity.addRenderer(RangeIndicator);
            entity.addComponent(Stats, type, stats);
            entity.addComponent(Buildable);
            
            this.addEntity(entity);        
            return entity;
        }
        removeSummon(summon) {
            this.state.removeEntity(summon);
        }
        createSummon(x, y, type) {
            let stats = gameConfig.towers[type];
            let summon = this.createTower(x, y, type);
            summon.addComponent(LifeSpan, stats.lifeSpan);
        }
        createEnemy(spawnType = "") {        
            let normalTypes = [];
            let bossTypes = [];
            for(let type in gameConfig.enemies) {
                if(gameConfig.enemies[type].boss) {
                    bossTypes.push(type);
                } else {
                    normalTypes.push(type);
                }
            }

            let allTypes = {
                normal: normalTypes,
                boss: bossTypes
            }
            let typeArr = allTypes[spawnType];
            if(!typeArr) typeArr = allTypes.normal;    
            let type = typeArr[Math.floor(Math.random() * typeArr.length)];
         

            let stats = gameConfig.enemies[type];
            stats.hp *= 1 + (.01 * this.state.wave);
            let entity = new Entity(this, 0, 0);
            entity.addRenderer(Renderer, this.imageManager.getImages("enemies", type), stats.drawOffsetY ? stats.drawOffsetY : 0 );
            entity.addComponent(Stats, type, stats);
            entity.addRenderer(Health);
            entity.addComponent(EssenceBounty);
            entity.addComponent(FollowPath);
            entity.addComponent(SpacialGridEntity);
            entity.addComponent(ArrayTracker, "enemies");
            this.addEntity(entity);
        }
        
        createEnvironmentObject(x, y, type, tracker="environment") {
            let stats = gameConfig.environment[type];
            let entity = new Entity(this, x, y);
            entity.addRenderer(Renderer, this.imageManager.getImages("environment", type), stats.drawOffsetY ? stats.drawOffsetY : 0 );
            entity.addComponent(Stats, type, stats);
            entity.addComponent(ArrayTracker, tracker);            
            this.addEntity(entity);      
            return entity;  
        }
        createHitEffect(x, y, damageType = "default") {
            let entity = new Entity(this, x, y);
            entity.addRenderer(HitEffectRenderer, null, 0);
            entity.addComponent(HitEffectParticle, damageType);
            entity.addComponent(LifeSpan, 30); // ~0.5 seconds at 60 FPS
            this.addEntity(entity);
        }
        applyUpgrade(upgradeId) {
            const upgrade = upgrades.find(u => u.id === upgradeId);
            if (upgrade && upgrade.canApply(this.state)) {
                upgrade.apply(this.state);
                this.uiManager.updateUpgrades(); // Hypothetical UI update
            }
        }
    }

    const translator = new CoordinateTranslator(CONFIG);
    const gameConfig = {
        projectiles: {
            plasmaBolt: { hitEffectType: 'plasma', render: {"shapes":[{"type":"sphere","size":6,"x":0,"y":24,"z":0,"rotationX":90,"color":"#ee6060"}]} },
            nanoOrb: { render: {"shapes":[{"type":"sphere","size":6,"x":0,"y":5,"z":0,"rotationX":90,"color":"#ee6060"}]} },
            neutronFragment: { render: {"shapes":[{"type":"sphere","size":6,"x":0,"y":25,"z":0,"rotationX":90,"color":"#ee6060"}]} },
            missile: { hitEffectType: 'fire', render: {"shapes":[{"type":"cylinder","size":5,"color":"#888888","x":0,"y":24,"z":-1.3812500000000014,"rotationX":90,"rotationY":0,"rotationZ":0,"height":25},{"type":"cone","size":5,"color":"#ff1117","x":0,"y":24,"z":13.618749999999999,"rotationX":90,"rotationY":0,"rotationZ":0,"height":5},{"type":"cone","size":2.5,"color":"#ff1117","x":0,"y":24,"z":-13.881250000000001,"rotationX":90,"rotationY":0,"rotationZ":0,"height":2.5},{"type":"cylinder","size":6.25,"color":"#888888","x":0,"y":24,"z":-11.131250000000001,"rotationX":90,"rotationY":0,"rotationZ":0,"height":5},{"type":"box","size":5,"color":"#888888","x":0,"y":27,"z":-11.631250000000001,"rotationX":45,"rotationY":0,"rotationZ":0,"width":0.25,"height":2.5,"depth":8.5},{"type":"box","size":5,"color":"#888888","x":0,"y":21,"z":-11.631250000000001,"rotationX":-45,"rotationY":0,"rotationZ":0,"width":0.25,"height":2.5,"depth":8.5},{"type":"box","size":5,"color":"#888888","x":-3,"y":24,"z":-11.631250000000001,"rotationX":0,"rotationY":45,"rotationZ":90,"width":0.25,"height":2.5,"depth":8.5},{"type":"box","size":5,"color":"#888888","x":3,"y":24,"z":-11.631250000000001,"rotationX":0,"rotationY":-45,"rotationZ":-90,"width":0.25,"height":2.5,"depth":8.5}]} },
            cryoMist: {  hitEffectType: 'ice', render: {"shapes":[{"type":"sphere","size":6,"x":0,"y":25,"z":0,"rotationX":90,"color":"#6060ee"}]} },
            lightning: { customRenderer: 'lightning', hitEffectType: 'electric' },
        },
        towers: 
        {
            keep: { title: 'Citadel', mineAmt: 1, attackSpeed: 50, render: {"shapes":[{"type":"box","width":40,"height":12,"depth":40,"color":"#8B8B8B","x":0,"y":6,"z":0},{"type":"box","width":32,"height":20,"depth":32,"color":"#A0A0A0","x":0,"y":22,"z":0},{"type":"sphere","width":24,"height":16,"depth":24,"color":"#C0C0C0","x":0,"y":32,"z":0,"size":24},{"type":"cylinder","size":12,"height":22,"color":"#D8D8D8","x":0,"y":42,"z":0},{"type":"cone","size":14,"height":20,"color":"#4169E1","x":0,"y":62,"z":0},{"type":"cylinder","size":6,"height":30,"color":"#C0C0C0","x":16,"y":22,"z":16},{"type":"cylinder","size":6,"height":30,"color":"#C0C0C0","x":-16,"y":22,"z":16},{"type":"cylinder","size":6,"height":30,"color":"#C0C0C0","x":16,"y":22,"z":-16},{"type":"cylinder","size":6,"height":30,"color":"#C0C0C0","x":-16,"y":22,"z":-16},{"type":"cone","size":8,"height":10,"color":"#4169E1","x":16,"y":42,"z":16},{"type":"cone","size":8,"height":10,"color":"#4169E1","x":-16,"y":42,"z":16},{"type":"cone","size":8,"height":10,"color":"#4169E1","x":16,"y":42,"z":-16},{"type":"cone","size":8,"height":10,"color":"#4169E1","x":-16,"y":42,"z":-16},{"type":"box","width":44,"height":4,"depth":44,"color":"#696969","x":0,"y":2,"z":0}]} },
            sentry: { title: 'Photon Sentry', info: 'Defensive attack sentry.', cost: 25, population: 1, range: 120, damage: 2, attackSpeed: 20, projectile: 'plasmaBolt', critChance: 0.05, critMultiplier: 1.5, render: {"shapes":[{"type":"cylinder","size":12,"height":4,"color":"#696969","x":0,"y":0,"z":0},{"type":"cylinder","size":10,"height":26,"color":"#8B8B8B","x":0,"y":15,"z":0},{"type":"cylinder","size":12,"height":4,"color":"#696969","x":0,"y":30,"z":0},{"type":"cylinder","size":6,"height":14,"color":"#A9A9A9","x":0,"y":38,"z":0},{"type":"sphere","size":8,"color":"#CD7F32","x":0,"y":38,"z":0},{"type":"cylinder","size":2,"height":12,"color":"#A9A9A9","x":0,"y":40,"z":0,"rotationX":90},{"type":"sphere","size":3,"color":"#FF4500","x":0,"y":40,"z":6},{"type":"box","width":3,"height":5,"depth":3,"color":"#696969","x":4,"y":32,"z":4},{"type":"box","width":3,"height":5,"depth":3,"color":"#696969","x":-4,"y":32,"z":4},{"type":"box","width":3,"height":5,"depth":3,"color":"#696969","x":4,"y":32,"z":-4},{"type":"box","width":3,"height":5,"depth":3,"color":"#696969","x":-4,"y":32,"z":-4}]} },
            fusionCore: { title: 'Fusion Core', info: 'Creates additional energy every second.', cost: 50, population: 1, attackSpeed: 50, critMultiplier: 1, mineAmt: 1, render: {"shapes":[{"type":"cylinder","size":24,"height":8,"color":"#3A3A3A","x":0,"y":0,"z":0},{"type":"cylinder","size":20,"height":12,"color":"#555555","x":0,"y":10,"z":0},{"type":"sphere","size":14,"color":"#4B0082","x":0,"y":22,"z":0},{"type":"torus","size":22,"tubeSize":2,"color":"#00BFFF","x":0,"y":22,"z":0,"rotationX":30},{"type":"torus","size":22,"tubeSize":2,"color":"#00BFFF","x":0,"y":22,"z":0,"rotationX":105,"rotationZ":45},{"type":"cylinder","size":4,"height":10,"color":"#666666","x":12,"y":6,"z":12},{"type":"cylinder","size":4,"height":10,"color":"#666666","x":-12,"y":6,"z":12},{"type":"cylinder","size":4,"height":10,"color":"#666666","x":12,"y":6,"z":-12},{"type":"cylinder","size":4,"height":10,"color":"#666666","x":-12,"y":6,"z":-12},{"type":"box","width":8,"height":4,"depth":8,"color":"#555555","x":16,"y":2,"z":0},{"type":"box","width":8,"height":4,"depth":8,"color":"#555555","x":-16,"y":2,"z":0},{"type":"box","width":8,"height":4,"depth":8,"color":"#555555","x":0,"y":2,"z":16},{"type":"box","width":8,"height":4,"depth":8,"color":"#555555","x":0,"y":2,"z":-16},{"type":"sphere","size":3,"color":"#00FFFF","x":12,"y":12,"z":12},{"type":"sphere","size":3,"color":"#00FFFF","x":-12,"y":12,"z":12},{"type":"sphere","size":3,"color":"#00FFFF","x":12,"y":12,"z":-12},{"type":"sphere","size":3,"color":"#00FFFF","x":-12,"y":12,"z":-12}]} },
            barracks: { title: 'Barracks', info: 'Provides 5 additional max population.', cost: 100, attackSpeed: 1000, critChance: 0.1, critMultiplier: 2, supply: 5, render: {"shapes":[{"type":"box","width":40,"height":4,"depth":40,"color":"#303040","x":0,"y":2,"z":0},{"type":"box","width":36,"height":12,"depth":36,"color":"#404050","x":0,"y":10,"z":0},{"type":"box","width":40,"height":2,"depth":40,"color":"#505060","x":0,"y":17,"z":0},{"type":"cylinder","size":12,"height":12,"color":"#2288cc","x":-16,"y":24,"z":0},{"type":"torus","size":12,"tubeSize":1,"color":"#44aaff","x":-16,"y":24,"z":0,"rotationX":90},{"type":"torus","size":12,"tubeSize":1,"color":"#44aaff","x":-16,"y":28,"z":0,"rotationX":90},{"type":"torus","size":12,"tubeSize":1,"color":"#44aaff","x":-16,"y":20,"z":0,"rotationX":90},{"type":"cylinder","size":12,"height":12,"color":"#2288cc","x":16,"y":24,"z":0},{"type":"torus","size":12,"tubeSize":1,"color":"#44aaff","x":16,"y":24,"z":0,"rotationX":90},{"type":"torus","size":12,"tubeSize":1,"color":"#44aaff","x":16,"y":28,"z":0,"rotationX":90},{"type":"torus","size":12,"tubeSize":1,"color":"#44aaff","x":16,"y":20,"z":0,"rotationX":90},{"type":"cylinder","size":16,"height":6,"color":"#333333","x":0,"y":20,"z":0},{"type":"cylinder","size":14,"height":2,"color":"#444444","x":0,"y":24,"z":0},{"type":"cylinder","size":12,"height":2,"color":"#2288cc","x":0,"y":26,"z":0},{"type":"box","width":6,"height":6,"depth":6,"color":"#cc2200","x":-14,"y":9,"z":-14},{"type":"box","width":6,"height":6,"depth":6,"color":"#cc6600","x":0,"y":9,"z":-14},{"type":"box","width":6,"height":6,"depth":6,"color":"#ccaa00","x":14,"y":9,"z":-14},{"type":"sphere","size":3,"color":"#44aaff","x":0,"y":28,"z":0},{"type":"box","width":40,"height":1,"depth":24,"color":"#444455","x":0,"y":18.5,"z":0},{"type":"cylinder","size":2,"height":4,"color":"#aa0000","x":-18,"y":20.5,"z":-8},{"type":"cylinder","size":2,"height":4,"color":"#aa0000","x":18,"y":20.5,"z":-8},{"type":"cylinder","size":2,"height":4,"color":"#aa0000","x":-18,"y":20.5,"z":8},{"type":"cylinder","size":2,"height":4,"color":"#aa0000","x":18,"y":20.5,"z":8}]} },
            fabricator: { title: 'Fabricator', info: 'Can be upgraded to summon drones from defeated enemies.', summonType: 'drone', cost: 200, population: 4, range: 150, damage: 8, attackSpeed: 30, projectile: 'nanoOrb', piercing: 1, critChance: 0.15, critMultiplier: 1.8, render: {"shapes":[{"type":"box","width":40,"height":6,"depth":40,"x":0,"y":3,"z":0,"color":"#303030"},{"type":"cylinder","size":36,"height":14,"x":0,"y":13,"z":0,"color":"#505050"},{"type":"cylinder","size":28,"height":4,"x":0,"y":22,"z":0,"color":"#202020"},{"type":"cylinder","size":24,"height":16,"x":0,"y":32,"z":0,"color":"#404040"},{"type":"torus","size":20,"tubeSize":2,"x":0,"y":26,"z":0,"color":"#00FFAA"},{"type":"sphere","size":14,"x":0,"y":32,"z":0,"color":"#80FFD0"},{"type":"box","width":6,"height":28,"depth":6,"x":16,"y":22,"z":16,"color":"#303030"},{"type":"box","width":6,"height":28,"depth":6,"x":-16,"y":22,"z":16,"color":"#303030"},{"type":"box","width":6,"height":28,"depth":6,"x":16,"y":22,"z":-16,"color":"#303030"},{"type":"box","width":6,"height":28,"depth":6,"x":-16,"y":22,"z":-16,"color":"#303030"},{"type":"sphere","size":4,"x":16,"y":38,"z":16,"color":"#00FFAA"},{"type":"sphere","size":4,"x":-16,"y":38,"z":16,"color":"#00FFAA"},{"type":"sphere","size":4,"x":16,"y":38,"z":-16,"color":"#00FFAA"},{"type":"sphere","size":4,"x":-16,"y":38,"z":-16,"color":"#00FFAA"},{"type":"cylinder","size":10,"height":4,"x":0,"y":42,"z":0,"color":"#606060"},{"type":"cylinder","size":6,"height":8,"x":0,"y":48,"z":0,"color":"#505050"},{"type":"torus","size":8,"tubeSize":1,"x":0,"y":46,"z":0,"rotationX":90,"color":"#00FFAA"},{"type":"torus","size":4,"tubeSize":1,"x":0,"y":32,"z":0,"rotationX":30,"rotationY":45,"color":"#00FFFF"},{"type":"torus","size":4,"tubeSize":1,"x":0,"y":32,"z":0,"rotationX":120,"rotationY":45,"color":"#00FFFF"},{"type":"sphere","size":2,"x":6,"y":32,"z":0,"color":"#FFFFFF"},{"type":"sphere","size":2,"x":-6,"y":32,"z":0,"color":"#FFFFFF"},{"type":"sphere","size":2,"x":0,"y":32,"z":6,"color":"#FFFFFF"},{"type":"sphere","size":2,"x":0,"y":32,"z":-6,"color":"#FFFFFF"}]} },
            drone: { title: 'Drone', info: 'Raise the dead.', drawOffsetY: -12, population: 1, range: 80, damage: 5, attackSpeed: 30, projectile: 'neutronFragment', critMultiplier: 1, lifeSpan: 500, render: {"shapes":[{"type":"sphere","size":10,"x":0,"y":10,"z":0,"color":"#3D3D3D"},{"type":"torus","size":12,"tubeSize":2,"x":0,"y":10,"z":0,"rotationX":90,"color":"#00FFAA"},{"type":"torus","size":12,"tubeSize":2,"x":0,"y":10,"z":0,"rotationY":90,"color":"#00FFAA"},{"type":"cylinder","size":4,"height":2,"x":0,"y":16,"z":0,"color":"#505050"},{"type":"sphere","size":3,"x":0,"y":18,"z":0,"color":"#00FFDD"},{"type":"cylinder","size":16,"height":1,"x":0,"y":8,"z":0,"rotationX":90,"rotationY":0,"color":"#404040"},{"type":"cylinder","size":16,"height":1,"x":0,"y":8,"z":0,"rotationX":90,"rotationY":90,"color":"#404040"},{"type":"cylinder","size":4,"height":1,"x":14,"y":8,"z":14,"color":"#505050"},{"type":"cylinder","size":4,"height":1,"x":-14,"y":8,"z":14,"color":"#505050"},{"type":"cylinder","size":4,"height":1,"x":14,"y":8,"z":-14,"color":"#505050"},{"type":"cylinder","size":4,"height":1,"x":-14,"y":8,"z":-14,"color":"#505050"},{"type":"torus","size":6,"tubeSize":1,"x":14,"y":9,"z":14,"rotationX":90,"color":"#00FFAA"},{"type":"torus","size":6,"tubeSize":1,"x":-14,"y":9,"z":14,"rotationX":90,"color":"#00FFAA"},{"type":"torus","size":6,"tubeSize":1,"x":14,"y":9,"z":-14,"rotationX":90,"color":"#00FFAA"},{"type":"torus","size":6,"tubeSize":1,"x":-14,"y":9,"z":-14,"rotationX":90,"color":"#00FFAA"},{"type":"cylinder","size":1,"height":4,"x":0,"y":6,"z":0,"color":"#00FFDD"},{"type":"sphere","size":2,"x":0,"y":4,"z":0,"color":"#00FFAA"},{"type":"sphere","size":1,"x":5,"y":10,"z":0,"color":"#FFFFFF"},{"type":"sphere","size":1,"x":-5,"y":10,"z":0,"color":"#FFFFFF"},{"type":"sphere","size":1,"x":0,"y":10,"z":5,"color":"#FFFFFF"},{"type":"sphere","size":1,"x":0,"y":10,"z":-5,"color":"#FFFFFF"}]} },
            teslaCoil: { title: 'Tesla Coil', info: 'Projectiles chain between enemies.', projectileStartOffsetY: 24, cost: 70, population: 3, range: 100, damage: 10, attackSpeed: 25, projectile: 'lightning', piercing: 2, critChance: 0.1, critMultiplier: 1.7, render: {"shapes":[{"type":"cylinder","size":16,"height":4,"color":"#555555","x":0,"y":2,"z":0},{"type":"cylinder","size":12,"height":8,"color":"#777777","x":0,"y":8,"z":0},{"type":"cylinder","size":10,"height":20,"color":"#333333","x":0,"y":22,"z":0},{"type":"cylinder","size":12,"height":3,"color":"#444444","x":0,"y":33.5,"z":0},{"type":"sphere","size":14,"color":"#66bbff","x":0,"y":42,"z":0},{"type":"torus","size":20,"tubeSize":1.6,"color":"#66bbff","x":0,"y":18,"z":0,"rotationX":90},{"type":"torus","size":18,"tubeSize":1.6,"color":"#4499ff","x":0,"y":24,"z":0,"rotationX":90},{"type":"torus","size":16,"tubeSize":1.6,"color":"#2277ff","x":0,"y":30,"z":0,"rotationX":90},{"type":"cone","size":6,"height":16,"color":"#888888","x":7,"y":34,"z":0,"rotationZ":-90},{"type":"cone","size":6,"height":16,"color":"#888888","x":-7,"y":34,"z":0,"rotationZ":90},{"type":"cone","size":6,"height":16,"color":"#888888","x":0,"y":34,"z":7,"rotationX":90},{"type":"cone","size":6,"height":16,"color":"#888888","x":0,"y":34,"z":-7,"rotationX":-90},{"type":"box","width":3,"height":14,"depth":3,"color":"#888888","x":6,"y":16,"z":6,"rotationY":45},{"type":"box","width":3,"height":14,"depth":3,"color":"#888888","x":-6,"y":16,"z":6,"rotationY":-45},{"type":"box","width":3,"height":14,"depth":3,"color":"#888888","x":6,"y":16,"z":-6,"rotationY":-45},{"type":"box","width":3,"height":14,"depth":3,"color":"#888888","x":-6,"y":16,"z":-6,"rotationY":45},{"type":"cylinder","size":2,"height":1,"color":"#66bbff","x":0,"y":36,"z":0}]} },
            missileLauncher: { title: 'Missile Launcher', info: 'Projectiles explode in an AoE.', cost: 90, population: 3, range: 90, damage: 6, attackSpeed: 35, projectile: 'missile', critChance: 0.05, critMultiplier: 2, splashRadius: 45, burnDamage: 2, render: {"shapes":[{"type":"box","width":40,"height":8,"depth":40,"x":0,"y":4,"z":0,"color":"#555555"},{"type":"cylinder","size":32,"height":10,"x":0,"y":13,"z":0,"color":"#444444"},{"type":"box","width":24,"height":14,"depth":30,"x":0,"y":25,"z":0,"color":"#3A3A3A"},{"type":"cylinder","size":8,"height":34,"x":-8,"y":30,"z":8,"rotationX":90,"color":"#2A2A2A"},{"type":"cylinder","size":8,"height":34,"x":8,"y":30,"z":8,"rotationX":90,"color":"#2A2A2A"},{"type":"cylinder","size":6,"height":18,"x":-8,"y":30,"z":-6,"rotationX":90,"color":"#7f7f7f"},{"type":"cylinder","size":6,"height":18,"x":8,"y":30,"z":-6,"rotationX":90,"color":"#7f7f7f"},{"type":"cone","size":6,"height":8,"x":-8,"y":30,"z":-18,"rotationX":-90,"color":"#D14A4A"},{"type":"cone","size":6,"height":8,"x":8,"y":30,"z":-18,"rotationX":-90,"color":"#D14A4A"}]} },
            chrono: { title: 'Chrono Defibrilator', info: 'Projectiles explode in AoE and slow.', cost: 100, population: 3, range: 90, damage: 2, attackSpeed: 50, projectile: 'cryoMist', critMultiplier: 1, splashRadius: 30, slowEffect: 0.7, render: {"shapes":[{"type":"torus","size":36,"tubeSize":4,"x":0,"y":16,"z":0,"rotationX":60,"color":"#50D0FF"},{"type":"torus","size":36,"tubeSize":4,"x":0,"y":16,"z":0,"rotationY":60,"color":"#50D0FF"},{"type":"cylinder","size":22,"height":10,"x":0,"y":5,"z":0,"color":"#333333"},{"type":"cylinder","size":16,"height":14,"x":0,"y":17,"z":0,"color":"#222222"},{"type":"sphere","size":12,"x":0,"y":16,"z":0,"color":"#A0E6FF"},{"type":"tetrahedron","size":10,"x":0,"y":16,"z":0,"rotationY":45,"color":"#203040"},{"type":"cone","size":8,"height":16,"x":0,"y":32,"z":0,"rotationX":180,"color":"#444444"},{"type":"box","width":38,"height":4,"depth":38,"x":0,"y":2,"z":0,"color":"#555555"},{"type":"sphere","size":4,"x":14,"y":12,"z":14,"color":"#C0FFFF"},{"type":"sphere","size":4,"x":-14,"y":12,"z":14,"color":"#C0FFFF"},{"type":"sphere","size":4,"x":14,"y":12,"z":-14,"color":"#C0FFFF"},{"type":"sphere","size":4,"x":-14,"y":12,"z":-14,"color":"#C0FFFF"}]} },
        },
        enemies:  {
            zombie: { hp: 30, speed: 0.8, value: 5, essence: 10, render: {"shapes":[{"type":"sphere","size":16,"color":"#60A060","x":0,"y":43,"z":0},{"type":"cylinder","width":20,"height":24,"depth":10,"color":"#506050","x":0,"y":24,"z":0,"size":16},{"type":"sphere","size":5,"color":"#FFFFFF","x":4,"y":45,"z":7},{"type":"sphere","size":5,"color":"#FFFFFF","x":-4,"y":45,"z":7},{"type":"sphere","size":2,"color":"#000000","x":4,"y":45,"z":9},{"type":"sphere","size":2,"color":"#000000","x":-4,"y":45,"z":9},{"type":"cylinder","size":4,"height":20,"color":"#60A060","x":8,"y":29,"z":10,"rotationX":90,"rotationZ":15},{"type":"cylinder","size":4,"height":20,"color":"#60A060","x":-8,"y":29,"z":10,"rotationX":90,"rotationZ":-15},{"type":"cylinder","size":4,"height":24,"color":"#60A060","x":5,"y":12,"z":0,"rotationZ":0},{"type":"cylinder","size":4,"height":24,"color":"#60A060","x":-5,"y":12,"z":0,"rotationZ":0,"rotationX":0}]} },
            skeleton: { hp: 20, speed: 1.2, value: 7, essence: 12, render: {"shapes":[{"type":"sphere","size":14,"color":"#E0DED8","x":0,"y":40,"z":0},{"type":"box","width":16,"height":20,"depth":8,"color":"#CFCBC0","x":0,"y":24,"z":0},{"type":"sphere","size":3,"color":"#000000","x":4,"y":41,"z":5},{"type":"sphere","size":3,"color":"#000000","x":-4,"y":41,"z":5},{"type":"cylinder","size":3,"height":18,"color":"#E0DED8","x":8,"y":29,"z":10,"rotationX":90,"rotationZ":15},{"type":"cylinder","size":3,"height":18,"color":"#E0DED8","x":-8,"y":29,"z":10,"rotationX":90,"rotationZ":-15},{"type":"sphere","size":5,"color":"#E0DED8","x":6,"y":29,"z":20},{"type":"sphere","size":5,"color":"#E0DED8","x":-6,"y":29,"z":20},{"type":"cylinder","size":3,"height":22,"color":"#E0DED8","x":5,"y":14,"z":0,"rotationZ":0},{"type":"cylinder","size":3,"height":22,"color":"#E0DED8","x":-5,"y":14,"z":0,"rotationZ":0},{"type":"sphere","size":5,"color":"#E0DED8","x":5,"y":2,"z":0},{"type":"sphere","size":5,"color":"#E0DED8","x":-5,"y":2,"z":0}]} },
            ghost: { hp: 15, speed: 1.5, value: 10, essence: 15, render: {"shapes":[{"type":"sphere","size":16,"color":"#C2E8F7","x":0,"y":31,"z":0},{"type":"sphere","size":14,"color":"#D8F0F9","x":0,"y":21,"z":0},{"type":"sphere","size":12,"color":"#E5F6FC","x":0,"y":11,"z":0},{"type":"cone","size":8,"height":14,"color":"#E5F6FC","x":6,"y":6,"z":0,"rotationX":180},{"type":"cone","size":8,"height":14,"color":"#E5F6FC","x":-6,"y":6,"z":0,"rotationX":180},{"type":"cone","size":8,"height":14,"color":"#E5F6FC","x":0,"y":6,"z":0,"rotationX":180},{"type":"sphere","size":4,"color":"#1A1A1A","x":4,"y":31,"z":7},{"type":"sphere","size":4,"color":"#1A1A1A","x":-4,"y":31,"z":7},{"type":"sphere","size":8,"color":"#1A1A1A","x":0,"y":28,"z":4,"rotationX":45,"rotationY":0,"rotationZ":0}]} },
            wraith: { hp: 25, speed: 1.8, value: 12, essence: 18, dodgeChance: 0.2, render: {"shapes":[{"type":"sphere","size":16,"color":"#3A6A8A","x":0,"y":24,"z":0},{"type":"sphere","size":8,"color":"#FFFFFF","x":0,"y":24,"z":6},{"type":"sphere","size":4,"color":"#000000","x":0,"y":24,"z":8.5},{"type":"cylinder","size":6,"height":4,"color":"#2A5A7A","x":-8,"y":22,"z":0,"rotationZ":30},{"type":"cylinder","size":6,"height":4,"color":"#2A5A7A","x":8,"y":22,"z":0,"rotationZ":-30}]} },
            bloodBeast: { hp: 50, speed: 0.6, value: 15, essence: 20, regen: 0.5, render: {"shapes":[{"type":"sphere","width":26,"height":20,"depth":24,"color":"#A52A2A","x":0,"y":20,"z":0,"size":28},{"type":"sphere","size":18,"color":"#A52A2A","x":0,"y":36,"z":0},{"type":"cylinder","size":8,"height":14,"color":"#8B4513","x":16,"y":24,"z":0,"rotationZ":45},{"type":"cylinder","size":8,"height":14,"color":"#8B4513","x":-16,"y":24,"z":0,"rotationZ":-45},{"type":"sphere","size":9,"color":"#A52A2A","x":22,"y":18,"z":0},{"type":"sphere","size":9,"color":"#A52A2A","x":-22,"y":18,"z":0},{"type":"cylinder","size":8,"height":16,"color":"#8B4513","x":10,"y":8,"z":0,"rotationZ":0},{"type":"cylinder","size":8,"height":16,"color":"#8B4513","x":-10,"y":8,"z":0,"rotationZ":0},{"type":"sphere","size":6,"color":"#FFFFFF","x":5,"y":38,"z":8},{"type":"sphere","size":6,"color":"#FFFFFF","x":-5,"y":38,"z":8},{"type":"sphere","size":3,"color":"#000000","x":5,"y":38,"z":10},{"type":"sphere","size":3,"color":"#000000","x":-5,"y":38,"z":10},{"type":"cone","size":6,"height":12,"color":"#8B4513","x":-10,"y":42,"z":0,"rotationZ":45},{"type":"cone","size":6,"height":12,"color":"#8B4513","x":10,"y":42,"z":0,"rotationZ":-45}]} },
            banshee: { hp: 20, speed: 1.4, value: 8, essence: 14, screamDamage: 5, render: {"shapes":[{"type":"sphere","size":12,"color":"#BCA9DF","x":0,"y":36,"z":2},{"type":"cone","size":16,"height":30,"color":"#9F8AC7","x":0,"y":18,"z":0,"rotationX":180},{"type":"sphere","size":4,"color":"#FF3366","x":4,"y":36,"z":7},{"type":"sphere","size":4,"color":"#FF3366","x":-4,"y":36,"z":7},{"type":"cylinder","size":3,"height":16,"color":"#BCA9DF","x":-8,"y":28,"z":10,"rotationX":90,"rotationZ":30},{"type":"cylinder","size":3,"height":16,"color":"#BCA9DF","x":8,"y":28,"z":10,"rotationX":90,"rotationZ":-30},{"type":"cylinder","size":2,"height":12,"color":"#BCA9DF","x":3,"y":33,"z":-10,"rotationX":-40},{"type":"cylinder","size":2,"height":12,"color":"#BCA9DF","x":-3,"y":33,"z":-10,"rotationX":-40},{"type":"sphere","size":6,"color":"#000000","x":0,"y":32,"z":7.8,"rotationX":45},{"type":"sphere","size":6,"color":"#BCA9DF","x":15,"y":18,"z":0},{"type":"sphere","size":6,"color":"#BCA9DF","x":-15,"y":18,"z":0},{"type":"sphere","size":6,"color":"#BCA9DF","x":0,"y":18,"z":-15}]} },
            trex: { info: 'T-Rex', hp: 40, speed: 1.5, value: 10, essence: 15, render: {"shapes":[{"type":"box","width":12,"height":25,"depth":12,"x":0,"y":22.6,"z":-2.6,"rotationX":46,"color":"#5D8233"},{"type":"box","width":12,"height":10,"depth":16,"x":0,"y":37,"z":12,"color":"#5D8233"},{"type":"box","width":10,"height":4,"depth":14,"x":0,"y":29,"z":14,"color":"#4E6C2A"},{"type":"box","width":8,"height":1,"depth":1,"x":0,"y":31,"z":20,"color":"#FFFFFF"},{"type":"box","width":1,"height":2,"depth":1,"x":-3,"y":31,"z":20,"color":"#FFFFFF"},{"type":"box","width":1,"height":2,"depth":1,"x":0,"y":31,"z":20,"color":"#FFFFFF"},{"type":"box","width":1,"height":2,"depth":1,"x":3,"y":31,"z":20,"color":"#FFFFFF"},{"type":"sphere","size":3,"x":-7,"y":42,"z":14,"color":"#FFFF00"},{"type":"sphere","size":1.5,"x":-7,"y":42,"z":15,"color":"#000000"},{"type":"sphere","size":3,"x":7,"y":42,"z":14,"color":"#FFFF00"},{"type":"sphere","size":1.5,"x":7,"y":42,"z":15,"color":"#000000"},{"type":"box","width":6,"height":4,"depth":14,"x":0,"y":18,"z":-17.9,"rotationX":-20,"color":"#5D8233"},{"type":"box","width":4,"height":3,"depth":10,"x":0,"y":15,"z":-30,"rotationX":-10,"color":"#5D8233"},{"type":"box","width":5,"height":16,"depth":5,"x":6,"y":10,"z":0,"color":"#4E6C2A"},{"type":"box","width":5,"height":16,"depth":5,"x":-6,"y":10,"z":0,"color":"#4E6C2A"},{"type":"box","width":7,"height":2,"depth":9,"x":6,"y":1,"z":0,"color":"#4E6C2A"},{"type":"box","width":7,"height":2,"depth":9,"x":-6,"y":1,"z":0,"color":"#4E6C2A"},{"type":"box","width":3,"height":5,"depth":3,"x":8,"y":26,"z":0,"rotationX":-40,"color":"#4E6C2A"},{"type":"box","width":3,"height":5,"depth":3,"x":-8,"y":26,"z":0,"rotationX":-40,"color":"#4E6C2A"},{"type":"box","width":2,"height":2,"depth":1,"x":8,"y":24,"z":3,"color":"#A0A0A0"},{"type":"box","width":2,"height":2,"depth":1,"x":-8,"y":24,"z":3,"color":"#A0A0A0"},{"type":"cone","size":4,"height":6,"x":0,"y":35,"z":-2,"rotationX":-60,"color":"#536026"},{"type":"cone","size":4,"height":6,"x":0,"y":28,"z":-8,"rotationX":-75,"color":"#436026"},{"type":"cone","size":3,"height":4,"x":0,"y":22,"z":-20,"rotationX":-25,"color":"#436026"},{"type":"cone","size":2,"height":3,"x":0,"y":18,"z":-28,"rotationX":-25,"color":"#436026"}]} },
            stegosaurus: { info: 'Stegosaurus', speed: 1, hp: 30, essence: 10, value: 5, render: {"shapes":[{"type":"box","width":24,"height":12,"depth":32,"x":0,"y":18,"z":0,"color":"#5D8233"},{"type":"box","width":16,"height":12,"depth":22,"x":0,"y":28,"z":24,"color":"#5D8233"},{"type":"box","width":14,"height":5,"depth":20,"x":0,"y":23,"z":26,"color":"#4E6C2A"},{"type":"box","width":12,"height":2,"depth":1,"x":0,"y":23,"z":36,"color":"#FFFFFF"},{"type":"box","width":1,"height":3,"depth":1,"x":-4,"y":22,"z":35,"color":"#FFFFFF"},{"type":"box","width":1,"height":3,"depth":1,"x":-2,"y":22,"z":35,"color":"#FFFFFF"},{"type":"box","width":1,"height":3,"depth":1,"x":0,"y":22,"z":35,"color":"#FFFFFF"},{"type":"box","width":1,"height":3,"depth":1,"x":2,"y":22,"z":35,"color":"#FFFFFF"},{"type":"box","width":1,"height":3,"depth":1,"x":4,"y":22,"z":35,"color":"#FFFFFF"},{"type":"sphere","size":4,"x":-9,"y":32,"z":28,"color":"#FFFF00"},{"type":"sphere","size":2,"x":-10,"y":32,"z":29,"color":"#000000"},{"type":"sphere","size":4,"x":9,"y":32,"z":28,"color":"#FFFF00"},{"type":"sphere","size":2,"x":10,"y":32,"z":29,"color":"#000000"},{"type":"box","width":8,"height":6,"depth":20,"x":0,"y":16,"z":-20,"color":"#5D8233"},{"type":"box","width":6,"height":4,"depth":16,"x":0,"y":15,"z":-38,"rotationY":0,"color":"#5D8233"},{"type":"box","width":6,"height":12,"depth":6,"x":10,"y":10,"z":10,"color":"#4E6C2A"},{"type":"box","width":6,"height":12,"depth":6,"x":10,"y":10,"z":-10,"color":"#4E6C2A"},{"type":"box","width":6,"height":12,"depth":6,"x":-10,"y":10,"z":10,"color":"#4E6C2A"},{"type":"box","width":6,"height":12,"depth":6,"x":-10,"y":10,"z":-10,"color":"#4E6C2A"},{"type":"box","width":8,"height":3,"depth":10,"x":10,"y":3,"z":12,"color":"#4E6C2A"},{"type":"box","width":8,"height":3,"depth":10,"x":10,"y":3,"z":-8,"color":"#4E6C2A"},{"type":"box","width":8,"height":3,"depth":10,"x":-10,"y":3,"z":12,"color":"#4E6C2A"},{"type":"box","width":8,"height":3,"depth":10,"x":-10,"y":3,"z":-8,"color":"#4E6C2A"},{"type":"box","width":4,"height":6,"depth":4,"x":12,"y":20,"z":10,"color":"#4E6C2A"},{"type":"box","width":4,"height":6,"depth":4,"x":-12,"y":20,"z":10,"color":"#4E6C2A"},{"type":"box","width":3,"height":3,"depth":1,"x":12,"y":20,"z":13,"color":"#A0A0A0"},{"type":"box","width":3,"height":3,"depth":1,"x":-12,"y":20,"z":13,"color":"#A0A0A0"},{"type":"cone","size":6,"height":8,"x":0,"y":27,"z":0,"rotationX":0,"color":"#436026"},{"type":"cone","size":6,"height":8,"x":0,"y":26,"z":-10,"rotationX":0,"color":"#436026"},{"type":"cone","size":5,"height":6,"x":0,"y":22,"z":-24,"rotationX":0,"color":"#436026"},{"type":"cone","size":4,"height":5,"x":0,"y":20,"z":-36,"rotationX":0,"color":"#436026"},{"type":"cone","size":6,"height":8,"x":0,"y":34,"z":20,"rotationX":0,"color":"#436026"}]} },
            dragon: { info: 'Dragon', hp: 500, speed: 0.5, essence: 50, value: 50, boss: true, render: {"shapes":[{"type":"box","width":18,"height":10,"depth":28,"x":0,"y":20,"z":-6.4,"rotationX":-19,"color":"#8B0000"},{"type":"box","width":14,"height":8,"depth":20,"x":0,"y":30,"z":18,"rotationX":-10,"color":"#8B0000"},{"type":"box","width":12,"height":6,"depth":16,"x":0,"y":40,"z":30,"rotationX":-20,"color":"#8B0000"},{"type":"cone","size":10,"height":20,"x":0,"y":42,"z":42,"rotationX":90,"color":"#8B0000"},{"type":"box","width":12,"height":6,"depth":16,"x":0,"y":14,"z":-24,"rotationX":-5,"color":"#8B0000"},{"type":"box","width":8,"height":4,"depth":20,"x":0,"y":10,"z":-42,"rotationX":-5,"color":"#8B0000"},{"type":"cone","size":6,"height":12,"x":0,"y":8,"z":-54,"rotationX":-90,"color":"#8B0000"},{"type":"box","width":22,"height":10,"depth":18,"x":0,"y":26,"z":0,"rotationX":-14,"color":"#8B0000"},{"type":"sphere","size":8,"x":0,"y":46,"z":34,"color":"#A52A2A"},{"type":"sphere","size":3,"x":-4,"y":48,"z":36,"color":"#FFFF00"},{"type":"sphere","size":1.5,"x":-4,"y":48,"z":37,"color":"#000000"},{"type":"sphere","size":3,"x":4,"y":48,"z":36,"color":"#FFFF00"},{"type":"sphere","size":1.5,"x":4,"y":48,"z":37,"color":"#000000"},{"type":"box","width":5,"height":3,"depth":10,"x":0,"y":40,"z":40,"color":"#A52A2A"},{"type":"box","width":4,"height":2,"depth":1,"x":0,"y":42,"z":46,"color":"#FFFFFF"},{"type":"box","width":1,"height":2,"depth":1,"x":-2,"y":40,"z":46,"color":"#FFFFFF"},{"type":"box","width":1,"height":2,"depth":1,"x":0,"y":40,"z":46,"color":"#FFFFFF"},{"type":"box","width":1,"height":2,"depth":1,"x":2,"y":40,"z":46,"color":"#FFFFFF"},{"type":"box","width":5,"height":12,"depth":5,"x":10,"y":12,"z":0,"color":"#8B0000"},{"type":"box","width":5,"height":12,"depth":5,"x":-10,"y":12,"z":0,"color":"#8B0000"},{"type":"box","width":5,"height":12,"depth":5,"x":10,"y":12,"z":-16,"color":"#8B0000"},{"type":"box","width":5,"height":12,"depth":5,"x":-10,"y":12,"z":-16,"color":"#8B0000"},{"type":"box","width":7,"height":2,"depth":7,"x":10,"y":5,"z":0,"color":"#8B0000"},{"type":"box","width":7,"height":2,"depth":7,"x":-10,"y":5,"z":0,"color":"#8B0000"},{"type":"box","width":7,"height":2,"depth":7,"x":10,"y":6,"z":-16,"color":"#8B0000"},{"type":"box","width":7,"height":2,"depth":7,"x":-10,"y":6,"z":-16,"color":"#8B0000"},{"type":"cone","size":6,"height":10,"x":0,"y":36,"z":10,"rotationX":-20,"color":"#A52A2A"},{"type":"cone","size":6,"height":10,"x":0,"y":34,"z":-8,"rotationX":-32,"color":"#A52A2A"},{"type":"cone","size":5,"height":8,"x":0,"y":22,"z":-24,"rotationX":-75,"color":"#A52A2A"},{"type":"cone","size":4,"height":6,"x":0,"y":16,"z":-38,"rotationX":-75,"color":"#A52A2A"},{"type":"box","width":20,"height":1,"depth":28,"x":18,"y":24,"z":-4,"rotationY":15,"rotationZ":12,"color":"#A52A2A"},{"type":"box","width":20,"height":1,"depth":28,"x":-18,"y":24,"z":-4,"rotationY":-15,"rotationZ":-12,"color":"#A52A2A"},{"type":"box","width":18,"height":1,"depth":24,"x":18,"y":27,"z":-4,"rotationY":15,"rotationZ":24,"color":"#A52A2A"},{"type":"box","width":18,"height":1,"depth":24,"x":-18,"y":27,"z":-4,"rotationY":-15,"rotationZ":-24,"color":"#A52A2A"},{"type":"box","width":16,"height":1,"depth":20,"x":18,"y":30,"z":-4,"rotationY":15,"rotationZ":36,"color":"#A52A2A"},{"type":"box","width":16,"height":1,"depth":20,"x":-18,"y":30,"z":-4,"rotationY":-15,"rotationZ":-36,"color":"#A52A2A"}]} },
            pterodactyl: { info: 'Pterodactyl', speed: 2, value: 10, hp: 5, essence: 5, render: {"shapes":[{"type":"cylinder","size":7.199999999999999,"height":14.399999999999999,"x":0,"y":47.48726562500001,"z":-2.3686718749999995,"color":"#7d6d5e","rotationX":90,"rotationZ":0},{"type":"cylinder","size":2.88,"height":12,"x":0,"y":49.294765625,"z":9.631328125000001,"color":"#7D6B5D","rotationX":45,"rotationZ":0},{"type":"cone","size":2.4,"height":10.56,"x":0,"y":52.76726562500002,"z":15.871328125,"color":"#7D6B5D","rotationX":120,"rotationZ":0},{"type":"cone","size":0.96,"height":9.6,"x":0,"y":59.48726562500001,"z":13.471328125,"color":"#6D5D4D","rotationX":0,"rotationZ":0},{"type":"box","width":24,"height":0.48,"depth":9.6,"x":-12,"y":47.48726562500001,"z":-2.3686718749999995,"color":"#8D7B6D","rotationY":0,"rotationZ":15},{"type":"box","width":24,"height":0.48,"depth":9.6,"x":12,"y":47.48726562500001,"z":-2.3686718749999995,"color":"#8D7B6D","rotationY":0,"rotationZ":-15},{"type":"box","width":4,"height":0.24,"depth":2,"x":-12,"y":47,"z":3,"color":"#8D7B6D","rotationY":90,"rotationZ":15},{"type":"box","width":10,"height":0.24,"depth":6,"x":25,"y":43.2,"z":-4.1,"color":"#8D7B6D","rotationY":40,"rotationZ":-30,"rotationX":16},{"type":"cone","size":1.92,"height":12,"x":0,"y":47.48726562500001,"z":-16.851171875000002,"color":"#7D6B5D","rotationX":-90,"rotationZ":0},{"type":"box","width":5.76,"height":0.48,"depth":4.8,"x":0,"y":47.48726562500001,"z":-19.648671875,"color":"#8D7B6D","rotationX":0,"rotationZ":0},{"type":"cylinder","size":0.72,"height":5.76,"x":-2.4,"y":42.68726562500001,"z":-4.768671874999999,"color":"#6D5D4D","rotationX":20,"rotationZ":0},{"type":"cylinder","size":0.72,"height":5.76,"x":2.4,"y":42.68726562500001,"z":-4.768671874999999,"color":"#6D5D4D","rotationX":20,"rotationZ":0},{"type":"cone","size":1.44,"height":2.4,"x":-2.4,"y":40.04726562500001,"z":-4.851171875,"color":"#6D5D4D","rotationX":-60,"rotationZ":0},{"type":"cone","size":1.44,"height":2.4,"x":2.4,"y":40.04726562500001,"z":-4.851171875,"color":"#6D5D4D","rotationX":-60,"rotationZ":0},{"type":"sphere","size":0.72,"x":-0.96,"y":54.68726562500001,"z":15.391328125000001,"color":"#000000"},{"type":"sphere","size":0.72,"x":0.96,"y":54.68726562500001,"z":15.391328125000001,"color":"#000000"},{"type":"box","width":4,"height":0.24,"depth":2,"x":12,"y":47,"z":3,"color":"#8D7B6D","rotationY":90,"rotationZ":15},{"type":"box","width":10,"height":0.24,"depth":6,"x":-25,"y":43.2,"z":-4.1,"color":"#8D7B6D","rotationY":-40,"rotationZ":30,"rotationX":16}]} },
        },
        environment: {
            tree: { info: 'Tree', render: {"shapes":[{"type":"cylinder","size":5,"color":"#733f17","x":0,"y":5,"z":0,"rotationX":0,"rotationY":0,"rotationZ":0,"height":10},{"type":"cone","size":20,"color":"#018314","x":0,"y":25,"z":0,"rotationX":0,"rotationY":0,"rotationZ":0,"height":30},{"type":"cone","size":17.5,"color":"#018314","x":0,"y":30,"z":0,"rotationX":0,"rotationY":0,"rotationZ":0,"height":20},{"type":"cone","size":7.5,"color":"#018314","x":0,"y":37.5,"z":0,"rotationX":0,"rotationY":0,"rotationZ":0,"height":7.5}]} },
            rock: { info: 'Rock', render: {"shapes":[{"type":"tetrahedron","size":16,"color":"#666666","x":3.5,"y":2,"z":2.5,"rotationX":50,"rotationY":140,"rotationZ":10},{"type":"tetrahedron","size":12,"color":"#5b5b5b","x":10.5,"y":2,"z":7.5,"rotationX":50,"rotationY":150,"rotationZ":10}]} },
        },
        upgrades: {
            // Bat Swarm Upgrades
            sentryFrenzy: { desc: '+25% Attack Speed', value: .75 },
            sentryIntelligence: { desc: '+15% Damage and +10% Range', damage: 1.15, range: 1.1 },
            dematerializeSentry: { desc: 'Heal 0.5% Core HP per hit', leech: 0.005 },

            // Necromancer Upgrades
            necroSummon: { desc: '10% chance to raise a skeleton when killing an enemy', summonChance: 1.1 },
            necroMastery: { desc: '+20% Range and projectiles pierce one additional enemy', range: 1.2, piercing: 1 },

            // Shadow Turret Upgrades
            shadowPierce: { desc: 'Projectiles pierce 2 additional enemies', piercing: 2 },
            overCharge: { desc: '+30% Range', range: 1.3 },
            shadowCrit: { desc: '+10% Critical Chance', critChance: 0.1 },

            // Soul Pyre Upgrades
            pyreBurn: { desc: '+50% Burn Damage', burnDamage: 1 },
            pyreBlaze: { desc: '+20% Damage and +10% Attack Speed', damage: 1.2, attackSpeed: 1.1 },
            pyreSoul: { desc: '+10% splash radius', splashRadius: 1.1 },

            // Mist Shrine Upgrades
            mistSlow: { desc: 'Slow effect increased by 20%', slowEffect: 0.8 },
            mistSpread: { desc: '+25% Range and +1 Piercing', range: 1.25, piercing: 1 },

            // Global Upgrades
            bloodEff: { desc: 'Towers cost 15% less Blood Shards', value: 0.85 },
            bloodCore: { desc: 'Increase max Core HP by 20% and heal 30 HP', maxHpMultiplier: 1.2, healAmount: 30 },
            bloodHarvest: { desc: 'Gain 25% more Blood Shards from enemies', value: 1.25 },
            essenceExtraction: { desc: 'Gain 25% more Essence from enemies', value: 1.25 },
            bloodFrenzy: { desc: 'All towers deal 20% more damage', damageMultiplier: 1.2 },
            bloodRegeneration: { desc: 'All healing effects are 25% more effective', healingMultiplier: 1.25 },
            essenceOverflow: { desc: 'Gain 10% more Essence when above 50% Core HP', value: 1.1 },
            darkResilience: { desc: 'Towers take 20% less damage from enemy abilities', towerDamageReduction: 0.8 }
        },
        effects: {
            slow: { id: 'slow', title: 'Slow', desc: 'Target is slowed', stat: 'speed', lifeTime: 100 }
        }
    }
    const effects = {
        slow: (stats, additiveStats, multiplicitiveStats, slowAmount) => {
            stats[gameConfig.effects.slow.stat] *= slowAmount;
        }
    }
    const upgrades = [
        // Bat Swarm Upgrades
        new Upgrade(
            'sentryFrenzy',
            'Sentry Frenzy',
            'Sentry Swarm: ' + gameConfig.upgrades.sentryFrenzy.desc,
            '🦇',
            'sentry',
            (state) => true,
            (stats, additiveStats, multiplicitiveStats) => {
                multiplicitiveStats['attackSpeed'].push(gameConfig.upgrades.sentryFrenzy.value);
            }
        ),
        new Upgrade(
            'sentryIntelligence',
            'Sentry Intelligence',
            'Sentry Swarm: ' + gameConfig.upgrades.sentryIntelligence.desc,
            '🦇',
            'sentry',
            (state) => true,
            (stats, additiveStats, multiplicitiveStats) => {            
                multiplicitiveStats['damage'].push(gameConfig.upgrades.sentryIntelligence.damage);
                multiplicitiveStats['range'].push(gameConfig.upgrades.sentryIntelligence.range);        
            }
        ),

        // Necromancer Upgrades
        new Upgrade(
            'necroSummon',
            'Raise Dead',
            'Necromancer: ' + gameConfig.upgrades.necroSummon.desc,
            '💀',
            'fabricator',
            (state) => true,
            (stats, additiveStats, multiplicitiveStats) => {
                stats.summonChance = 1;
                if(!additiveStats.summonChance) additiveStats.summonChance = [];
                additiveStats['summonChance'].push(gameConfig.upgrades.necroSummon.summonChance);
            }
        ),

        // Shadow Turret Upgrades
        new Upgrade(
            'overCharge',
            'Overcharge',
            'Tesla Coil: ' + gameConfig.upgrades.overCharge.desc,
            '📏',
            'teslaCoil',
            (state) => true,
            (stats, additiveStats, multiplicitiveStats) => {
                additiveStats['range'].push(gameConfig.upgrades.overCharge.range);
            }
        ),

        // Soul Pyre Upgrades
        new Upgrade(
            'pyreSoul',
            'Radiant Soul',
            'Soul Pyre: ' + gameConfig.upgrades.pyreSoul.desc,
            '💉',
            'soulPyre',
            (state) => true,
            (stats, additiveStats, multiplicitiveStats) => {
                additiveStats['splashRadius'].push(gameConfig.upgrades.pyreSoul.splashRadius);
            }
        ),

        // Mist Shrine Upgrades
        new Upgrade(
            'mistSlow',
            'Chilling Mist',
            'Mist Shrine: ' + gameConfig.upgrades.mistSlow.desc,
            '❄️',
            'mistShrine',
            (state) => true,
            (stats, additiveStats, multiplicitiveStats) => {
                multiplicitiveStats['slowEffect'].push(gameConfig.upgrades.mistSlow.slowEffect);
            }
        ),
        // Global Upgrades
        new Upgrade(
            'homeReinforcement',
            'Reinforcement',
            gameConfig.upgrades.bloodCore.desc,
            '🛡️',
            'global',
            (state) => true,
            (stats) => {
                stats.maxBloodCoreHP *= gameConfig.upgrades.bloodCore.maxHpMultiplier;
            },
            (state) => {
                state.bloodCoreHP = Math.min(state.stats.maxBloodCoreHP, state.bloodCoreHP + gameConfig.upgrades.bloodCore.healAmount);
            }
        ),
        new Upgrade(
            'essenceExtraction',
            'Essence Extraction',
            gameConfig.upgrades.essenceExtraction.desc,
            '🔮',
            'global',
            (state) => true,
            (stats) => {
                stats.essenceMultiplier *= gameConfig.upgrades.essenceExtraction.value;
            }
        ),
        new Upgrade(
            'essenceOverflow',
            'Essence Overflow',
            gameConfig.upgrades.essenceOverflow.desc,
            '🔮',
            'global',
            (state) => state.bloodCoreHP > state.stats.maxBloodCoreHP / 2,
            (stats) => {
                stats.essenceMultiplier *= gameConfig.upgrades.essenceOverflow.value;
            }
        ),

    ];

    const game = new Game();  
    async function main() {  
        await game.init();
        document.getElementById('startGameBtn').removeAttribute('style');
        document.getElementById('startGameBtn').addEventListener('click', (e) => {    
            game.state.isPaused = false;
            e.target.setAttribute('style','display:none;');
        });
        document.querySelector("#gameOverMenu .menu-button").addEventListener("click", (e) => {
            game.reset();
        });
        
        document.querySelector("#victoryMenu .menu-button").addEventListener("click", (e) => {
            game.reset();
        });
    }

    function resetGame() {
        game.reset();
    }

    window.onload = main; // Or attach to a start button
</script>
	
	
</body>

</html>
